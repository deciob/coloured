{"absId":"curl/domReady","text":"/** MIT License (c) copyright 2010-2013 B Cavalier & J Hann */\n\n/**\n * curl domReady\n *\n * Licensed under the MIT License at:\n * \t\thttp://www.opensource.org/licenses/mit-license.php\n */\n\n/**\n * usage:\n *  require(['ModuleA', 'curl/domReady'], function (ModuleA, domReady) {\n * \t\tvar a = new ModuleA();\n * \t\tdomReady(function () {\n * \t\t\tdocument.body.appendChild(a.domNode);\n * \t\t});\n * \t});\n *\n * also: check out curl's domReady! plugin\n *\n * HT to Bryan Forbes who wrote the initial domReady code:\n * http://www.reigndropsfall.net/\n *\n */\n(function (global, doc) {\n\n\tvar\n\t\treadyState = 'readyState',\n\t\t// keep these quoted so closure compiler doesn't squash them\n\t\treadyStates = { 'loaded': 1, 'interactive': 1, 'complete': 1 },\n\t\tcallbacks = [],\n\t\tfixReadyState = doc && typeof doc[readyState] != \"string\",\n\t\t// IE needs this cuz it won't stop setTimeout if it's already queued up\n\t\tcompleted = false,\n\t\tpollerTime = 10,\n\t\taddEvent,\n\t\tremover,\n\t\tremovers = [],\n\t\tpollerHandle,\n\t\tundef;\n\n\tfunction ready () {\n\t\tcompleted = true;\n\t\tclearTimeout(pollerHandle);\n\t\twhile (remover = removers.pop()) remover();\n\t\tif (fixReadyState) {\n\t\t\tdoc[readyState] = \"complete\";\n\t\t}\n\t\t// callback all queued callbacks\n\t\tvar cb;\n\t\twhile ((cb = callbacks.shift())) {\n\t\t\tcb();\n\t\t}\n\t}\n\n\tvar testEl;\n\tfunction isDomManipulable () {\n\t\t// question: implement Diego Perini's IEContentLoaded instead?\n\t\t// answer: The current impl seems more future-proof rather than a\n\t\t// non-standard method (doScroll). i don't care if the rest of the js\n\t\t// world is using doScroll! They can have fun repairing their libs when\n\t\t// the IE team removes doScroll in IE 13. :)\n\t\tif (!doc.body) return false; // no body? we're definitely not ready!\n\t\tif (!testEl) testEl = doc.createTextNode('');\n\t\ttry {\n\t\t\t// webkit needs to use body. doc\n\t\t\tdoc.body.removeChild(doc.body.appendChild(testEl));\n\t\t\ttestEl = undef;\n\t\t\treturn true;\n\t\t}\n\t\tcatch (ex) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction checkDOMReady (e) {\n\t\tvar isReady;\n\t\t// all browsers except IE will be ready when readyState == 'interactive'\n\t\t// so we also must check for document.body\n\t\tisReady = readyStates[doc[readyState]] && isDomManipulable();\n\t\tif (!completed && isReady) {\n\t\t\tready();\n\t\t}\n\t\treturn isReady;\n\t}\n\n\tfunction poller () {\n\t\tcheckDOMReady();\n\t\tif (!completed) {\n\t\t\tpollerHandle = setTimeout(poller, pollerTime);\n\t\t}\n\t}\n\n\t// select the correct event listener function. all of our supported\n\t// browsers will use one of these\n\tif ('addEventListener' in global) {\n\t\taddEvent = function (node, event) {\n\t\t\tnode.addEventListener(event, checkDOMReady, false);\n\t\t\treturn function () { node.removeEventListener(event, checkDOMReady, false); };\n\t\t};\n\t}\n\telse {\n\t\taddEvent = function (node, event) {\n\t\t\tnode.attachEvent('on' + event, checkDOMReady);\n\t\t\treturn function () { node.detachEvent(event, checkDOMReady); };\n\t\t};\n\t}\n\n\tif (doc) {\n\t\tif (!checkDOMReady()) {\n\t\t\t// add event listeners and collect remover functions\n\t\t\tremovers = [\n\t\t\t\taddEvent(global, 'load'),\n\t\t\t\taddEvent(doc, 'readystatechange'),\n\t\t\t\taddEvent(global, 'DOMContentLoaded')\n\t\t\t];\n\t\t\t// additionally, poll for readystate\n\t\t\tpollerHandle = setTimeout(poller, pollerTime);\n\t\t}\n\t}\n\n\tdefine(/*=='curl/domReady',==*/ function () {\n\n\t\t// this is simply a callback, but make it look like a promise\n\t\tfunction domReady (cb) {\n\t\t\tif (completed) cb(); else callbacks.push(cb);\n\t\t}\n\t\tdomReady['then'] = domReady;\n\t\tdomReady['amd'] = true;\n\n\t\treturn domReady;\n\n\t});\n\n}(this, this.document));\n","modules":[{"pos":3171,"count":44,"factory":true,"id":"curl/domReady"}]}