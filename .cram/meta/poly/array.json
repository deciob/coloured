{"absId":"poly/array","text":"/*\n\tArray -- a stand-alone module for using Javascript 1.6 array features\n\tin lame-o browsers that don't support Javascript 1.6\n\n\t(c) copyright 2011-2013 Brian Cavalier and John Hann\n\n\tThis module is part of the cujo.js family of libraries (http://cujojs.com/).\n\n\tLicensed under the MIT License at:\n\t\thttp://www.opensource.org/licenses/mit-license.php\n*/\n/*\n\tThis module is under 1kB when compiled/gzipped and is compatible with\n\thas() pre-processors (<400 bytes when compiled for modern browsers).\n\n\twrapper API:\n\n\tThis module will wrap native methods to normalize array calls to\n\tbe unified across js engines that support the array methods\n\tnatively with those that don't:\n\n\tdefine(['poly/lib/shim/array'], function (array) {\n\t\tvar items = [1, 2, 3];\n\t\tarray.forEach(items, function (item) {\n\t\t\tconsole.log(item);\n\t\t};\n\t});\n\n\tforEach(array, lambda [, context]);\n\tevery(array, lambda [, context]);\n\tsome(array, lambda [, context]);\n\tfilter(array, lambda [, context]);\n\tmap(array, lambda [, context]);\n\tindexOf(arr, item [, fromIndex]);\n\tlastIndexOf(arr, item [, fromIndex]);\n\treduce(arr, reduceFunc [, initialValue]);\n\treduceRight(arr, reduceFunc [, initialValue]);\n\tisArray(object)\n\n\tpolyfill API:\n\n\tYou may also use this module to augment the Array.prototype of\n\tolder js engines by loading it via the poly! plugin prefix:\n\n\tdefine(['poly!poly/lib/shim/array'], function () {\n\t\tvar items = [1, 2, 3];\n\t\titems.forEach(function (item) {\n\t\t\tconsole.log(item);\n\t\t};\n\t});\n\n\tAll of the wrapper API methods are shimmed and are reasonably close to\n\tthe ES5 specification, but may vary slightly in unforeseen edge cases:\n\n\tvar array = [1, 2, 3];\n\n\tarray.forEach(lambda [, context]);\n\tarray.every(lambda [, context]);\n\tarray.some(lambda [, context]);\n\tarray.filter(lambda [, context]);\n\tarray.map(lambda [, context]);\n\tarray.indexOf(item [, fromIndex]);\n\tarray.lastIndexOf(item [, fromIndex]);\n\tarray.reduce(reduceFunc [, initialValue]);\n\tarray.reduceRight(reduceFunc [, initialValue]);\n\tArray.isArray(object)\n\n */\n\ndefine(['./lib/_base'], function (base) {\n\"use strict\";\n\n\tvar proto = Array.prototype,\n\t\ttoString = {}.toString,\n\t\tfeatureMap,\n\t\ttoObject,\n\t\t_reduce,\n\t\t_find,\n\t\tundef;\n\n\tfeatureMap = {\n\t\t'array-foreach': 'forEach',\n\t\t'array-every': 'every',\n\t\t'array-some': 'some',\n\t\t'array-map': 'map',\n\t\t'array-filter': 'filter',\n\t\t'array-reduce': 'reduce',\n\t\t'array-reduceright': 'reduceRight',\n\t\t'array-indexof': 'indexOf',\n\t\t'array-lastindexof': 'lastIndexOf'\n\t};\n\n\ttoObject = base.createCaster(Object, 'Array');\n\n\tfunction toArrayLike (o) {\n\t\treturn (base.toString(o) == '[object String]')\n\t\t\t? o.split('')\n\t\t\t: toObject(o);\n\t}\n\n\tfunction isArray (o) {\n\t\treturn toString.call(o) == '[object Array]';\n\t}\n\n\tfunction has (feature) {\n\t\tvar prop = featureMap[feature];\n\t\treturn base.isFunction(proto[prop]);\n\t}\n\n\tfunction returnTruthy () {\n\t\treturn 1;\n\t}\n\n\tfunction returnValue (val) {\n\t\treturn val;\n\t}\n\n\t/***** iterators *****/\n\n\tfunction _iterate (arr, lambda, continueFunc, context, start, inc) {\n\n\t\tvar alo, len, i, end;\n\n\t\talo = toArrayLike(arr);\n\t\tlen = alo.length >>> 0;\n\n\t\tif (start === undef) start = 0;\n\t\tif (!inc) inc = 1;\n\t\tend = inc < 0 ? -1 : len;\n\n\t\tif (!base.isFunction(lambda)) {\n\t\t\tthrow new TypeError(lambda + ' is not a function');\n\t\t}\n\t\tif (start == end) {\n\t\t\treturn false;\n\t\t}\n\t\tif ((start <= end) ^ (inc > 0)) {\n\t\t\tthrow new TypeError('Invalid length or starting index');\n\t\t}\n\n\t\tfor (i = start; i != end; i = i + inc) {\n\t\t\tif (i in alo) {\n\t\t\t\tif (!continueFunc(lambda.call(context, alo[i], i, alo), i, alo[i])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tif (!has('array-foreach')) {\n\t\tproto.forEach = function forEach (lambda) {\n\t\t\t// arguments[+1] is to fool google closure compiler into NOT adding a function argument!\n\t\t\t_iterate(this, lambda, returnTruthy, arguments[+1]);\n\t\t};\n\t}\n\n\tif (!has('array-every')) {\n\t\tproto.every = function every (lambda) {\n\t\t\t// arguments[+1] is to fool google closure compiler into NOT adding a function argument!\n\t\t\treturn _iterate(this, lambda, returnValue, arguments[+1]);\n\t\t};\n\t}\n\n\tif (!has('array-some')) {\n\t\tproto.some = function some (lambda) {\n\t\t\t// arguments[+1] is to fool google closure compiler into NOT adding a function argument!\n\t\t\treturn _iterate(this, lambda, function (val) { return !val; }, arguments[+1]);\n\t\t};\n\t}\n\n\t/***** mutators *****/\n\n\tif(!has('array-map')) {\n\t\tproto.map = function map (lambda) {\n\t\t\tvar arr, result;\n\n\t\t\tarr = this;\n\t\t\tresult = new Array(arr.length);\n\n\t\t\t// arguments[+1] is to fool google closure compiler into NOT adding a function argument!\n\t\t\t_iterate(arr, lambda, function (val, i) { result[i] = val; return 1; }, arguments[+1]);\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\tif (!has('array-filter')) {\n\t\tproto.filter = function filter (lambda) {\n\t\t\tvar arr, result;\n\n\t\t\tarr = this;\n\t\t\tresult = [];\n\n\t\t\t_iterate(arr, lambda, function (val, i, orig) {\n\t\t\t\t// use a copy of the original value in case\n\t\t\t\t// the lambda function changed it\n\t\t\t\tif (val) {\n\t\t\t\t\tresult.push(orig);\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}, arguments[1]);\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\t/***** reducers *****/\n\n\tif (!has('array-reduce') || !has('array-reduceright')) {\n\n\t\t_reduce = function _reduce (reduceFunc, inc, initialValue, hasInitialValue) {\n\t\t\tvar reduced, startPos, initialValuePos;\n\n\t\t\tstartPos = initialValuePos = inc > 0 ? -1 : toArrayLike(this).length >>> 0;\n\n\t\t\t// If no initialValue, use first item of array (we know length !== 0 here)\n\t\t\t// and adjust i to start at second item\n\t\t\tif (!hasInitialValue) {\n\t\t\t\t_iterate(this, returnValue, function (val, i) {\n\t\t\t\t\treduced = val;\n\t\t\t\t\tinitialValuePos = i;\n\t\t\t\t}, null, startPos + inc, inc);\n\t\t\t\tif (initialValuePos == startPos) {\n\t\t\t\t\t// no intial value and no items in array!\n\t\t\t\t\tthrow new TypeError();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// If initialValue provided, use it\n\t\t\t\treduced = initialValue;\n\t\t\t}\n\n\t\t\t// Do the actual reduce\n\t\t\t_iterate(this, function (item, i, arr) {\n\t\t\t\treduced = reduceFunc(reduced, item, i, arr);\n\t\t\t}, returnTruthy, null, initialValuePos + inc, inc);\n\n\t\t\t// we have a reduced value!\n\t\t\treturn reduced;\n\t\t};\n\n\t\tif (!has('array-reduce')) {\n\t\t\tproto.reduce = function reduce (reduceFunc /*, initialValue */) {\n\t\t\t\treturn _reduce.call(this, reduceFunc, 1, arguments[+1], arguments.length > 1);\n\t\t\t};\n\t\t}\n\n\t\tif (!has('array-reduceright')) {\n\t\t\tproto.reduceRight = function reduceRight (reduceFunc /*, initialValue */) {\n\t\t\t\treturn _reduce.call(this, reduceFunc, -1, arguments[+1], arguments.length > 1);\n\t\t\t};\n\t\t}\n\t}\n\n\t/***** finders *****/\n\n\tif (!has('array-indexof') || !has('array-lastindexof')) {\n\n\t\t_find = function _find (arr, item, from, forward) {\n\t\t\tvar len = toArrayLike(arr).length >>> 0, foundAt = -1;\n\n\t\t\t// convert to number, or default to start or end positions\n\t\t\tfrom = isNaN(from) ? (forward ? 0 : len - 1) : Number(from);\n\t\t\t// negative means it's an offset from the end position\n\t\t\tif (from < 0) {\n\t\t\t\tfrom = len + from - 1;\n\t\t\t}\n\n\t\t\t_iterate(arr, returnValue, function (val, i) {\n\t\t\t\tif (val === item) {\n\t\t\t\t\tfoundAt = i;\n\t\t\t\t}\n\t\t\t\treturn foundAt == -1;\n\t\t\t}, null, from, forward ? 1 : -1);\n\n\t\t\treturn foundAt;\n\t\t};\n\n\t\tif (!has('array-indexof')) {\n\t\t\tproto.indexOf = function indexOf (item) {\n\t\t\t\t// arguments[+1] is to fool google closure compiler into NOT adding a function argument!\n\t\t\t\treturn _find(this, item, arguments[+1], true);\n\t\t\t};\n\t\t}\n\n\t\tif (!has('array-lastindexof')) {\n\t\t\tproto.lastIndexOf = function lastIndexOf (item) {\n\t\t\t\t// arguments[+1] is to fool google closure compiler into NOT adding a function argument!\n\t\t\t\treturn _find(this, item, arguments[+1], false);\n\t\t\t};\n\t\t}\n\t}\n\n\tif (!Array.isArray) {\n\t\tArray.isArray = isArray;\n\t}\n\n});\n","modules":[{"pos":2009,"count":40,"depList":["poly/lib/_base"],"factory":true,"argList":["base"],"id":"poly/array"}]}