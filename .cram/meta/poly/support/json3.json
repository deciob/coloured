{"absId":"poly/support/json3","text":"/*! JSON v3.2.4 | http://bestiejs.github.com/json3 | Copyright 2012, Kit Cambridge | http://kit.mit-license.org */\n;(function () {\n  // Convenience aliases.\n  var getClass = {}.toString, isProperty, forEach, undef;\n\n  // Detect the `define` function exposed by asynchronous module loaders. The\n  // strict `define` check is necessary for compatibility with `r.js`.\n  var isLoader = typeof define === \"function\" && define.amd, JSON3 = !isLoader && typeof exports == \"object\" && exports;\n\n  if (JSON3 || isLoader) {\n    if (typeof JSON == \"object\" && JSON) {\n      // Delegate to the native `stringify` and `parse` implementations in\n      // asynchronous module loaders and CommonJS environments.\n      if (isLoader) {\n        JSON3 = JSON;\n      } else {\n        JSON3.stringify = JSON.stringify;\n        JSON3.parse = JSON.parse;\n      }\n    } else if (isLoader) {\n      JSON3 = this.JSON = {};\n    }\n  } else {\n    // Export for web browsers and JavaScript engines.\n    JSON3 = this.JSON || (this.JSON = {});\n  }\n\n  // Local variables.\n  var Escapes, toPaddedString, quote, serialize;\n  var fromCharCode, Unescapes, abort, lex, get, walk, update, Index, Source;\n\n  // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\n  var isExtended = new Date(-3509827334573292), floor, Months, getDay;\n\n  try {\n    // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\n    // results for certain dates in Opera >= 10.53.\n    isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() == 1 &&\n      // Safari < 2.0.2 stores the internal millisecond time value correctly,\n      // but clips the values returned by the date methods to the range of\n      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\n      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\n  } catch (exception) {}\n\n  // Internal: Determines whether the native `JSON.stringify` and `parse`\n  // implementations are spec-compliant. Based on work by Ken Snyder.\n  function has(name) {\n    var stringifySupported, parseSupported, value, serialized = '{\"A\":[1,true,false,null,\"\\\\u0000\\\\b\\\\n\\\\f\\\\r\\\\t\"]}', all = name == \"json\";\n    if (all || name == \"json-stringify\" || name == \"json-parse\") {\n      // Test `JSON.stringify`.\n      if (name == \"json-stringify\" || all) {\n        if ((stringifySupported = typeof JSON3.stringify == \"function\" && isExtended)) {\n          // A test function object with a custom `toJSON` method.\n          (value = function () {\n            return 1;\n          }).toJSON = value;\n          try {\n            stringifySupported =\n              // Firefox 3.1b1 and b2 serialize string, number, and boolean\n              // primitives as object literals.\n              JSON3.stringify(0) === \"0\" &&\n              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\n              // literals.\n              JSON3.stringify(new Number()) === \"0\" &&\n              JSON3.stringify(new String()) == '\"\"' &&\n              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\n              // does not define a canonical JSON representation (this applies to\n              // objects with `toJSON` properties as well, *unless* they are nested\n              // within an object or array).\n              JSON3.stringify(getClass) === undef &&\n              // IE 8 serializes `undefined` as `\"undefined\"`. Safari <= 5.1.7 and\n              // FF 3.1b3 pass this test.\n              JSON3.stringify(undef) === undef &&\n              // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\n              // respectively, if the value is omitted entirely.\n              JSON3.stringify() === undef &&\n              // FF 3.1b1, 2 throw an error if the given value is not a number,\n              // string, array, object, Boolean, or `null` literal. This applies to\n              // objects with custom `toJSON` methods as well, unless they are nested\n              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\n              // methods entirely.\n              JSON3.stringify(value) === \"1\" &&\n              JSON3.stringify([value]) == \"[1]\" &&\n              // Prototype <= 1.6.1 serializes `[undefined]` as `\"[]\"` instead of\n              // `\"[null]\"`.\n              JSON3.stringify([undef]) == \"[null]\" &&\n              // YUI 3.0.0b1 fails to serialize `null` literals.\n              JSON3.stringify(null) == \"null\" &&\n              // FF 3.1b1, 2 halts serialization if an array contains a function:\n              // `[1, true, getClass, 1]` serializes as \"[1,true,],\". These versions\n              // of Firefox also allow trailing commas in JSON objects and arrays.\n              // FF 3.1b3 elides non-JSON values from objects and arrays, unless they\n              // define custom `toJSON` methods.\n              JSON3.stringify([undef, getClass, null]) == \"[null,null,null]\" &&\n              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\n              // where character escape codes are expected (e.g., `\\b` => `\\u0008`).\n              JSON3.stringify({ \"A\": [value, true, false, null, \"\\0\\b\\n\\f\\r\\t\"] }) == serialized &&\n              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\n              JSON3.stringify(null, value) === \"1\" &&\n              JSON3.stringify([1, 2], null, 1) == \"[\\n 1,\\n 2\\n]\" &&\n              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\n              // serialize extended years.\n              JSON3.stringify(new Date(-8.64e15)) == '\"-271821-04-20T00:00:00.000Z\"' &&\n              // The milliseconds are optional in ES 5, but required in 5.1.\n              JSON3.stringify(new Date(8.64e15)) == '\"+275760-09-13T00:00:00.000Z\"' &&\n              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\n              // four-digit years instead of six-digit years. Credits: @Yaffle.\n              JSON3.stringify(new Date(-621987552e5)) == '\"-000001-01-01T00:00:00.000Z\"' &&\n              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\n              // values less than 1000. Credits: @Yaffle.\n              JSON3.stringify(new Date(-1)) == '\"1969-12-31T23:59:59.999Z\"';\n          } catch (exception) {\n            stringifySupported = false;\n          }\n        }\n        if (!all) {\n          return stringifySupported;\n        }\n      }\n      // Test `JSON.parse`.\n      if (name == \"json-parse\" || all) {\n        if (typeof JSON3.parse == \"function\") {\n          try {\n            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\n            // Conforming implementations should also coerce the initial argument to\n            // a string prior to parsing.\n            if (JSON3.parse(\"0\") === 0 && !JSON3.parse(false)) {\n              // Simple parsing test.\n              value = JSON3.parse(serialized);\n              if ((parseSupported = value.A.length == 5 && value.A[0] == 1)) {\n                try {\n                  // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\n                  parseSupported = !JSON3.parse('\"\\t\"');\n                } catch (exception) {}\n                if (parseSupported) {\n                  try {\n                    // FF 4.0 and 4.0.1 allow leading `+` signs, and leading and\n                    // trailing decimal points. FF 4.0, 4.0.1, and IE 9-10 also\n                    // allow certain octal literals.\n                    parseSupported = JSON3.parse(\"01\") != 1;\n                  } catch (exception) {}\n                }\n              }\n            }\n          } catch (exception) {\n            parseSupported = false;\n          }\n        }\n        if (!all) {\n          return parseSupported;\n        }\n      }\n      return stringifySupported && parseSupported;\n    }\n  }\n\n  if (!has(\"json\")) {\n    // Define additional utility methods if the `Date` methods are buggy.\n    if (!isExtended) {\n      floor = Math.floor;\n      // A mapping between the months of the year and the number of days between\n      // January 1st and the first of the respective month.\n      Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n      // Internal: Calculates the number of days between the Unix epoch and the\n      // first day of the given month.\n      getDay = function (year, month) {\n        return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\n      };\n    }\n    \n    // Internal: Determines if a property is a direct property of the given\n    // object. Delegates to the native `Object#hasOwnProperty` method.\n    if (!(isProperty = {}.hasOwnProperty)) {\n      isProperty = function (property) {\n        var members = {}, constructor;\n        if ((members.__proto__ = null, members.__proto__ = {\n          // The *proto* property cannot be set multiple times in recent\n          // versions of Firefox and SeaMonkey.\n          \"toString\": 1\n        }, members).toString != getClass) {\n          // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but\n          // supports the mutable *proto* property.\n          isProperty = function (property) {\n            // Capture and break the object's prototype chain (see section 8.6.2\n            // of the ES 5.1 spec). The parenthesized expression prevents an\n            // unsafe transformation by the Closure Compiler.\n            var original = this.__proto__, result = property in (this.__proto__ = null, this);\n            // Restore the original prototype chain.\n            this.__proto__ = original;\n            return result;\n          };\n        } else {\n          // Capture a reference to the top-level `Object` constructor.\n          constructor = members.constructor;\n          // Use the `constructor` property to simulate `Object#hasOwnProperty` in\n          // other environments.\n          isProperty = function (property) {\n            var parent = (this.constructor || constructor).prototype;\n            return property in this && !(property in parent && this[property] === parent[property]);\n          };\n        }\n        members = null;\n        return isProperty.call(this, property);\n      };\n    }\n\n    // Internal: Normalizes the `for...in` iteration algorithm across\n    // environments. Each enumerated key is yielded to a `callback` function.\n    forEach = function (object, callback) {\n      var size = 0, Properties, members, property, forEach;\n\n      // Tests for bugs in the current environment's `for...in` algorithm. The\n      // `valueOf` property inherits the non-enumerable flag from\n      // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\n      (Properties = function () {\n        this.valueOf = 0;\n      }).prototype.valueOf = 0;\n\n      // Iterate over a new instance of the `Properties` class.\n      members = new Properties();\n      for (property in members) {\n        // Ignore all properties inherited from `Object.prototype`.\n        if (isProperty.call(members, property)) {\n          size++;\n        }\n      }\n      Properties = members = null;\n\n      // Normalize the iteration algorithm.\n      if (!size) {\n        // A list of non-enumerable properties inherited from `Object.prototype`.\n        members = [\"valueOf\", \"toString\", \"toLocaleString\", \"propertyIsEnumerable\", \"isPrototypeOf\", \"hasOwnProperty\", \"constructor\"];\n        // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\n        // properties.\n        forEach = function (object, callback) {\n          var isFunction = getClass.call(object) == \"[object Function]\", property, length;\n          for (property in object) {\n            // Gecko <= 1.0 enumerates the `prototype` property of functions under\n            // certain conditions; IE does not.\n            if (!(isFunction && property == \"prototype\") && isProperty.call(object, property)) {\n              callback(property);\n            }\n          }\n          // Manually invoke the callback for each non-enumerable property.\n          for (length = members.length; property = members[--length]; isProperty.call(object, property) && callback(property));\n        };\n      } else if (size == 2) {\n        // Safari <= 2.0.4 enumerates shadowed properties twice.\n        forEach = function (object, callback) {\n          // Create a set of iterated properties.\n          var members = {}, isFunction = getClass.call(object) == \"[object Function]\", property;\n          for (property in object) {\n            // Store each property name to prevent double enumeration. The\n            // `prototype` property of functions is not enumerated due to cross-\n            // environment inconsistencies.\n            if (!(isFunction && property == \"prototype\") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {\n              callback(property);\n            }\n          }\n        };\n      } else {\n        // No bugs detected; use the standard `for...in` algorithm.\n        forEach = function (object, callback) {\n          var isFunction = getClass.call(object) == \"[object Function]\", property, isConstructor;\n          for (property in object) {\n            if (!(isFunction && property == \"prototype\") && isProperty.call(object, property) && !(isConstructor = property === \"constructor\")) {\n              callback(property);\n            }\n          }\n          // Manually invoke the callback for the `constructor` property due to\n          // cross-environment inconsistencies.\n          if (isConstructor || isProperty.call(object, (property = \"constructor\"))) {\n            callback(property);\n          }\n        };\n      }\n      return forEach(object, callback);\n    };\n\n    // Public: Serializes a JavaScript `value` as a JSON string. The optional\n    // `filter` argument may specify either a function that alters how object and\n    // array members are serialized, or an array of strings and numbers that\n    // indicates which properties should be serialized. The optional `width`\n    // argument may be either a string or number that specifies the indentation\n    // level of the output.\n    if (!has(\"json-stringify\")) {\n      // Internal: A map of control characters and their escaped equivalents.\n      Escapes = {\n        \"\\\\\": \"\\\\\\\\\",\n        '\"': '\\\\\"',\n        \"\\b\": \"\\\\b\",\n        \"\\f\": \"\\\\f\",\n        \"\\n\": \"\\\\n\",\n        \"\\r\": \"\\\\r\",\n        \"\\t\": \"\\\\t\"\n      };\n\n      // Internal: Converts `value` into a zero-padded string such that its\n      // length is at least equal to `width`. The `width` must be <= 6.\n      toPaddedString = function (width, value) {\n        // The `|| 0` expression is necessary to work around a bug in\n        // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== \"0\"`.\n        return (\"000000\" + (value || 0)).slice(-width);\n      };\n\n      // Internal: Double-quotes a string `value`, replacing all ASCII control\n      // characters (characters with code unit values between 0 and 31) with\n      // their escaped equivalents. This is an implementation of the\n      // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\n      quote = function (value) {\n        var result = '\"', index = 0, symbol;\n        for (; symbol = value.charAt(index); index++) {\n          // Escape the reverse solidus, double quote, backspace, form feed, line\n          // feed, carriage return, and tab characters.\n          result += '\\\\\"\\b\\f\\n\\r\\t'.indexOf(symbol) > -1 ? Escapes[symbol] :\n            // If the character is a control character, append its Unicode escape\n            // sequence; otherwise, append the character as-is.\n            (Escapes[symbol] = symbol < \" \" ? \"\\\\u00\" + toPaddedString(2, symbol.charCodeAt(0).toString(16)) : symbol);\n        }\n        return result + '\"';\n      };\n\n      // Internal: Recursively serializes an object. Implements the\n      // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\n      serialize = function (property, object, callback, properties, whitespace, indentation, stack) {\n        var value = object[property], className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, any, result;\n        if (typeof value == \"object\" && value) {\n          className = getClass.call(value);\n          if (className == \"[object Date]\" && !isProperty.call(value, \"toJSON\")) {\n            if (value > -1 / 0 && value < 1 / 0) {\n              // Dates are serialized according to the `Date#toJSON` method\n              // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\n              // for the ISO 8601 date time string format.\n              if (getDay) {\n                // Manually compute the year, month, date, hours, minutes,\n                // seconds, and milliseconds if the `getUTC*` methods are\n                // buggy. Adapted from @Yaffle's `date-shim` project.\n                date = floor(value / 864e5);\n                for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);\n                for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);\n                date = 1 + date - getDay(year, month);\n                // The `time` value specifies the time within the day (see ES\n                // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\n                // to compute `A modulo B`, as the `%` operator does not\n                // correspond to the `modulo` operation for negative numbers.\n                time = (value % 864e5 + 864e5) % 864e5;\n                // The hours, minutes, seconds, and milliseconds are obtained by\n                // decomposing the time within the day. See section 15.9.1.10.\n                hours = floor(time / 36e5) % 24;\n                minutes = floor(time / 6e4) % 60;\n                seconds = floor(time / 1e3) % 60;\n                milliseconds = time % 1e3;\n              } else {\n                year = value.getUTCFullYear();\n                month = value.getUTCMonth();\n                date = value.getUTCDate();\n                hours = value.getUTCHours();\n                minutes = value.getUTCMinutes();\n                seconds = value.getUTCSeconds();\n                milliseconds = value.getUTCMilliseconds();\n              }\n              // Serialize extended years correctly.\n              value = (year <= 0 || year >= 1e4 ? (year < 0 ? \"-\" : \"+\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +\n                \"-\" + toPaddedString(2, month + 1) + \"-\" + toPaddedString(2, date) +\n                // Months, dates, hours, minutes, and seconds should have two\n                // digits; milliseconds should have three.\n                \"T\" + toPaddedString(2, hours) + \":\" + toPaddedString(2, minutes) + \":\" + toPaddedString(2, seconds) +\n                // Milliseconds are optional in ES 5.0, but required in 5.1.\n                \".\" + toPaddedString(3, milliseconds) + \"Z\";\n            } else {\n              value = null;\n            }\n          } else if (typeof value.toJSON == \"function\" && ((className != \"[object Number]\" && className != \"[object String]\" && className != \"[object Array]\") || isProperty.call(value, \"toJSON\"))) {\n            // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\n            // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\n            // ignores all `toJSON` methods on these objects unless they are\n            // defined directly on an instance.\n            value = value.toJSON(property);\n          }\n        }\n        if (callback) {\n          // If a replacement function was provided, call it to obtain the value\n          // for serialization.\n          value = callback.call(object, property, value);\n        }\n        if (value === null) {\n          return \"null\";\n        }\n        className = getClass.call(value);\n        if (className == \"[object Boolean]\") {\n          // Booleans are represented literally.\n          return \"\" + value;\n        } else if (className == \"[object Number]\") {\n          // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\n          // `\"null\"`.\n          return value > -1 / 0 && value < 1 / 0 ? \"\" + value : \"null\";\n        } else if (className == \"[object String]\") {\n          // Strings are double-quoted and escaped.\n          return quote(value);\n        }\n        // Recursively serialize objects and arrays.\n        if (typeof value == \"object\") {\n          // Check for cyclic structures. This is a linear search; performance\n          // is inversely proportional to the number of unique nested objects.\n          for (length = stack.length; length--;) {\n            if (stack[length] === value) {\n              // Cyclic structures cannot be serialized by `JSON.stringify`.\n              throw TypeError();\n            }\n          }\n          // Add the object to the stack of traversed objects.\n          stack.push(value);\n          results = [];\n          // Save the current indentation level and indent one additional level.\n          prefix = indentation;\n          indentation += whitespace;\n          if (className == \"[object Array]\") {\n            // Recursively serialize array elements.\n            for (index = 0, length = value.length; index < length; any || (any = true), index++) {\n              element = serialize(index, value, callback, properties, whitespace, indentation, stack);\n              results.push(element === undef ? \"null\" : element);\n            }\n            result = any ? (whitespace ? \"[\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"]\" : (\"[\" + results.join(\",\") + \"]\")) : \"[]\";\n          } else {\n            // Recursively serialize object members. Members are selected from\n            // either a user-specified list of property names, or the object\n            // itself.\n            forEach(properties || value, function (property) {\n              var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\n              if (element !== undef) {\n                // According to ES 5.1 section 15.12.3: \"If `gap` {whitespace}\n                // is not the empty string, let `member` {quote(property) + \":\"}\n                // be the concatenation of `member` and the `space` character.\"\n                // The \"`space` character\" refers to the literal space\n                // character, not the `space` {width} argument provided to\n                // `JSON.stringify`.\n                results.push(quote(property) + \":\" + (whitespace ? \" \" : \"\") + element);\n              }\n              any || (any = true);\n            });\n            result = any ? (whitespace ? \"{\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"}\" : (\"{\" + results.join(\",\") + \"}\")) : \"{}\";\n          }\n          // Remove the object from the traversed object stack.\n          stack.pop();\n          return result;\n        }\n      };\n\n      // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\n      JSON3.stringify = function (source, filter, width) {\n        var whitespace, callback, properties, index, length, value;\n        if (typeof filter == \"function\" || typeof filter == \"object\" && filter) {\n          if (getClass.call(filter) == \"[object Function]\") {\n            callback = filter;\n          } else if (getClass.call(filter) == \"[object Array]\") {\n            // Convert the property names array into a makeshift set.\n            properties = {};\n            for (index = 0, length = filter.length; index < length; value = filter[index++], ((getClass.call(value) == \"[object String]\" || getClass.call(value) == \"[object Number]\") && (properties[value] = 1)));\n          }\n        }\n        if (width) {\n          if (getClass.call(width) == \"[object Number]\") {\n            // Convert the `width` to an integer and create a string containing\n            // `width` number of space characters.\n            if ((width -= width % 1) > 0) {\n              for (whitespace = \"\", width > 10 && (width = 10); whitespace.length < width; whitespace += \" \");\n            }\n          } else if (getClass.call(width) == \"[object String]\") {\n            whitespace = width.length <= 10 ? width : width.slice(0, 10);\n          }\n        }\n        // Opera <= 7.54u2 discards the values associated with empty string keys\n        // (`\"\"`) only if they are used directly within an object member list\n        // (e.g., `!(\"\" in { \"\": 1})`).\n        return serialize(\"\", (value = {}, value[\"\"] = source, value), callback, properties, whitespace, \"\", []);\n      };\n    }\n\n    // Public: Parses a JSON source string.\n    if (!has(\"json-parse\")) {\n      fromCharCode = String.fromCharCode;\n      // Internal: A map of escaped control characters and their unescaped\n      // equivalents.\n      Unescapes = {\n        \"\\\\\": \"\\\\\",\n        '\"': '\"',\n        \"/\": \"/\",\n        \"b\": \"\\b\",\n        \"t\": \"\\t\",\n        \"n\": \"\\n\",\n        \"f\": \"\\f\",\n        \"r\": \"\\r\"\n      };\n\n      // Internal: Resets the parser state and throws a `SyntaxError`.\n      abort = function() {\n        Index = Source = null;\n        throw SyntaxError();\n      };\n\n      // Internal: Returns the next token, or `\"$\"` if the parser has reached\n      // the end of the source string. A token may be a string, number, `null`\n      // literal, or Boolean literal.\n      lex = function () {\n        var source = Source, length = source.length, symbol, value, begin, position, sign;\n        while (Index < length) {\n          symbol = source.charAt(Index);\n          if (\"\\t\\r\\n \".indexOf(symbol) > -1) {\n            // Skip whitespace tokens, including tabs, carriage returns, line\n            // feeds, and space characters.\n            Index++;\n          } else if (\"{}[]:,\".indexOf(symbol) > -1) {\n            // Parse a punctuator token at the current position.\n            Index++;\n            return symbol;\n          } else if (symbol == '\"') {\n            // Advance to the next character and parse a JSON string at the\n            // current position. String tokens are prefixed with the sentinel\n            // `@` character to distinguish them from punctuators.\n            for (value = \"@\", Index++; Index < length;) {\n              symbol = source.charAt(Index);\n              if (symbol < \" \") {\n                // Unescaped ASCII control characters are not permitted.\n                abort();\n              } else if (symbol == \"\\\\\") {\n                // Parse escaped JSON control characters, `\"`, `\\`, `/`, and\n                // Unicode escape sequences.\n                symbol = source.charAt(++Index);\n                if ('\\\\\"/btnfr'.indexOf(symbol) > -1) {\n                  // Revive escaped control characters.\n                  value += Unescapes[symbol];\n                  Index++;\n                } else if (symbol == \"u\") {\n                  // Advance to the first character of the escape sequence.\n                  begin = ++Index;\n                  // Validate the Unicode escape sequence.\n                  for (position = Index + 4; Index < position; Index++) {\n                    symbol = source.charAt(Index);\n                    // A valid sequence comprises four hexdigits that form a\n                    // single hexadecimal value.\n                    if (!(symbol >= \"0\" && symbol <= \"9\" || symbol >= \"a\" && symbol <= \"f\" || symbol >= \"A\" && symbol <= \"F\")) {\n                      // Invalid Unicode escape sequence.\n                      abort();\n                    }\n                  }\n                  // Revive the escaped character.\n                  value += fromCharCode(\"0x\" + source.slice(begin, Index));\n                } else {\n                  // Invalid escape sequence.\n                  abort();\n                }\n              } else {\n                if (symbol == '\"') {\n                  // An unescaped double-quote character marks the end of the\n                  // string.\n                  break;\n                }\n                // Append the original character as-is.\n                value += symbol;\n                Index++;\n              }\n            }\n            if (source.charAt(Index) == '\"') {\n              Index++;\n              // Return the revived string.\n              return value;\n            }\n            // Unterminated string.\n            abort();\n          } else {\n            // Parse numbers and literals.\n            begin = Index;\n            // Advance the scanner's position past the sign, if one is\n            // specified.\n            if (symbol == \"-\") {\n              sign = true;\n              symbol = source.charAt(++Index);\n            }\n            // Parse an integer or floating-point value.\n            if (symbol >= \"0\" && symbol <= \"9\") {\n              // Leading zeroes are interpreted as octal literals.\n              if (symbol == \"0\" && (symbol = source.charAt(Index + 1), symbol >= \"0\" && symbol <= \"9\")) {\n                // Illegal octal literal.\n                abort();\n              }\n              sign = false;\n              // Parse the integer component.\n              for (; Index < length && (symbol = source.charAt(Index), symbol >= \"0\" && symbol <= \"9\"); Index++);\n              // Floats cannot contain a leading decimal point; however, this\n              // case is already accounted for by the parser.\n              if (source.charAt(Index) == \".\") {\n                position = ++Index;\n                // Parse the decimal component.\n                for (; position < length && (symbol = source.charAt(position), symbol >= \"0\" && symbol <= \"9\"); position++);\n                if (position == Index) {\n                  // Illegal trailing decimal.\n                  abort();\n                }\n                Index = position;\n              }\n              // Parse exponents.\n              symbol = source.charAt(Index);\n              if (symbol == \"e\" || symbol == \"E\") {\n                // Skip past the sign following the exponent, if one is\n                // specified.\n                symbol = source.charAt(++Index);\n                if (symbol == \"+\" || symbol == \"-\") {\n                  Index++;\n                }\n                // Parse the exponential component.\n                for (position = Index; position < length && (symbol = source.charAt(position), symbol >= \"0\" && symbol <= \"9\"); position++);\n                if (position == Index) {\n                  // Illegal empty exponent.\n                  abort();\n                }\n                Index = position;\n              }\n              // Coerce the parsed value to a JavaScript number.\n              return +source.slice(begin, Index);\n            }\n            // A negative sign may only precede numbers.\n            if (sign) {\n              abort();\n            }\n            // `true`, `false`, and `null` literals.\n            if (source.slice(Index, Index + 4) == \"true\") {\n              Index += 4;\n              return true;\n            } else if (source.slice(Index, Index + 5) == \"false\") {\n              Index += 5;\n              return false;\n            } else if (source.slice(Index, Index + 4) == \"null\") {\n              Index += 4;\n              return null;\n            }\n            // Unrecognized token.\n            abort();\n          }\n        }\n        // Return the sentinel `$` character if the parser has reached the end\n        // of the source string.\n        return \"$\";\n      };\n\n      // Internal: Parses a JSON `value` token.\n      get = function (value) {\n        var results, any, key;\n        if (value == \"$\") {\n          // Unexpected end of input.\n          abort();\n        }\n        if (typeof value == \"string\") {\n          if (value.charAt(0) == \"@\") {\n            // Remove the sentinel `@` character.\n            return value.slice(1);\n          }\n          // Parse object and array literals.\n          if (value == \"[\") {\n            // Parses a JSON array, returning a new JavaScript array.\n            results = [];\n            for (;; any || (any = true)) {\n              value = lex();\n              // A closing square bracket marks the end of the array literal.\n              if (value == \"]\") {\n                break;\n              }\n              // If the array literal contains elements, the current token\n              // should be a comma separating the previous element from the\n              // next.\n              if (any) {\n                if (value == \",\") {\n                  value = lex();\n                  if (value == \"]\") {\n                    // Unexpected trailing `,` in array literal.\n                    abort();\n                  }\n                } else {\n                  // A `,` must separate each array element.\n                  abort();\n                }\n              }\n              // Elisions and leading commas are not permitted.\n              if (value == \",\") {\n                abort();\n              }\n              results.push(get(value));\n            }\n            return results;\n          } else if (value == \"{\") {\n            // Parses a JSON object, returning a new JavaScript object.\n            results = {};\n            for (;; any || (any = true)) {\n              value = lex();\n              // A closing curly brace marks the end of the object literal.\n              if (value == \"}\") {\n                break;\n              }\n              // If the object literal contains members, the current token\n              // should be a comma separator.\n              if (any) {\n                if (value == \",\") {\n                  value = lex();\n                  if (value == \"}\") {\n                    // Unexpected trailing `,` in object literal.\n                    abort();\n                  }\n                } else {\n                  // A `,` must separate each object member.\n                  abort();\n                }\n              }\n              // Leading commas are not permitted, object property names must be\n              // double-quoted strings, and a `:` must separate each property\n              // name and value.\n              if (value == \",\" || typeof value != \"string\" || value.charAt(0) != \"@\" || lex() != \":\") {\n                abort();\n              }\n              results[value.slice(1)] = get(lex());\n            }\n            return results;\n          }\n          // Unexpected token encountered.\n          abort();\n        }\n        return value;\n      };\n\n      // Internal: Updates a traversed object member.\n      update = function(source, property, callback) {\n        var element = walk(source, property, callback);\n        if (element === undef) {\n          delete source[property];\n        } else {\n          source[property] = element;\n        }\n      };\n\n      // Internal: Recursively traverses a parsed JSON object, invoking the\n      // `callback` function for each value. This is an implementation of the\n      // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\n      walk = function (source, property, callback) {\n        var value = source[property], length;\n        if (typeof value == \"object\" && value) {\n          if (getClass.call(value) == \"[object Array]\") {\n            for (length = value.length; length--;) {\n              update(value, length, callback);\n            }\n          } else {\n            // `forEach` can't be used to traverse an array in Opera <= 8.54,\n            // as `Object#hasOwnProperty` returns `false` for array indices\n            // (e.g., `![1, 2, 3].hasOwnProperty(\"0\")`).\n            forEach(value, function (property) {\n              update(value, property, callback);\n            });\n          }\n        }\n        return callback.call(source, property, value);\n      };\n\n      // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\n      JSON3.parse = function (source, callback) {\n        var result, value;\n        Index = 0;\n        Source = source;\n        result = get(lex());\n        // If a JSON string contains multiple tokens, it is invalid.\n        if (lex() != \"$\") {\n          abort();\n        }\n        // Reset the parser state.\n        Index = Source = null;\n        return callback && getClass.call(callback) == \"[object Function]\" ? walk((value = {}, value[\"\"] = result, value), \"\", callback) : result;\n      };\n    }\n  }\n\n  // Export for asynchronous module loaders.\n  if (isLoader) {\n    define(function () {\n      return JSON3;\n    });\n  }\n}).call(this);","modules":[{"pos":36462,"count":19,"factory":true,"id":"poly/support/json3"}]}