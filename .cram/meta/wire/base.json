{"absId":"wire/base","text":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * wire/base plugin\n * Base wire plugin that provides properties, init, and destroy facets, and\n * a proxy for plain JS objects.\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\n(function(define) {\ndefine(['when', './lib/object', './lib/functional', './lib/component', './lib/invoker'], function(when, object, functional, createComponent, createInvoker) {\n\n\tvar whenAll, obj, undef;\n\n\twhenAll = when.all;\n\tobj = {};\n\n\tfunction asArray(it) {\n\t\treturn Array.isArray(it) ? it : [it];\n\t}\n\n\tfunction invoke(func, proxy, args, wire) {\n        return when(wire(args, func, proxy.path),\n\t\t\tfunction (resolvedArgs) {\n\t\t\t\treturn proxy.invoke(func, asArray(resolvedArgs));\n\t\t\t}\n\t\t);\n\t}\n\n\tfunction invokeAll(facet, wire) {\n\t\tvar options = facet.options;\n\n\t\tif(typeof options == 'string') {\n\t\t\treturn invoke(options, facet, [], wire);\n\n\t\t} else {\n\t\t\tvar promises, funcName;\n\t\t\tpromises = [];\n\n\t\t\tfor(funcName in options) {\n\t\t\t\tpromises.push(invoke(funcName, facet, options[funcName], wire));\n\t\t\t}\n\n\t\t\treturn whenAll(promises);\n\t\t}\n\t}\n\n\t//\n\t// Mixins\n\t//\n\n\tfunction mixin(target, src) {\n\t\tvar name, s;\n\n\t\tfor(name in src) {\n\t\t\ts = src[name];\n\t\t\tif(!(name in target) || (target[name] !== s && (!(name in obj) || obj[name] !== s))) {\n\t\t\t\ttarget[name] = s;\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t}\n\n\tfunction doMixin(target, introduction, wire) {\n\t\tintroduction = typeof introduction == 'string'\n\t\t\t? wire.resolveRef(introduction)\n\t\t\t: wire(introduction);\n\n\t\treturn when(introduction, mixin.bind(null, target));\n\t}\n\n\tfunction mixinFacet(resolver, facet, wire) {\n\t\tvar target, intros, promise;\n\n\t\ttarget = facet.target;\n\t\tintros = facet.options;\n\n\t\tif(!Array.isArray(intros)) {\n\t\t\tintros = [intros];\n\t\t}\n\n\t\tpromise = when.reduce(intros, function(target, intro) {\n\t\t\treturn doMixin(target, intro, wire);\n\t\t}, target);\n\n\t\tresolver.resolve(promise);\n\t}\n\n    /**\n     * Factory that handles cases where you need to create an object literal\n     * that has a property whose name would trigger another wire factory.\n     * For example, if you need an object literal with a property named \"create\",\n     * which would normally cause wire to try to construct an instance using\n     * a constructor or other function, and will probably result in an error,\n     * or an unexpected result:\n     * myObject: {\n     *      create: \"foo\"\n     *    ...\n     * }\n     *\n     * You can use the literal factory to force creation of an object literal:\n     * myObject: {\n     *    literal: {\n     *      create: \"foo\"\n     *    }\n     * }\n     *\n     * which will result in myObject.create == \"foo\" rather than attempting\n     * to create an instance of an AMD module whose id is \"foo\".\n     */\n\tfunction literalFactory(resolver, spec /*, wire */) {\n\t\tresolver.resolve(spec.literal);\n\t}\n\n\t/**\n\t * @deprecated Use create (instanceFactory) instead\n\t * @param resolver\n\t * @param spec\n\t * @param wire\n\t */\n\tfunction protoFactory(resolver, spec, wire) {\n\t\tvar parentRef, promise;\n\n        parentRef = spec.prototype;\n\n        promise = typeof parentRef === 'string'\n                ? wire.resolveRef(parentRef)\n                : wire(parentRef);\n\n        when(promise, Object.create)\n\t\t\t.then(resolver.resolve, resolver.reject);\n\t}\n\n\tfunction propertiesFacet(resolver, facet, wire) {\n\n\t\tvar properties, path, setProperty;\n\n\t\tproperties = facet.options;\n\t\tpath = facet.path;\n\t\tsetProperty = facet.set.bind(facet);\n\n\t\twhen.map(Object.keys(facet.options), function(key) {\n\t\t\treturn wire(properties[key], key, facet.path)\n\t\t\t\t.then(function(wiredProperty) {\n\t\t\t\t\tsetProperty(key, wiredProperty);\n\t\t\t\t}\n\t\t\t);\n\t\t}).then(resolver.resolve, resolver.reject);\n\n\t}\n\n\tfunction invokerFactory(resolver, componentDef, wire) {\n\n\t\twire(componentDef.invoker).then(function(invokerContext) {\n\t\t\t// It'd be nice to use wire.getProxy() then proxy.invoke()\n\t\t\t// here, but that means the invoker must always return\n\t\t\t// a promise.  Not sure that's best, so for now, just\n\t\t\t// call the method directly\n\t\t\treturn createInvoker(invokerContext.method, invokerContext.args);\n\t\t}).then(resolver.resolve, resolver.reject);\n\n\t}\n\n\tfunction invokerFacet(resolver, facet, wire) {\n\t\tresolver.resolve(invokeAll(facet, wire));\n\t}\n\n\tfunction pojoProxy(object /*, spec */) {\n\t\treturn {\n\t\t\tget: function(property) {\n\t\t\t\treturn object[property];\n\t\t\t},\n\t\t\tset: function(property, value) {\n\t\t\t\tobject[property] = value;\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\tinvoke: function(method, args) {\n\t\t\t\tif(typeof method === 'string') {\n\t\t\t\t\tmethod = object[method];\n\t\t\t\t}\n\n\t\t\t\treturn method.apply(object, args);\n\t\t\t},\n\t\t\tdestroy: function() {},\n\t\t\tclone: function(options) {\n\t\t\t\t// don't try to clone a primitive\n\t\t\t\tif (typeof object != 'object') {\n\t\t\t\t\treturn object;\n\t\t\t\t}\n\t\t\t\t// cloneThing doesn't clone functions (methods), so clone here:\n\t\t\t\telse if (typeof object == 'function') {\n\t\t\t\t\treturn object.bind();\n\t\t\t\t}\n\n\t\t\t\tif (!options) {\n\t\t\t\t\toptions = {};\n\t\t\t\t}\n\n\t\t\t\treturn cloneThing(object, options);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction cloneThing (thing, options) {\n\t\tvar deep, inherited, clone, prop;\n\t\tdeep = options.deep;\n\t\tinherited = options.inherited;\n\n\t\t// Note: this filters out primitive properties and methods\n\t\tif (typeof thing != 'object') {\n\t\t\treturn thing;\n\t\t}\n\t\telse if (thing instanceof Date) {\n\t\t\treturn new Date(thing.getTime());\n\t\t}\n\t\telse if (thing instanceof RegExp) {\n\t\t\treturn new RegExp(thing);\n\t\t}\n\t\telse if (Array.isArray(thing)) {\n\t\t\treturn deep\n\t\t\t\t? thing.map(function (i) { return cloneThing(i, options); })\n\t\t\t\t: thing.slice();\n\t\t}\n\t\telse {\n\t\t\tclone = thing.constructor ? new thing.constructor() : {};\n\t\t\tfor (prop in thing) {\n\t\t\t\tif (inherited || thing.hasOwnProperty(prop)) {\n\t\t\t\t\tclone[prop] = deep\n\t\t\t\t\t\t? cloneThing(thing[prop], options)\n\t\t\t\t\t\t: thing[prop];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn clone;\n\t\t}\n\t}\n\n    //noinspection JSUnusedLocalSymbols\n    /**\n     * Wrapper for use with when.reduce that calls the supplied destroyFunc\n     * @param [unused]\n     * @param destroyFunc {Function} destroy function to call\n     */\n    function destroyReducer(unused, destroyFunc) {\n        return destroyFunc();\n    }\n\n\tfunction moduleFactory(resolver, spec, wire) {\n\t\tresolver.resolve(wire.loadModule(spec.module, spec));\n\t}\n\n\tfunction cloneFactory(resolver, spec, wire) {\n\t\tvar sourceRef, options;\n\n\t\tif (wire.resolver.isRef(spec.clone.source)) {\n\t\t\tsourceRef = spec.clone.source;\n\t\t\toptions = spec.clone;\n\t\t}\n\t\telse {\n\t\t\tsourceRef = spec.clone;\n\t\t\toptions = {};\n\t\t}\n\n\t\twhen(wire(sourceRef), function (ref) {\n\t\t\treturn when(wire.getProxy(ref), function (proxy) {\n\t\t\t\tif (!proxy.clone) {\n\t\t\t\t\tthrow new Error('No clone function found for ' + spec.id);\n\t\t\t\t}\n\n\t\t\t\treturn proxy.clone(options);\n\t\t\t});\n\t\t}).then(resolver.resolve, resolver.reject);\n\t}\n\n\t/**\n\t * Factory that uses an AMD module either directly, or as a\n\t * constructor or plain function to create the resulting item.\n\t *\n\t * @param resolver {Resolver} resolver to resolve with the created component\n\t * @param spec {Object} portion of the spec for the component to be created\n\t */\n\tfunction instanceFactory(resolver, spec, wire) {\n\t\tvar create, args, isConstructor, name, promise;\n\n\t\tname = spec.id;\n\t\tcreate = spec.create;\n\n\t\tif (typeof create == 'string') {\n\t\t\tpromise = wire.loadModule(create, spec);\n\t\t} else if(wire.resolver.isRef(create)) {\n\t\t\tpromise = wire(create);\n\t\t} else {\n\t\t\tpromise = wire(create);\n\t\t\targs = create.args;\n\t\t\tisConstructor = create.isConstructor;\n\t\t}\n\n\t\tresolver.resolve(when(promise, handleModule));\n\n\t\t// Load the module, and use it to create the object\n\t\tfunction handleModule(module) {\n\t\t\tfunction resolve(resolvedArgs) {\n\t\t\t\treturn createComponent(module, resolvedArgs, isConstructor);\n\t\t\t}\n\n\t\t\t// We'll either use the module directly, or we need\n\t\t\t// to instantiate/invoke it.\n\t\t\tif (typeof module == 'function') {\n\t\t\t\t// Instantiate or invoke it and use the result\n\t\t\t\treturn args\n\t\t\t\t\t? when(wire(asArray(args)), resolve)\n\t\t\t\t\t: resolve([]);\n\n\t\t\t} else {\n\t\t\t\t// Simply use the module as is\n\t\t\t\treturn Object.create(module);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction composeFactory(resolver, spec, wire) {\n\t\tvar promise;\n\n\t\tspec = spec.compose;\n\n\t\tif(typeof spec == 'string') {\n\t\t\tpromise = functional.compose.parse(undef, spec, wire);\n\t\t} else {\n\t\t\t// Assume it's an array of things that will wire to functions\n\t\t\tpromise = when(wire(spec), function(funcArray) {\n\t\t\t\treturn functional.compose(funcArray);\n\t\t\t});\n\t\t}\n\n\t\tresolver.resolve(promise);\n\t}\n\n\treturn {\n\t\twire$plugin: function(ready, destroyed /*, options */) {\n            // Components in the current context that will be destroyed\n            // when this context is destroyed\n\t\t\tvar destroyFuncs, plugin;\n\n\t\t\tdestroyFuncs = [];\n\n\t\t\twhen(destroyed, function() {\n                return when.reduce(destroyFuncs, destroyReducer, 0);\n\t\t\t});\n\n\t\t\tfunction destroyFacet(resolver, facet, wire) {\n\t\t\t\tdestroyFuncs.push(function destroyObject() {\n\t\t\t\t\treturn invokeAll(facet, wire);\n\t\t\t\t});\n\n\t\t\t\t// This resolver is just related to *collecting* the functions to\n\t\t\t\t// invoke when the component is destroyed.\n\t\t\t\tresolver.resolve();\n\t\t\t}\n\n\t\t\tplugin = {\n\t\t\t\tfactories: {\n\t\t\t\t\tmodule: moduleFactory,\n\t\t\t\t\tcreate: instanceFactory,\n\t\t\t\t\tliteral: literalFactory,\n\t\t\t\t\tprototype: protoFactory,\n\t\t\t\t\tclone: cloneFactory,\n\t\t\t\t\tcompose: composeFactory,\n\t\t\t\t\tinvoker: invokerFactory\n\t\t\t\t},\n\t\t\t\tfacets: {\n\t\t\t\t\t// properties facet.  Sets properties on components\n\t\t\t\t\t// after creation.\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tconfigure: propertiesFacet\n\t\t\t\t\t},\n\t\t\t\t\tmixin: {\n\t\t\t\t\t\tconfigure: mixinFacet\n\t\t\t\t\t},\n\t\t\t\t\t// init facet.  Invokes methods on components during\n\t\t\t\t\t// the \"init\" stage.\n\t\t\t\t\tinit: {\n\t\t\t\t\t\tinitialize: invokerFacet\n\t\t\t\t\t},\n\t\t\t\t\t// ready facet.  Invokes methods on components during\n\t\t\t\t\t// the \"ready\" stage.\n\t\t\t\t\tready: {\n\t\t\t\t\t\tready: invokerFacet\n\t\t\t\t\t},\n\t\t\t\t\t// destroy facet.  Registers methods to be invoked\n\t\t\t\t\t// on components when the enclosing context is destroyed\n\t\t\t\t\tdestroy: {\n\t\t\t\t\t\tready: destroyFacet\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tproxies: [\n\t\t\t\t\tpojoProxy\n\t\t\t\t]\n\t\t\t};\n\n\t\t\t// \"introduce\" is deprecated, but preserved here for now.\n\t\t\tplugin.facets.introduce = plugin.facets.mixin;\n\n\t\t\treturn plugin;\n\t\t}\n\t};\n});\n})(typeof define == 'function'\n\t? define\n\t: function(deps, factory) {\n\t\tmodule.exports = factory.apply(this, deps.map(function(x) {\n\t\t\treturn require(x);\n\t\t}));\n\t}\n);\n","modules":[{"pos":391,"count":156,"depList":["when/when","wire/lib/object","wire/lib/functional","wire/lib/component","wire/lib/invoker"],"factory":true,"argList":["when","object","functional","createComponent","createInvoker"],"id":"wire/base"}]}