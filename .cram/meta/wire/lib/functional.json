{"absId":"wire/lib/functional","text":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * functional\n * Helper library for working with pure functions in wire and wire plugins\n *\n * NOTE: This lib assumes Function.prototype.bind is available\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n(function (define) {\ndefine(['when'], function (when) {\n\"use strict\";\n\n\tvar slice, undef;\n\n\tslice = [].slice;\n\n\t/**\n\t * Create a partial function\n\t * @param f {Function}\n\t * @param [args] {*} additional arguments will be bound to the returned partial\n\t * @return {Function}\n\t */\n\tfunction partial(f, args/*...*/) {\n\t\t// What we want here is to allow the partial function to be called in\n\t\t// any context, by attaching it to an object, or using partialed.call/apply\n\t\t// That's why we're not using Function.bind() here.  It has no way to bind\n\t\t// arguments but allow the context to default.  In other words, you MUST bind\n\t\t// the the context to something with Function.bind().\n\n\t\t// Optimization: return f if no args provided\n\t\tif(arguments.length == 1) {\n\t\t\treturn f;\n\t\t}\n\n\t\targs = slice.call(arguments, 1);\n\n\t\treturn function() {\n\t\t\treturn f.apply(this, args.concat(slice.call(arguments)));\n\t\t};\n\t}\n\n\t/**\n\t * Creates a partial function that weaves arguments into returned function\n\t * @param f {Function}\n\t * @param weaves {Object} sparse array-like object (with length property)\n\t *   These weaves are spliced into the run-time arguments.  Each property\n\t *   whose is a positive integer describes a point at which to splice\n\t *   an argument.\n\t * @return {Function}\n\t */\n\tfunction weave (f, weaves) {\n\t\treturn function () {\n\t\t\tvar length = Math.max(weaves.length || 0, arguments.length, f.length);\n\t\t\treturn f.apply(this, injectArgs(weaves, length, arguments));\n\t\t};\n\t}\n\n\t/**\n\t * @private\n\t * @param weaves {Object} sparse array-like object (with length property)\n\t * @param length {Number} how long the resulting arguments list should be\n\t * @param args {Arguments} run-time arguments\n\t * @return {Array} interwoven arguments\n\t */\n\tfunction injectArgs (weaves, length, args) {\n\t\tvar woven = [], i;\n\t\targs = slice.call(args); // copy\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tif (i in weaves) {\n\t\t\t\twoven.push(weaves[i]);\n\t\t\t}\n\t\t\tif (args.length > 0) {\n\t\t\t\twoven.push(args.shift());\n\t\t\t}\n\t\t}\n\t\treturn woven;\n\t}\n\n\t/**\n\t * Compose functions\n\t * @param funcs {Array} array of functions to compose\n\t * @return {Function} composed function\n\t */\n\tfunction compose(funcs) {\n\n\t\tvar first;\n\t\tfirst = funcs[0];\n\t\tfuncs = funcs.slice(1);\n\n\t\treturn function composed() {\n\t\t\tvar context = this;\n\t\t\treturn funcs.reduce(function(result, f) {\n\t\t\t\treturn f.call(context, result);\n\t\t\t}, first.apply(this, arguments));\n\t\t};\n\t}\n\n\t/**\n\t * Parses the function composition string, resolving references as needed, and\n\t * composes a function from the resolved refs.\n\t * @param proxy {Object} wire proxy on which to invoke the final method of the composition\n\t * @param composeString {String} function composition string\n\t *  of the form: 'transform1 | transform2 | ... | methodOnProxyTarget\"\n\t * @param wire.resolveRef {Function} function to use is resolving references, returns a promise\n\t * @param wire.getProxy {Function} function used to obtain a proxy for a component\n\t * @return {Promise} a promise for the composed function\n\t */\n\tcompose.parse = function parseCompose(proxy, composeString, wire) {\n\n\t\tvar bindSpecs, resolveRef, getProxy;\n\n\t\tif(typeof composeString != 'string') {\n\t\t\treturn wire(composeString, function(func) {\n\t\t\t\treturn createProxyInvoker(proxy, func);\n\t\t\t});\n\t\t}\n\n\t\tbindSpecs = composeString.split(/\\s*\\|\\s*/);\n\t\tresolveRef = wire.resolveRef;\n\t\tgetProxy = wire.getProxy;\n\n\t\tfunction createProxyInvoker(proxy, method) {\n\t\t\treturn function() {\n\t\t\t\treturn proxy.invoke(method, arguments);\n\t\t\t};\n\t\t}\n\n\t\tfunction createBound(bindSpec) {\n\t\t\tvar target, method;\n\n\t\t\ttarget = bindSpec.split('.');\n\n\t\t\tif(target.length > 2) {\n\t\t\t\tthrow new Error('Only 1 \".\" is allowed in refs: ' + bindSpec);\n\t\t\t}\n\n\t\t\tif(target.length > 1) {\n\t\t\t\tmethod = target[1];\n\t\t\t\ttarget = target[0];\n\t\t\t\tif(!target) {\n\t\t\t\t\treturn function(target) {\n\t\t\t\t\t\treturn target[method].apply(target, slice.call(arguments, 1));\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn when(getProxy(target), function(proxy) {\n\t\t\t\t\treturn createProxyInvoker(proxy, method);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn when(resolveRef(bindSpec),\n\t\t\t\t\tnull,\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\treturn createProxyInvoker(proxy, bindSpec);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t}\n\n\t\t// First, resolve each transform function, stuffing it into an array\n\t\t// The result of this reduce will an array of concrete functions\n\t\t// Then add the final context[method] to the array of funcs and\n\t\t// return the composition.\n\t\treturn when.reduce(bindSpecs, function(funcs, bindSpec) {\n\t\t\treturn when(createBound(bindSpec), function(func) {\n\t\t\t\tfuncs.push(func);\n\t\t\t\treturn funcs;\n\t\t\t});\n\t\t}, []).then(\n\t\t\tfunction(funcs) {\n\t\t\t\tvar context = proxy && proxy.target;\n\t\t\t\treturn (funcs.length == 1 ? funcs[0] : compose(funcs)).bind(context);\n\t\t\t}\n\t\t);\n\t};\n\n\treturn {\n\t\tcompose: compose,\n\t\tpartial: partial,\n\t\tweave: weave\n\t};\n\n});\n})(typeof define == 'function'\n\t// AMD\n\t? define\n\t// CommonJS\n\t: function(deps, factory) {\n\t\tmodule.exports = factory.apply(this, deps.map(function(x) {\n\t\t\treturn require(x);\n\t\t}));\n\t}\n);\n","modules":[{"pos":417,"count":33,"depList":["when/when"],"factory":true,"argList":["when"],"id":"wire/lib/functional"}]}