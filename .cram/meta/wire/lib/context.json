{"absId":"wire/lib/context","text":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\n(function(define){\ndefine(['require', 'when', './array', './object', './async', './moduleLoader', './lifecycle', './resolver', '../base'],\nfunction(require, when, array, object, async, createModuleLoader, Lifecycle, Resolver, basePlugin) {\n\n\t\"use strict\";\n\n\tvar defer, emptyObject, undef;\n\n\t// Local refs to when.js\n\tdefer = when.defer;\n\temptyObject = {};\n\n\tfunction WireContext() {}\n\n\t/**\n\t * Creates a new context from the supplied specs, with the supplied parent context.\n\t * If specs is an {Array}, it may be a mixed array of string module ids, and object\n\t * literal specs.  All spec module ids will be loaded, and then all specs will be\n\t * merged from left-to-right (rightmost wins), and the resulting, merged spec will\n\t * be wired.\n\t *\n\t * @private\n\t *\n\t * @param specs {String|Array|*}\n\t * @param parent {Object} parent content\n\t * @param options {Object}\n\t *\n\t * @return {Promise} a promise for the new context\n\t */\n\tfunction createContext(specs, parent, options) {\n\t\t// Do the actual wiring after all specs have been loaded\n\t\tfunction doWireContext(spec) {\n\t\t\treturn createScope(spec, parent, options);\n\t\t}\n\n\t\tvar moduleLoader = getModuleLoader(parent, options);\n\n\t\treturn when(specs, function(specs) {\n\t\t\treturn Array.isArray(specs)\n\t\t\t\t? when(ensureAllSpecsLoaded(specs, moduleLoader), doWireContext)\n\t\t\t\t: when(isString(specs) ? moduleLoader(specs) : specs, doWireContext);\n\t\t});\n\t}\n\n\treturn createContext;\n\n\t/**\n\t * Do the work of creating a new scope and fully wiring its contents\n\t * @private\n\t *\n\t * @param scopeDef {Object} The spec (or portion of a spec) to be wired into a new scope\n\t * @param parent {scope} scope to use as the parent, and thus from which to inherit\n\t *  plugins, components, etc.\n\t * @param [options] {Object} scope options\n\t *\n\t * @return {Promise} a promise for the new scope\n\t */\n\tfunction createScope(scopeDef, parent, options) {\n\t\tvar scope, scopeParent, context, config, contextHandlers,\n\t\t\tproxiedComponents, components, lifecycle, resolver, inflightRefs,\n\t\t\tpluginApi, resolvers, factories, facets, listeners, proxiers,\n\t\t\tmoduleLoader, modulesToLoad, plugins,\n\t\t\twireApi, modulesReady, scopeReady, scopeDestroyed, doDestroy;\n\n\t\tinflightRefs = [];\n\n\t\t// Empty parent scope if none provided\n\t\tif(!parent) { parent = {}; }\n\t\tif(!options) { options = {}; }\n\n\t\tinheritFromParent(parent, options);\n\t\tcreatePluginApi();\n\n\t\t// TODO: Find a better way to load and scan the base plugin\n\t\tscanPlugin(basePlugin);\n\n\t\tconfigureContext(options);\n\t\tpluginApi.resolver = resolver;\n\n\t\t// Setup overwritable doDestroy so that this context\n\t\t// can only be destroyed once\n\t\tdoDestroy = function () {\n\t\t\t// Retain a do-nothing doDestroy() func, in case\n\t\t\t// it is called again for some reason.\n\t\t\tdoDestroy = function () {\n\t\t\t};\n\n\t\t\treturn when(destroyContext(), executeDestroyers);\n\t\t};\n\n\t\tcontext = {\n\t\t\tspec: scopeDef,\n\t\t\tcomponents: components,\n\t\t\tconfig: config\n\t\t};\n\n\t\tfunction executeInitializers() {\n\t\t\treturn async.sequence(contextHandlers.init, context);\n\t\t}\n\t\tfunction executeDestroyers() {\n\t\t\treturn async.sequence(contextHandlers.destroy, context);\n\t\t}\n\n\t\treturn executeInitializers()\n\t\t\t.then(function() {\n\n\t\t\t\tvar componentsToCreate = parseSpec(scopeDef, scopeReady);\n\n\t\t\t\tcreateComponents(componentsToCreate, scopeDef);\n\n\t\t\t\t// Once all modules are loaded, all the components can finish\n\t\t\t\tensureAllModulesLoaded();\n\n\t\t\t\t// Return promise\n\t\t\t\t// Context will be ready when this promise resolves\n\t\t\t\treturn scopeReady.promise;\n\t\t\t});\n\n\t\t//\n\t\t// Initialization\n\t\t//\n\n\t\tfunction inheritFromParent(parent, options) {\n\t\t\t// Descend scope and plugins from parent so that this scope can\n\t\t\t// use them directly via the prototype chain\n\n\t\t\tWireContext.prototype = createWireApi(object.inherit(parent.components));\n\t\t\tcomponents = new WireContext();\n\t\t\tWireContext.prototype = undef;\n\n\t\t\tresolvers = object.inherit(parent.resolvers);\n\t\t\tfactories = object.inherit(parent.factories);\n\t\t\tfacets = object.inherit(parent.facets);\n\n\t\t\t// Set/override integral resolvers and factories\n\t\t\tresolvers.wire = wireResolver;\n\t\t\tfactories.wire = wireFactory;\n\n\t\t\tlisteners = array.delegate(parent.listeners);\n\n\t\t\t// Proxies is an array, have to concat\n\t\t\tproxiers = array.delegate(parent.proxiers);\n\t\t\tproxiedComponents = [];\n\n\t\t\tplugins = [];\n\t\t\tmodulesToLoad = [];\n\t\t\tmodulesReady = defer();\n\n\t\t\tscopeReady = defer();\n\t\t\tscopeDestroyed = defer();\n\n\t\t\tmoduleLoader = getModuleLoader(parent, options);\n\n\t\t\t// A proxy of this scope that can be used as a parent to\n\t\t\t// any child scopes that may be created.\n\t\t\tscopeParent = {\n\t\t\t\tmoduleLoader: moduleLoader,\n\t\t\t\tcomponents: components,\n\t\t\t\tdestroyed: scopeDestroyed.promise\n\t\t\t};\n\n\t\t\t// Full scope definition.  This will be given to sub-scopes,\n\t\t\t// but should never be given to child contexts\n\t\t\tscope = Object.create(scopeParent);\n\n\t\t\tscope.resolvers = resolvers;\n\t\t\tscope.factories = factories;\n\t\t\tscope.facets = facets;\n\t\t\tscope.listeners = listeners;\n\t\t\tscope.proxiers = proxiers;\n\t\t\tscope.resolveRef = resolveRefName;\n\t\t\tscope.destroy = destroy;\n\t\t\tscope.path = createPath(options.name, parent.path);\n\n\t\t\t// When the parent begins its destroy phase, this child must\n\t\t\t// begin its destroy phase and complete it before the parent.\n\t\t\t// The context hierarchy will be destroyed from child to parent.\n\t\t\tif (parent.destroyed) {\n\t\t\t\twhen(parent.destroyed, destroy);\n\t\t\t}\n\t\t}\n\n\t\tfunction createWireApi(context) {\n\t\t\twireApi = context.wire = wireChild;\n\t\t\twireApi.destroy = context.destroy = apiDestroy;\n\n\t\t\t// Consider deprecating resolve\n\t\t\t// Any reference you could resolve using this should simply be\n\t\t\t// injected instead.\n\t\t\twireApi.resolve = context.resolve = apiResolveRef;\n\n\t\t\treturn context;\n\t\t}\n\n\t\tfunction createPluginApi() {\n\t\t\t// Plugin API\n\t\t\t// wire() API that is passed to plugins.\n\t\t\tpluginApi = function (spec, name, path) {\n\t\t\t\treturn createItem(spec, createPath(name, path));\n\t\t\t};\n\n\t\t\tpluginApi.resolveRef = apiResolveRef;\n\t\t\tpluginApi.getProxy = getProxy;\n\t\t\tpluginApi.loadModule = getModule;\n\t\t}\n\n\t\tfunction configureContext(options) {\n\t\t\t// TODO: This configuration object needs to be abstracted and reused\n\t\t\tconfig = {\n\t\t\t\tpluginApi: pluginApi,\n\t\t\t\tresolvers: resolvers,\n\t\t\t\tfacets: facets,\n\t\t\t\tlisteners: listeners\n\t\t\t};\n\n\t\t\tlifecycle = new Lifecycle(config);\n\t\t\tresolver = new Resolver(config);\n\n\t\t\tcontextHandlers = {\n\t\t\t\tinit: array.delegate(options.init),\n\t\t\t\tdestroy: array.delegate(options.destroy)\n\t\t\t};\n\t\t}\n\n\t\tfunction parseSpec(scopeDef, scopeReady) {\n\t\t\tvar promises, componentsToCreate, d;\n\n\t\t\tpromises = [];\n\t\t\tcomponentsToCreate = {};\n\n\t\t\t// Setup a promise for each item in this scope\n\t\t\tfor (var name in scopeDef) {\n\t\t\t\t// An initializer may have inserted concrete components\n\t\t\t\t// into the context.  If so, they override components of the\n\t\t\t\t// same name from the input spec\n\t\t\t\tif(!(components.hasOwnProperty(name))) {\n\t\t\t\t\t// Hack for 0.9.x + when 2.0 compat only. To be removed in 0.10.0\n\t\t\t\t\td = defer();\n\t\t\t\t\tcomponentsToCreate[name] = d.resolver;\n\t\t\t\t\tcomponents[name] = d.promise;\n\t\t\t\t\tpromises.push(d.promise);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// When all scope item promises are resolved, the scope\n\t\t\t// is ready. When this scope is ready, resolve the promise\n\t\t\t// with the objects that were created\n\t\t\twhen.all(promises).then(\n\t\t\t\tfunction() {\n\t\t\t\t\tscopeReady.resolve(components);\n\t\t\t\t},\n\t\t\t\tscopeReady.reject\n\t\t\t);\n\n\t\t\treturn componentsToCreate;\n\t\t}\n\n\t\t//\n\t\t// Context Startup\n\t\t//\n\n\t\tfunction createComponents(componentsToCreate, spec) {\n\t\t\t// Process/create each item in scope and resolve its\n\t\t\t// promise when completed.\n\t\t\tfor (var name in componentsToCreate) {\n\t\t\t\tcreateScopeItem(name, spec[name], componentsToCreate[name]);\n\t\t\t}\n\t\t}\n\n\t\tfunction ensureAllModulesLoaded() {\n\t\t\tasync.until(waitForModules, 0, allModulesLoaded).then(\n\t\t\t\tfunction() { modulesReady.resolve(); },\n\t\t\t\tfunction() { modulesReady.reject(); }\n\t\t\t);\n\n\t\t\tfunction waitForModules() {\n\t\t\t\tvar modules = modulesToLoad;\n\t\t\t\tmodulesToLoad = [];\n\n\t\t\t\treturn when.all(modules);\n\t\t\t}\n\n\t\t\tfunction allModulesLoaded() {\n\t\t\t\treturn modulesToLoad.length === 0;\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// Context Destroy\n\t\t//\n\n\t\tfunction destroyContext() {\n\t\t\tvar shutdown;\n\n\t\t\tscopeDestroyed.resolve();\n\n\t\t\t// TODO: Clear out the context prototypes?\n\n\t\t\tshutdown = when.reduce(proxiedComponents, function(unused, proxied) {\n\t\t\t\treturn lifecycle.shutdown(proxied);\n\t\t\t}, undef);\n\n\t\t\treturn when(shutdown, function () {\n\t\t\t\tfunction deleteAll(container) {\n\t\t\t\t\tfor(var p in container) {\n\t\t\t\t\t\tdelete container[p];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdeleteAll(components);\n\t\t\t\tdeleteAll(scope);\n\n\t\t\t\treturn when.reduce(proxiedComponents, function(p, proxied) {\n\t\t\t\t\twhen(p, function() {\n\t\t\t\t\t\tproxied.destroy();\n\t\t\t\t\t});\n\t\t\t\t}, undef)\n\t\t\t\t.then(function() {\n\t\t\t\t\t// Free Objects\n\t\t\t\t\tcomponents = scope = parent\n\t\t\t\t\t\t= resolvers = factories = facets = listeners\n\t\t\t\t\t\t= wireApi = proxiedComponents = proxiers = plugins\n\t\t\t\t\t\t= undef;\n\n\t\t\t\t\treturn scopeDestroyed.promise;\n\n\t\t\t\t});\n\n\t\t\t});\n\t\t}\n\n\t\t//\n\t\t// Context API\n\t\t//\n\n\t\t// API of a wired context that is returned, via promise, to\n\t\t// the caller.  It will also have properties for all the\n\t\t// objects that were created in this scope.\n\n\t\t/**\n\t\t * Resolves a reference in the current context, using any reference resolvers\n\t\t * available in the current context\n\t\t *\n\t\t * @param ref {String} reference name (may contain resolver prefix, e.g. \"resolver!refname\"\n\t\t */\n\t\tfunction apiResolveRef(ref, onBehalfOf) {\n\t\t\treturn when(resolveRefName(ref, {}, onBehalfOf));\n\t\t}\n\n\t\t/**\n\t\t * Destroys the current context\n\t\t */\n\t\tfunction apiDestroy() {\n\t\t\treturn destroy();\n\t\t}\n\n\t\t/**\n\t\t * Wires a child spec with this context as its parent\n\t\t * @param spec\n\t\t */\n\t\tfunction wireChild(spec, options) {\n\t\t\treturn createContext(spec, scopeParent, options);\n\t\t}\n\n\t\t//\n\t\t// Scope functions\n\t\t//\n\n\t\tfunction createPath(name, basePath) {\n\t\t\tvar path = basePath || scope.path;\n\n\t\t\treturn (path && name) ? (path + '.' + name) : name;\n\t\t}\n\n\t\tfunction createScopeItem(name, val, resolver) {\n\t\t\t// NOTE: Order is important here.\n\t\t\t// The object & local property assignment MUST happen before\n\t\t\t// the chain resolves so that the concrete item is in place.\n\t\t\t// Otherwise, the whole scope can be marked as resolved before\n\t\t\t// the final item has been resolved.\n\t\t\tvar p = createItem(val, name);\n\n\t\t\treturn when(p, function (resolved) {\n\t\t\t\tmakeResolvable(name, resolved);\n\t\t\t\tresolver.resolve(resolved);\n\t\t\t}, resolver.reject);\n\t\t}\n\n\t\t/**\n\t\t * Make a component resolvable under the given name\n\t\t * @param name {String} name by which to allow the component to be resolved\n\t\t * @param component {*} component\n\t\t */\n\t\tfunction makeResolvable(name, component) {\n\t\t\tcomponents[name] = getResolvedValue(component);\n\t\t}\n\n\t\tfunction createItem(val, name) {\n\t\t\tvar created;\n\n\t\t\tif (resolver.isRef(val)) {\n\t\t\t\t// Reference\n\t\t\t\tcreated = resolveRef(val, name);\n\n\t\t\t} else if (Array.isArray(val)) {\n\t\t\t\t// Array\n\t\t\t\tcreated = createArray(val, name);\n\n\t\t\t} else if (object.isObject(val)) {\n\t\t\t\t// component spec, create the component\n\t\t\t\tcreated = realizeComponent(val, name);\n\n\t\t\t} else {\n\t\t\t\t// Plain value\n\t\t\t\tcreated = when.resolve(val);\n\t\t\t}\n\n\t\t\treturn created;\n\t\t}\n\n\t\tfunction getModule(moduleId, spec) {\n\t\t\tvar module = defer();\n\n\t\t\tscanPluginWhenLoaded(typeof moduleId == 'string'\n\t\t\t\t? moduleLoader(moduleId)\n\t\t\t\t: moduleId, module.resolver);\n\n\t\t\treturn module.promise;\n\n\t\t\tfunction scanPluginWhenLoaded(loadModulePromise, moduleReadyResolver) {\n\n\t\t\t\tvar loadPromise = when(loadModulePromise, function (module) {\n\t\t\t\t\treturn when(scanPlugin(module, spec), function() {\n\t\t\t\t\t\tmodulesReady.promise.then(function() {\n\t\t\t\t\t\t\treturn module;\n\t\t\t\t\t\t}).then(moduleReadyResolver.resolve, moduleReadyResolver.reject);\n\t\t\t\t\t}, moduleReadyResolver.reject);\n\t\t\t\t}, moduleReadyResolver.reject);\n\n\t\t\t\tmodulesToLoad && modulesToLoad.push(loadPromise);\n\n\t\t\t}\n\t\t}\n\n\t\tfunction scanPlugin(module, spec) {\n\t\t\tif (module && isFunction(module.wire$plugin) && plugins.indexOf(module.wire$plugin) === -1) {\n\t\t\t\t// Add to singleton plugins list to only allow one instance\n\t\t\t\t// of this plugin in the current context.\n\t\t\t\tplugins.push(module.wire$plugin);\n\n\t\t\t\t// Initialize the plugin for this context\n\t\t\t\treturn when(module.wire$plugin(scopeReady.promise, scopeDestroyed.promise, spec),\n\t\t\t\t\tfunction(plugin) {\n\t\t\t\t\t\tplugin && registerPlugin(plugin);\n\t\t\t\t\t\treturn module;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn module;\n\t\t}\n\n\t\tfunction registerPlugin(plugin) {\n\t\t\taddPlugin(plugin.resolvers, resolvers);\n\t\t\taddPlugin(plugin.factories, factories);\n\t\t\taddPlugin(plugin.facets, facets);\n\n\t\t\tlisteners.push(plugin);\n\n\t\t\taddProxies(plugin.proxies);\n\t\t}\n\n\t\tfunction addProxies(proxiesToAdd) {\n\t\t\tif (!proxiesToAdd) { return; }\n\n\t\t\tvar newProxiers, p, i = 0;\n\n\t\t\tnewProxiers = [];\n\t\t\twhile (p = proxiesToAdd[i++]) {\n\t\t\t\tif (proxiers.indexOf(p) < 0) {\n\t\t\t\t\tnewProxiers.push(p);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscope.proxiers = proxiers = newProxiers.concat(proxiers);\n\t\t}\n\n\t\tfunction addPlugin(src, registry) {\n\t\t\tvar name;\n\t\t\tfor (name in src) {\n\t\t\t\tif (registry.hasOwnProperty(name)) {\n\t\t\t\t\tthrow new Error(\"Two plugins for same type in scope: \" + name);\n\t\t\t\t}\n\n\t\t\t\tregistry[name] = src[name];\n\t\t\t}\n\t\t}\n\n\t\tfunction createArray(arrayDef, name) {\n\t\t\t// Minor optimization, if it's an empty array spec, just return\n\t\t\t// an empty array.\n\t\t\treturn arrayDef.length\n\t\t\t\t? when.map(arrayDef, function(item) {\n\t\t\t\t\treturn createItem(item, name + '[]');\n\t\t\t\t})\n\t\t\t\t: [];\n\t\t}\n\n\t\t/**\n\t\t * Fully realize a component from a spec: create, initialize, then\n\t\t * startup.\n\t\t * @param spec {Object} component spec\n\t\t * @param name {String} component name\n\t\t * @return {Promise} promise for the fully realized component\n\t\t */\n\t\tfunction realizeComponent(spec, name) {\n\n\t\t\t// Look for a factory, then use it to create the object\n\t\t\treturn when(findFactory(spec),\n\t\t\t\tfunction (factory) {\n\t\t\t\t\tvar component = defer();\n\n\t\t\t\t\tif (!spec.id) {\n\t\t\t\t\t\tspec.id = name;\n\t\t\t\t\t}\n\n\t\t\t\t\tfactory(component.resolver, spec, pluginApi);\n\n\t\t\t\t\treturn processComponent(component.promise, spec, name);\n\t\t\t\t},\n\t\t\t\tfunction () {\n\t\t\t\t\t// No factory found, treat object spec as a nested scope\n\t\t\t\t\treturn createScope(spec, scope, { name: name }).then(function(context) {\n\t\t\t\t\t\treturn safeMixin({}, context);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\t/**\n\t\t * Move component through all phases of the component lifecycle up\n\t\t * to ready.\n\t\t * @param component {*} component or promise for a component\n\t\t * @param spec {Object} component spec\n\t\t * @param name {String} component name\n\t\t * @return {Promise} promise for the component in the ready state\n\t\t */\n\t\tfunction processComponent(component, spec, name) {\n\t\t\treturn when(component, function(component) {\n\n\t\t\t\treturn when(createProxy(component, spec), function(proxy) {\n\t\t\t\t\treturn lifecycle.init(proxy);\n\n\t\t\t\t}).then(function(proxy) {\n\t\t\t\t\t// Components become resolvable after the initialization phase\n\t\t\t\t\t// This allows circular references to be resolved after init\n\t\t\t\t\tmakeResolvable(name, proxy.target);\n\t\t\t\t\treturn lifecycle.startup(proxy);\n\n\t\t\t\t}).then(function(proxy) {\n\t\t\t\t\treturn proxy.target;\n\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Select the factory plugin to use to create a component\n\t\t * for the supplied component spec\n\t\t * @param spec {Object} component spec\n\t\t * @return {Promise} promise for factory, rejected if no suitable\n\t\t *  factory can be found\n\t\t */\n\t\tfunction findFactory(spec) {\n\n\t\t\t// FUTURE: Should not have to wait for all modules to load,\n\t\t\t// but rather only the module containing the particular\n\t\t\t// factory we need.  But how to know which factory before\n\t\t\t// they are all loaded?\n\t\t\t// Maybe need a special syntax for factories, something like:\n\t\t\t// create: \"factory!whatever-arg-the-factory-takes\"\n\t\t\t// args: [factory args here]\n\n\t\t\tfunction getFactory() {\n\t\t\t\tvar f, factory;\n\n\t\t\t\tfor (f in factories) {\n\t\t\t\t\tif (spec.hasOwnProperty(f)) {\n\t\t\t\t\t\tfactory = factories[f];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Intentionally returns undefined if no factory found\n\t\t\t\treturn factory;\n\t\t\t}\n\n\t\t\treturn getFactory() || when(modulesReady.promise, function () {\n\t\t\t\treturn getFactory() || when.reject(spec);\n\t\t\t});\n\t\t}\n\n\t\tfunction createProxy(object, spec) {\n\t\t\treturn when(modulesReady.promise, function() {\n\t\t\t\tvar proxier, proxy, id, i;\n\n\t\t\t\ti = 0;\n\n\t\t\t\twhile ((proxier = proxiers[i++]) && !(proxy = proxier(object, spec))) {}\n\n\t\t\t\tproxy.target = object;\n\t\t\t\tproxy.spec = spec;\n\n\t\t\t\tif(spec) {\n\t\t\t\t\tid = spec && spec.id;\n\t\t\t\t\tproxy.id = id;\n\t\t\t\t\tproxy.path = createPath(id);\n\t\t\t\t\tproxiedComponents.push(proxy);\n\t\t\t\t}\n\n\t\t\t\treturn proxy;\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Return a proxy for the component name, or concrete component\n\t\t * @param nameOrComponent {String|*} if it's a string, consider it to be a component name\n\t\t *  otherwise, consider it to be a concrete component\n\t\t * @return {Object|Promise} proxy or promise for proxy of the component\n\t\t */\n\t\tfunction getProxy(nameOrComponent, onBehalfOf) {\n\t\t\treturn typeof nameOrComponent != 'string'\n\t\t\t\t? createProxy(nameOrComponent)\n\t\t\t\t: when(resolveRefName(nameOrComponent, {}, onBehalfOf), function(component) {\n\t\t\t\t\treturn createProxy(component);\n\t\t\t\t});\n\t\t}\n\n\t\t//\n\t\t// Destroy\n\t\t//\n\n\t\t/**\n\t\t * Destroy the current context.  Waits for the context to finish\n\t\t * wiring and then immediately destroys it.\n\t\t *\n\t\t * @return {Promise} a promise that will resolve once the context\n\t\t * has been destroyed\n\t\t */\n\t\tfunction destroy() {\n\t\t\treturn when(scopeReady.promise, doDestroy, doDestroy);\n\t\t}\n\n\t\t//\n\t\t// Reference resolution\n\t\t//\n\n\t\t/**\n\t\t * Resolves the supplied ref as a local component name, or delegates\n\t\t * to registered resolver plugins\n\t\t * @param ref {Object} reference object returned by resolver.parse or resolver.create\n\t\t * @param scope {Object} scope for resolving local component names\n\t\t * @param [onBehalfOf] {*} optional indicator of the party requesting the reference\n\t\t * @return {Promise} a promise for the fully resolved reference value\n\t\t */\n\t\tfunction doResolveRef(ref, scope, onBehalfOf) {\n\t\t\treturn ref.resolver\n\t\t\t\t? when(modulesReady.promise, ref.resolve)\n\t\t\t\t: doResolveDeepRef(ref.name, scope);\n\t\t}\n\n\t\t/**\n\t\t * Resolves a component references, traversing one level of \".\" nesting\n\t\t * if necessarily (e.g. \"thing.property\")\n\t\t * @param name {String} component name or dot-separated path\n\t\t * @param scope {Object} scope in which to resolve the reference\n\t\t * @return {Promise} promise for the referenced component or property\n\t\t */\n\t\tfunction doResolveDeepRef(name, scope) {\n\t\t\tvar parts = name.split('.');\n\n\t\t\tif(parts.length > 2) {\n\t\t\t\treturn when.reject('Only 1 \".\" is allowed in refs: ' + name);\n\t\t\t}\n\n\t\t\treturn when.reduce(parts, function(scope, segment) {\n\t\t\t\treturn segment in scope\n\t\t\t\t\t? scope[segment]\n\t\t\t\t\t: when.reject('Cannot resolve ref: ' + name);\n\t\t\t}, scope);\n\t\t}\n\n\t\t/**\n\t\t * @param ref {*} any reference format supported by the registered resolver\n\t\t * @param name {String} component name to which the the resolved value of the reference\n\t\t *  will eventually be assigned.  Used to avoid self-circular references.\n\t\t * @return {Promise} a promise for the fully resolved reference value\n\t\t */\n\t\tfunction resolveRef(ref, name) {\n\t\t\tvar scope;\n\n\t\t\tref = resolver.parse(ref);\n\t\t\tscope = name == ref.name && parent.components ? parent.components : components;\n\n\t\t\treturn doResolveRef(ref, scope, name);\n\t\t}\n\n\t\t/**\n\t\t *\n\t\t * @param refName {String} name of reference to resolve. Can be either a\n\t\t *  component name, or a plugin-style reference, e.g. plugin!reference\n\t\t * @param [options] {Object} additional options to pass to reference resolver\n\t\t *  plugins if the refName requires a plugin to resolve\n\t\t * @param [onBehalfOf] {*} optional indicator of the party requesting the reference\n\t\t * @return {Promise} a promise for the fully resolved reference value\n\t\t */\n\t\tfunction resolveRefName(refName, options, onBehalfOf) {\n\t\t\treturn doResolveRef(resolver.create(refName, options), components, onBehalfOf);\n\t\t}\n\n\t\t/**\n\t\t * Builtin reference resolver that resolves to the context-specific\n\t\t * wire function.\n\t\t *\n\t\t * @param resolver {Resolver} resolver to resolve\n\t\t */\n\t\tfunction wireResolver(resolver /*, name, refObj, wire*/) {\n\t\t\tresolver.resolve(wireApi);\n\t\t}\n\n\t\t//\n\t\t// Built-in Factories\n\t\t//\n\n\t\t/**\n\t\t * Factory that creates either a child context, or a *function* that will create\n\t\t * that child context.  In the case that a child is created, this factory returns\n\t\t * a promise that will resolve when the child has completed wiring.\n\t\t *\n\t\t * @param resolver {Resolver} resolver to resolve with the created component\n\t\t * @param spec {Object} portion of the spec for the component to be created\n\t\t */\n\t\tfunction wireFactory(resolver, spec, wire) {\n\t\t\t//\n\t\t\t// TODO: Move wireFactory to its own module\n\t\t\t//\n\t\t\tvar options, module, provide, defer, waitParent;\n\n\t\t\toptions = spec.wire;\n\n\t\t\t// Get child spec and options\n\t\t\tif (isString(options)) {\n\t\t\t\tmodule = options;\n\t\t\t} else {\n\t\t\t\tmodule = options.spec;\n\t\t\t\twaitParent = options.waitParent;\n\t\t\t\tdefer = options.defer;\n\t\t\t\tprovide = options.provide;\n\t\t\t}\n\n\t\t\tfunction init(context) {\n\t\t\t\tif(provide) {\n\t\t\t\t\treturn when(wire(provide), function(provides) {\n\t\t\t\t\t\tsafeMixin(context.components, provides);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction createChild(/** {Object|String}? */ mixin) {\n\t\t\t\tvar spec, config;\n\n\t\t\t\tspec = mixin ? [].concat(module, mixin) : module;\n\t\t\t\tconfig = { init: init };\n\n\t\t\t\tvar child = wireChild(spec, config);\n\t\t\t\treturn defer ? child\n\t\t\t\t\t: when(child, function(child) {\n\t\t\t\t\t\treturn child.hasOwnProperty('$exports') ? child.$exports : child;\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (defer) {\n\t\t\t\t// Resolve with the createChild *function* itself\n\t\t\t\t// which can be used later to wire the spec\n\t\t\t\tresolver.resolve(createChild);\n\n\t\t\t} else if(waitParent) {\n\n\t\t\t\tvar childPromise = when(scopeReady, function() {\n\t\t\t\t\t// ensure nothing is passed to createChild here\n\t\t\t\t\treturn createChild();\n\t\t\t\t});\n\n\t\t\t\tresolver.resolve(new ResolvedValue(childPromise));\n\n\t\t\t} else {\n\t\t\t\tresolver.resolve(createChild(spec));\n\n\t\t\t}\n\t\t}\n\n\t} // createScope\n\n\tfunction getModuleLoader(context, options) {\n\t\treturn options && options.require\n\t\t\t? createModuleLoader(options.require)\n\t\t\t: context.moduleLoader;\n\t}\n\n\t/**\n\t * Given a mixed array of strings and non-strings, returns a promise that will resolve\n\t * to an array containing resolved modules by loading all the strings found in the\n\t * specs array as module ids\n\t * @private\n\t *\n\t * @param specs {Array} mixed array of strings and non-strings\n\t *\n\t * @returns {Promise} a promise that resolves to an array of resolved modules\n\t */\n\tfunction ensureAllSpecsLoaded(specs, loadModule) {\n\t\treturn when.reduce(specs, function(merged, module) {\n\t\t\treturn isString(module)\n\t\t\t\t? when(loadModule(module), function(spec) { return safeMixin(merged, spec); })\n\t\t\t\t: safeMixin(merged, module);\n\t\t}, {});\n\t}\n\n\t/**\n\t * Add components in from to those in to.  If duplicates are found, it\n\t * is an error.\n\t * @param to {Object} target object\n\t * @param from {Object} source object\n\t */\n\tfunction safeMixin(to, from) {\n\t\tfor (var name in from) {\n\t\t\tif (from.hasOwnProperty(name) && !(name in emptyObject)) {\n\t\t\t\tif (to.hasOwnProperty(name)) {\n\t\t\t\t\tthrow new Error(\"Duplicate component name in sibling specs: \" + name);\n\t\t\t\t} else {\n\t\t\t\t\tto[name] = from[name];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn to;\n\t}\n\n\tfunction isString(it) {\n\t\treturn typeof it == 'string';\n\t}\n\n\t/**\n\t * Standard function test\n\t * @param it\n\t */\n\tfunction isFunction(it) {\n\t\treturn typeof it == 'function';\n\t}\n\n\t/**\n\t * Special object to hold a Promise that should not be resolved, but\n\t * rather should be passed through a promise chain *as the resolution value*\n\t * @param val\n\t */\n\tfunction ResolvedValue(val) {\n\t\tthis.value = val;\n\t}\n\n\t/**\n\t * If it is a PromiseKeeper, return it.value, otherwise return it.  See\n\t * PromiseKeeper above for an explanation.\n\t * @param it anything\n\t */\n\tfunction getResolvedValue(it) {\n\t\treturn it instanceof ResolvedValue ? it.value : it;\n\t}\n\n\n\t// TODO: Start using this after compatible curl release\n\t// TODO: Move to somewhere more logical and modular, like lib/resolver.js\n});\n})(typeof define == 'function'\n\t// AMD\n\t? define\n\t// CommonJS\n\t: function(deps, factory) {\n\t\tmodule.exports = factory.apply(this, [require].concat(deps.slice(1).map(function(x) {\n\t\t\treturn require(x);\n\t\t})));\n\t}\n);","modules":[{"pos":183,"count":219,"depList":["require","when/when","wire/lib/array","wire/lib/object","wire/lib/async","wire/lib/moduleLoader","wire/lib/lifecycle","wire/lib/resolver","wire/base"],"factory":true,"argList":["require","when","array","object","async","createModuleLoader","Lifecycle","Resolver","basePlugin"],"id":"wire/lib/context"}]}