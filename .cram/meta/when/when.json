{"absId":"when/when","text":"/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * A lightweight CommonJS Promises/A and when() implementation\n * when is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author Brian Cavalier\n * @author John Hann\n * @version 2.2.1\n */\n(function(define, global) { 'use strict';\ndefine(function () {\n\n\t// Public API\n\n\twhen.promise   = promise;    // Create a pending promise\n\twhen.resolve   = resolve;    // Create a resolved promise\n\twhen.reject    = reject;     // Create a rejected promise\n\twhen.defer     = defer;      // Create a {promise, resolver} pair\n\n\twhen.join      = join;       // Join 2 or more promises\n\n\twhen.all       = all;        // Resolve a list of promises\n\twhen.map       = map;        // Array.map() for promises\n\twhen.reduce    = reduce;     // Array.reduce() for promises\n\twhen.settle    = settle;     // Settle a list of promises\n\n\twhen.any       = any;        // One-winner race\n\twhen.some      = some;       // Multi-winner race\n\n\twhen.isPromise = isPromise;  // Determine if a thing is a promise\n\n\n\t/**\n\t * Register an observer for a promise or immediate value.\n\t *\n\t * @param {*} promiseOrValue\n\t * @param {function?} [onFulfilled] callback to be called when promiseOrValue is\n\t *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n\t *   will be invoked immediately.\n\t * @param {function?} [onRejected] callback to be called when promiseOrValue is\n\t *   rejected.\n\t * @param {function?} [onProgress] callback to be called when progress updates\n\t *   are issued for promiseOrValue.\n\t * @returns {Promise} a new {@link Promise} that will complete with the return\n\t *   value of callback or errback or the completion value of promiseOrValue if\n\t *   callback and/or errback is not supplied.\n\t */\n\tfunction when(promiseOrValue, onFulfilled, onRejected, onProgress) {\n\t\t// Get a trusted promise for the input promiseOrValue, and then\n\t\t// register promise handlers\n\t\treturn resolve(promiseOrValue).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Trusted Promise constructor.  A Promise created from this constructor is\n\t * a trusted when.js promise.  Any other duck-typed promise is considered\n\t * untrusted.\n\t * @constructor\n\t * @name Promise\n\t */\n\tfunction Promise(then, inspect) {\n\t\tthis.then = then;\n\t\tthis.inspect = inspect;\n\t}\n\n\tPromise.prototype = {\n\t\t/**\n\t\t * Register a rejection handler.  Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @return {Promise}\n\t\t */\n\t\totherwise: function(onRejected) {\n\t\t\treturn this.then(undef, onRejected);\n\t\t},\n\n\t\t/**\n\t\t * Ensures that onFulfilledOrRejected will be called regardless of whether\n\t\t * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT\n\t\t * receive the promises' value or reason.  Any returned value will be disregarded.\n\t\t * onFulfilledOrRejected may throw or return a rejected promise to signal\n\t\t * an additional error.\n\t\t * @param {function} onFulfilledOrRejected handler to be called regardless of\n\t\t *  fulfillment or rejection\n\t\t * @returns {Promise}\n\t\t */\n\t\tensure: function(onFulfilledOrRejected) {\n\t\t\treturn this.then(injectHandler, injectHandler)['yield'](this);\n\n\t\t\tfunction injectHandler() {\n\t\t\t\treturn resolve(onFulfilledOrRejected());\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Shortcut for .then(function() { return value; })\n\t\t * @param  {*} value\n\t\t * @return {Promise} a promise that:\n\t\t *  - is fulfilled if value is not a promise, or\n\t\t *  - if value is a promise, will fulfill with its value, or reject\n\t\t *    with its reason.\n\t\t */\n\t\t'yield': function(value) {\n\t\t\treturn this.then(function() {\n\t\t\t\treturn value;\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Assumes that this promise will fulfill with an array, and arranges\n\t\t * for the onFulfilled to be called with the array as its argument list\n\t\t * i.e. onFulfilled.apply(undefined, array).\n\t\t * @param {function} onFulfilled function to receive spread arguments\n\t\t * @return {Promise}\n\t\t */\n\t\tspread: function(onFulfilled) {\n\t\t\treturn this.then(function(array) {\n\t\t\t\t// array may contain promises, so resolve its contents.\n\t\t\t\treturn all(array, function(array) {\n\t\t\t\t\treturn onFulfilled.apply(undef, array);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Shortcut for .then(onFulfilledOrRejected, onFulfilledOrRejected)\n\t\t * @deprecated\n\t\t */\n\t\talways: function(onFulfilledOrRejected, onProgress) {\n\t\t\treturn this.then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress);\n\t\t}\n\t};\n\n\t/**\n\t * Returns a resolved promise. The returned promise will be\n\t *  - fulfilled with promiseOrValue if it is a value, or\n\t *  - if promiseOrValue is a promise\n\t *    - fulfilled with promiseOrValue's value after it is fulfilled\n\t *    - rejected with promiseOrValue's reason after it is rejected\n\t * @param  {*} value\n\t * @return {Promise}\n\t */\n\tfunction resolve(value) {\n\t\treturn promise(function(resolve) {\n\t\t\tresolve(value);\n\t\t});\n\t}\n\n\t/**\n\t * Returns a rejected promise for the supplied promiseOrValue.  The returned\n\t * promise will be rejected with:\n\t * - promiseOrValue, if it is a value, or\n\t * - if promiseOrValue is a promise\n\t *   - promiseOrValue's value after it is fulfilled\n\t *   - promiseOrValue's reason after it is rejected\n\t * @param {*} promiseOrValue the rejected value of the returned {@link Promise}\n\t * @return {Promise} rejected {@link Promise}\n\t */\n\tfunction reject(promiseOrValue) {\n\t\treturn when(promiseOrValue, rejected);\n\t}\n\n\t/**\n\t * Creates a {promise, resolver} pair, either or both of which\n\t * may be given out safely to consumers.\n\t * The resolver has resolve, reject, and progress.  The promise\n\t * has then plus extended promise API.\n\t *\n\t * @return {{\n\t * promise: Promise,\n\t * resolve: function:Promise,\n\t * reject: function:Promise,\n\t * notify: function:Promise\n\t * resolver: {\n\t *\tresolve: function:Promise,\n\t *\treject: function:Promise,\n\t *\tnotify: function:Promise\n\t * }}}\n\t */\n\tfunction defer() {\n\t\tvar deferred, pending, resolved;\n\n\t\t// Optimize object shape\n\t\tdeferred = {\n\t\t\tpromise: undef, resolve: undef, reject: undef, notify: undef,\n\t\t\tresolver: { resolve: undef, reject: undef, notify: undef }\n\t\t};\n\n\t\tdeferred.promise = pending = promise(makeDeferred);\n\n\t\treturn deferred;\n\n\t\tfunction makeDeferred(resolvePending, rejectPending, notifyPending) {\n\t\t\tdeferred.resolve = deferred.resolver.resolve = function(value) {\n\t\t\t\tif(resolved) {\n\t\t\t\t\treturn resolve(value);\n\t\t\t\t}\n\t\t\t\tresolved = true;\n\t\t\t\tresolvePending(value);\n\t\t\t\treturn pending;\n\t\t\t};\n\n\t\t\tdeferred.reject  = deferred.resolver.reject  = function(reason) {\n\t\t\t\tif(resolved) {\n\t\t\t\t\treturn resolve(rejected(reason));\n\t\t\t\t}\n\t\t\t\tresolved = true;\n\t\t\t\trejectPending(reason);\n\t\t\t\treturn pending;\n\t\t\t};\n\n\t\t\tdeferred.notify  = deferred.resolver.notify  = function(update) {\n\t\t\t\tnotifyPending(update);\n\t\t\t\treturn update;\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new promise whose fate is determined by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t */\n\tfunction promise(resolver) {\n\t\treturn _promise(resolver, monitorApi.PromiseStatus && monitorApi.PromiseStatus());\n\t}\n\n\t/**\n\t * Creates a new promise, linked to parent, whose fate is determined\n\t * by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @param {Promise?} status promise from which the new promise is begotten\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t * @private\n\t */\n\tfunction _promise(resolver, status) {\n\t\tvar self, value, handlers = [];\n\n\t\tself = new Promise(then, inspect);\n\n\t\t// Call the provider resolver to seal the promise's fate\n\t\ttry {\n\t\t\tresolver(promiseResolve, promiseReject, promiseNotify);\n\t\t} catch(e) {\n\t\t\tpromiseReject(e);\n\t\t}\n\n\t\t// Return the promise\n\t\treturn self;\n\n\t\t/**\n\t\t * Register handlers for this promise.\n\t\t * @param [onFulfilled] {Function} fulfillment handler\n\t\t * @param [onRejected] {Function} rejection handler\n\t\t * @param [onProgress] {Function} progress handler\n\t\t * @return {Promise} new Promise\n\t\t */\n\t\tfunction then(onFulfilled, onRejected, onProgress) {\n\t\t\tvar next = _promise(function(resolve, reject, notify) {\n\t\t\t\t// if not resolved, push onto handlers, otherwise execute asap\n\t\t\t\t// but not in the current stack\n\t\t\t\thandlers ? handlers.push(run) : enqueue(function() { run(value); });\n\n\t\t\t\tfunction run(p) {\n\t\t\t\t\tp.then(onFulfilled, onRejected, onProgress)\n\t\t\t\t\t\t.then(resolve, reject, notify);\n\t\t\t\t}\n\n\t\t\t}, status && status.observed());\n\n\t\t\treturn next;\n\t\t}\n\n\t\tfunction inspect() {\n\t\t\treturn value ? value.inspect() : toPendingState();\n\t\t}\n\n\t\t/**\n\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t * all listeners of the ultimate fulfillment or rejection\n\t\t * @param {*|Promise} val resolution value\n\t\t */\n\t\tfunction promiseResolve(val) {\n\t\t\tif(!handlers) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvalue = coerce(val);\n\t\t\tscheduleHandlers(handlers, value);\n\t\t\thandlers = undef;\n\n\t\t\tif (status) {\n\t\t\t\tvalue.then(\n\t\t\t\t\tfunction () { status.fulfilled(); },\n\t\t\t\t\tfunction(r) { status.rejected(r); }\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Reject this promise with the supplied reason, which will be used verbatim.\n\t\t * @param {*} reason reason for the rejection\n\t\t */\n\t\tfunction promiseReject(reason) {\n\t\t\tpromiseResolve(rejected(reason));\n\t\t}\n\n\t\t/**\n\t\t * Issue a progress event, notifying all progress listeners\n\t\t * @param {*} update progress event payload to pass to all listeners\n\t\t */\n\t\tfunction promiseNotify(update) {\n\t\t\tif(handlers) {\n\t\t\t\tscheduleHandlers(handlers, progressing(update));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Coerces x to a trusted Promise\n\t *\n\t * @private\n\t * @param {*} x thing to coerce\n\t * @returns {Promise} Guaranteed to return a trusted Promise.  If x\n\t *   is trusted, returns x, otherwise, returns a new, trusted, already-resolved\n\t *   Promise whose resolution value is:\n\t *   * the resolution value of x if it's a foreign promise, or\n\t *   * x if it's a value\n\t */\n\tfunction coerce(x) {\n\t\tif(x instanceof Promise) {\n\t\t\treturn x;\n\t\t}\n\n\t\tif (!(x === Object(x) && 'then' in x)) {\n\t\t\treturn fulfilled(x);\n\t\t}\n\n\t\treturn promise(function(resolve, reject, notify) {\n\t\t\tenqueue(function() {\n\t\t\t\ttry {\n\t\t\t\t\t// We must check and assimilate in the same tick, but not the\n\t\t\t\t\t// current tick, careful only to access promiseOrValue.then once.\n\t\t\t\t\tvar untrustedThen = x.then;\n\n\t\t\t\t\tif(typeof untrustedThen === 'function') {\n\t\t\t\t\t\tfcall(untrustedThen, x, resolve, reject, notify);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// It's a value, create a fulfilled wrapper\n\t\t\t\t\t\tresolve(fulfilled(x));\n\t\t\t\t\t}\n\n\t\t\t\t} catch(e) {\n\t\t\t\t\t// Something went wrong, reject\n\t\t\t\t\treject(e);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Create an already-fulfilled promise for the supplied value\n\t * @private\n\t * @param {*} value\n\t * @return {Promise} fulfilled promise\n\t */\n\tfunction fulfilled(value) {\n\t\tvar self = new Promise(function (onFulfilled) {\n\t\t\ttry {\n\t\t\t\treturn typeof onFulfilled == 'function'\n\t\t\t\t\t? coerce(onFulfilled(value)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn rejected(e);\n\t\t\t}\n\t\t}, function() {\n\t\t\treturn toFulfilledState(value);\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Create an already-rejected promise with the supplied rejection reason.\n\t * @private\n\t * @param {*} reason\n\t * @return {Promise} rejected promise\n\t */\n\tfunction rejected(reason) {\n\t\tvar self = new Promise(function (_, onRejected) {\n\t\t\ttry {\n\t\t\t\treturn typeof onRejected == 'function'\n\t\t\t\t\t? coerce(onRejected(reason)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn rejected(e);\n\t\t\t}\n\t\t}, function() {\n\t\t\treturn toRejectedState(reason);\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Create a progress promise with the supplied update.\n\t * @private\n\t * @param {*} update\n\t * @return {Promise} progress promise\n\t */\n\tfunction progressing(update) {\n\t\tvar self = new Promise(function (_, __, onProgress) {\n\t\t\ttry {\n\t\t\t\treturn typeof onProgress == 'function'\n\t\t\t\t\t? progressing(onProgress(update)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn progressing(e);\n\t\t\t}\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Schedule a task that will process a list of handlers\n\t * in the next queue drain run.\n\t * @private\n\t * @param {Array} handlers queue of handlers to execute\n\t * @param {*} value passed as the only arg to each handler\n\t */\n\tfunction scheduleHandlers(handlers, value) {\n\t\tenqueue(function() {\n\t\t\tvar handler, i = 0;\n\t\t\twhile (handler = handlers[i++]) {\n\t\t\t\thandler(value);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Determines if promiseOrValue is a promise or not\n\t *\n\t * @param {*} promiseOrValue anything\n\t * @returns {boolean} true if promiseOrValue is a {@link Promise}\n\t */\n\tfunction isPromise(promiseOrValue) {\n\t\treturn promiseOrValue && typeof promiseOrValue.then === 'function';\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * howMany of the supplied promisesOrValues have resolved, or will reject when\n\t * it becomes impossible for howMany to resolve, for example, when\n\t * (promisesOrValues.length - howMany) + 1 input promises reject.\n\t *\n\t * @param {Array} promisesOrValues array of anything, may contain a mix\n\t *      of promises and values\n\t * @param howMany {number} number of promisesOrValues to resolve\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise} promise that will resolve to an array of howMany values that\n\t *  resolved first, or will reject with an array of\n\t *  (promisesOrValues.length - howMany) + 1 rejection reasons.\n\t */\n\tfunction some(promisesOrValues, howMany, onFulfilled, onRejected, onProgress) {\n\n\t\treturn when(promisesOrValues, function(promisesOrValues) {\n\n\t\t\treturn promise(resolveSome).then(onFulfilled, onRejected, onProgress);\n\n\t\t\tfunction resolveSome(resolve, reject, notify) {\n\t\t\t\tvar toResolve, toReject, values, reasons, fulfillOne, rejectOne, len, i;\n\n\t\t\t\tlen = promisesOrValues.length >>> 0;\n\n\t\t\t\ttoResolve = Math.max(0, Math.min(howMany, len));\n\t\t\t\tvalues = [];\n\n\t\t\t\ttoReject = (len - toResolve) + 1;\n\t\t\t\treasons = [];\n\n\t\t\t\t// No items in the input, resolve immediately\n\t\t\t\tif (!toResolve) {\n\t\t\t\t\tresolve(values);\n\n\t\t\t\t} else {\n\t\t\t\t\trejectOne = function(reason) {\n\t\t\t\t\t\treasons.push(reason);\n\t\t\t\t\t\tif(!--toReject) {\n\t\t\t\t\t\t\tfulfillOne = rejectOne = identity;\n\t\t\t\t\t\t\treject(reasons);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tfulfillOne = function(val) {\n\t\t\t\t\t\t// This orders the values based on promise resolution order\n\t\t\t\t\t\tvalues.push(val);\n\t\t\t\t\t\tif (!--toResolve) {\n\t\t\t\t\t\t\tfulfillOne = rejectOne = identity;\n\t\t\t\t\t\t\tresolve(values);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tfor(i = 0; i < len; ++i) {\n\t\t\t\t\t\tif(i in promisesOrValues) {\n\t\t\t\t\t\t\twhen(promisesOrValues[i], fulfiller, rejecter, notify);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction rejecter(reason) {\n\t\t\t\t\trejectOne(reason);\n\t\t\t\t}\n\n\t\t\t\tfunction fulfiller(val) {\n\t\t\t\t\tfulfillOne(val);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * any one of the supplied promisesOrValues has resolved or will reject when\n\t * *all* promisesOrValues have rejected.\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise} promise that will resolve to the value that resolved first, or\n\t * will reject with an array of all rejected inputs.\n\t */\n\tfunction any(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\n\t\tfunction unwrapSingleResult(val) {\n\t\t\treturn onFulfilled ? onFulfilled(val[0]) : val[0];\n\t\t}\n\n\t\treturn some(promisesOrValues, 1, unwrapSingleResult, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Return a promise that will resolve only once all the supplied promisesOrValues\n\t * have resolved. The resolution value of the returned promise will be an array\n\t * containing the resolution values of each of the promisesOrValues.\n\t * @memberOf when\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise}\n\t */\n\tfunction all(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\t\treturn _map(promisesOrValues, identity).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Joins multiple promises into a single returned promise.\n\t * @return {Promise} a promise that will fulfill when *all* the input promises\n\t * have fulfilled, or will reject when *any one* of the input promises rejects.\n\t */\n\tfunction join(/* ...promises */) {\n\t\treturn _map(arguments, identity);\n\t}\n\n\t/**\n\t * Settles all input promises such that they are guaranteed not to\n\t * be pending once the returned promise fulfills. The returned promise\n\t * will always fulfill, except in the case where `array` is a promise\n\t * that rejects.\n\t * @param {Array|Promise} array or promise for array of promises to settle\n\t * @returns {Promise} promise that always fulfills with an array of\n\t *  outcome snapshots for each input promise.\n\t */\n\tfunction settle(array) {\n\t\treturn _map(array, toFulfilledState, toRejectedState);\n\t}\n\n\t/**\n\t * Promise-aware array map function, similar to `Array.prototype.map()`,\n\t * but input array may contain promises or values.\n\t * @param {Array|Promise} array array of anything, may contain promises and values\n\t * @param {function} mapFunc map function which may return a promise or value\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction map(array, mapFunc) {\n\t\treturn _map(array, mapFunc);\n\t}\n\n\t/**\n\t * Internal map that allows a fallback to handle rejections\n\t * @param {Array|Promise} array array of anything, may contain promises and values\n\t * @param {function} mapFunc map function which may return a promise or value\n\t * @param {function?} fallback function to handle rejected promises\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction _map(array, mapFunc, fallback) {\n\t\treturn when(array, function(array) {\n\n\t\t\treturn promise(resolveMap);\n\n\t\t\tfunction resolveMap(resolve, reject, notify) {\n\t\t\t\tvar results, len, toResolve, i;\n\n\t\t\t\t// Since we know the resulting length, we can preallocate the results\n\t\t\t\t// array to avoid array expansions.\n\t\t\t\ttoResolve = len = array.length >>> 0;\n\t\t\t\tresults = [];\n\n\t\t\t\tif(!toResolve) {\n\t\t\t\t\tresolve(results);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Since mapFunc may be async, get all invocations of it into flight\n\t\t\t\tfor(i = 0; i < len; i++) {\n\t\t\t\t\tif(i in array) {\n\t\t\t\t\t\tresolveOne(array[i], i);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t--toResolve;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction resolveOne(item, i) {\n\t\t\t\t\twhen(item, mapFunc, fallback).then(function(mapped) {\n\t\t\t\t\t\tresults[i] = mapped;\n\n\t\t\t\t\t\tif(!--toResolve) {\n\t\t\t\t\t\t\tresolve(results);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, reject, notify);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n\t * input may contain promises and/or values, and reduceFunc\n\t * may return either a value or a promise, *and* initialValue may\n\t * be a promise for the starting value.\n\t *\n\t * @param {Array|Promise} promise array or promise for an array of anything,\n\t *      may contain a mix of promises and values.\n\t * @param {function} reduceFunc reduce function reduce(currentValue, nextValue, index, total),\n\t *      where total is the total number of items being reduced, and will be the same\n\t *      in each call to reduceFunc.\n\t * @returns {Promise} that will resolve to the final reduced value\n\t */\n\tfunction reduce(promise, reduceFunc /*, initialValue */) {\n\t\tvar args = fcall(slice, arguments, 1);\n\n\t\treturn when(promise, function(array) {\n\t\t\tvar total;\n\n\t\t\ttotal = array.length;\n\n\t\t\t// Wrap the supplied reduceFunc with one that handles promises and then\n\t\t\t// delegates to the supplied.\n\t\t\targs[0] = function (current, val, i) {\n\t\t\t\treturn when(current, function (c) {\n\t\t\t\t\treturn when(val, function (value) {\n\t\t\t\t\t\treturn reduceFunc(c, value, i, total);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\t\treturn reduceArray.apply(array, args);\n\t\t});\n\t}\n\n\t// Snapshot states\n\n\t/**\n\t * Creates a fulfilled state snapshot\n\t * @private\n\t * @param {*} x any value\n\t * @returns {{state:'fulfilled',value:*}}\n\t */\n\tfunction toFulfilledState(x) {\n\t\treturn { state: 'fulfilled', value: x };\n\t}\n\n\t/**\n\t * Creates a rejected state snapshot\n\t * @private\n\t * @param {*} x any reason\n\t * @returns {{state:'rejected',reason:*}}\n\t */\n\tfunction toRejectedState(x) {\n\t\treturn { state: 'rejected', reason: x };\n\t}\n\n\t/**\n\t * Creates a pending state snapshot\n\t * @private\n\t * @returns {{state:'pending'}}\n\t */\n\tfunction toPendingState() {\n\t\treturn { state: 'pending' };\n\t}\n\n\t//\n\t// Utilities, etc.\n\t//\n\n\tvar reduceArray, slice, fcall, nextTick, handlerQueue,\n\t\tsetTimeout, funcProto, call, arrayProto, monitorApi, undef;\n\n\t//\n\t// Shared handler queue processing\n\t//\n\t// Credit to Twisol (https://github.com/Twisol) for suggesting\n\t// this type of extensible queue + trampoline approach for\n\t// next-tick conflation.\n\n\thandlerQueue = [];\n\n\t/**\n\t * Enqueue a task. If the queue is not currently scheduled to be\n\t * drained, schedule it.\n\t * @param {function} task\n\t */\n\tfunction enqueue(task) {\n\t\tif(handlerQueue.push(task) === 1) {\n\t\t\tnextTick(drainQueue);\n\t\t}\n\t}\n\n\t/**\n\t * Drain the handler queue entirely, being careful to allow the\n\t * queue to be extended while it is being processed, and to continue\n\t * processing until it is truly empty.\n\t */\n\tfunction drainQueue() {\n\t\tvar task, i = 0;\n\n\t\twhile(task = handlerQueue[i++]) {\n\t\t\ttask();\n\t\t}\n\n\t\thandlerQueue = [];\n\t}\n\n\t//\n\t// Capture function and array utils\n\t//\n\t/*global setImmediate,process,vertx*/\n\n\t// Allow attaching the monitor to when() if env has no console\n\tmonitorApi = typeof console != 'undefined' ? console : when;\n\n\t// capture setTimeout to avoid being caught by fake timers used in time based tests\n\tsetTimeout = global.setTimeout;\n\t// Prefer setImmediate, cascade to node, vertx and finally setTimeout\n\tnextTick = typeof setImmediate === 'function' ? setImmediate.bind(global)\n\t\t: typeof process === 'object' && process.nextTick ? process.nextTick\n\t\t: typeof vertx === 'object' ? vertx.runOnLoop // vert.x\n\t\t\t: function(task) { setTimeout(task, 0); }; // fallback\n\n\t// Safe function calls\n\tfuncProto = Function.prototype;\n\tcall = funcProto.call;\n\tfcall = funcProto.bind\n\t\t? call.bind(call)\n\t\t: function(f, context) {\n\t\t\treturn f.apply(context, slice.call(arguments, 2));\n\t\t};\n\n\t// Safe array ops\n\tarrayProto = [];\n\tslice = arrayProto.slice;\n\n\t// ES5 reduce implementation if native not available\n\t// See: http://es5.github.com/#x15.4.4.21 as there are many\n\t// specifics and edge cases.  ES5 dictates that reduce.length === 1\n\t// This implementation deviates from ES5 spec in the following ways:\n\t// 1. It does not check if reduceFunc is a Callable\n\treduceArray = arrayProto.reduce ||\n\t\tfunction(reduceFunc /*, initialValue */) {\n\t\t\t/*jshint maxcomplexity: 7*/\n\t\t\tvar arr, args, reduced, len, i;\n\n\t\t\ti = 0;\n\t\t\tarr = Object(this);\n\t\t\tlen = arr.length >>> 0;\n\t\t\targs = arguments;\n\n\t\t\t// If no initialValue, use first item of array (we know length !== 0 here)\n\t\t\t// and adjust i to start at second item\n\t\t\tif(args.length <= 1) {\n\t\t\t\t// Skip to the first real element in the array\n\t\t\t\tfor(;;) {\n\t\t\t\t\tif(i in arr) {\n\t\t\t\t\t\treduced = arr[i++];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If we reached the end of the array without finding any real\n\t\t\t\t\t// elements, it's a TypeError\n\t\t\t\t\tif(++i >= len) {\n\t\t\t\t\t\tthrow new TypeError();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If initialValue provided, use it\n\t\t\t\treduced = args[1];\n\t\t\t}\n\n\t\t\t// Do the actual reduce\n\t\t\tfor(;i < len; ++i) {\n\t\t\t\tif(i in arr) {\n\t\t\t\t\treduced = reduceFunc(reduced, arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn reduced;\n\t\t};\n\n\tfunction identity(x) {\n\t\treturn x;\n\t}\n\n\treturn when;\n});\n})(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(); },\n\tthis\n);\n","modules":[{"pos":428,"count":19,"factory":true,"id":"when/when"}]}{"absId":"when/when","text":"/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * A lightweight CommonJS Promises/A and when() implementation\n * when is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author Brian Cavalier\n * @author John Hann\n * @version 2.2.1\n */\n(function(define, global) { 'use strict';\ndefine(function () {\n\n\t// Public API\n\n\twhen.promise   = promise;    // Create a pending promise\n\twhen.resolve   = resolve;    // Create a resolved promise\n\twhen.reject    = reject;     // Create a rejected promise\n\twhen.defer     = defer;      // Create a {promise, resolver} pair\n\n\twhen.join      = join;       // Join 2 or more promises\n\n\twhen.all       = all;        // Resolve a list of promises\n\twhen.map       = map;        // Array.map() for promises\n\twhen.reduce    = reduce;     // Array.reduce() for promises\n\twhen.settle    = settle;     // Settle a list of promises\n\n\twhen.any       = any;        // One-winner race\n\twhen.some      = some;       // Multi-winner race\n\n\twhen.isPromise = isPromise;  // Determine if a thing is a promise\n\n\n\t/**\n\t * Register an observer for a promise or immediate value.\n\t *\n\t * @param {*} promiseOrValue\n\t * @param {function?} [onFulfilled] callback to be called when promiseOrValue is\n\t *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n\t *   will be invoked immediately.\n\t * @param {function?} [onRejected] callback to be called when promiseOrValue is\n\t *   rejected.\n\t * @param {function?} [onProgress] callback to be called when progress updates\n\t *   are issued for promiseOrValue.\n\t * @returns {Promise} a new {@link Promise} that will complete with the return\n\t *   value of callback or errback or the completion value of promiseOrValue if\n\t *   callback and/or errback is not supplied.\n\t */\n\tfunction when(promiseOrValue, onFulfilled, onRejected, onProgress) {\n\t\t// Get a trusted promise for the input promiseOrValue, and then\n\t\t// register promise handlers\n\t\treturn resolve(promiseOrValue).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Trusted Promise constructor.  A Promise created from this constructor is\n\t * a trusted when.js promise.  Any other duck-typed promise is considered\n\t * untrusted.\n\t * @constructor\n\t * @name Promise\n\t */\n\tfunction Promise(then, inspect) {\n\t\tthis.then = then;\n\t\tthis.inspect = inspect;\n\t}\n\n\tPromise.prototype = {\n\t\t/**\n\t\t * Register a rejection handler.  Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @return {Promise}\n\t\t */\n\t\totherwise: function(onRejected) {\n\t\t\treturn this.then(undef, onRejected);\n\t\t},\n\n\t\t/**\n\t\t * Ensures that onFulfilledOrRejected will be called regardless of whether\n\t\t * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT\n\t\t * receive the promises' value or reason.  Any returned value will be disregarded.\n\t\t * onFulfilledOrRejected may throw or return a rejected promise to signal\n\t\t * an additional error.\n\t\t * @param {function} onFulfilledOrRejected handler to be called regardless of\n\t\t *  fulfillment or rejection\n\t\t * @returns {Promise}\n\t\t */\n\t\tensure: function(onFulfilledOrRejected) {\n\t\t\treturn this.then(injectHandler, injectHandler)['yield'](this);\n\n\t\t\tfunction injectHandler() {\n\t\t\t\treturn resolve(onFulfilledOrRejected());\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Shortcut for .then(function() { return value; })\n\t\t * @param  {*} value\n\t\t * @return {Promise} a promise that:\n\t\t *  - is fulfilled if value is not a promise, or\n\t\t *  - if value is a promise, will fulfill with its value, or reject\n\t\t *    with its reason.\n\t\t */\n\t\t'yield': function(value) {\n\t\t\treturn this.then(function() {\n\t\t\t\treturn value;\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Assumes that this promise will fulfill with an array, and arranges\n\t\t * for the onFulfilled to be called with the array as its argument list\n\t\t * i.e. onFulfilled.apply(undefined, array).\n\t\t * @param {function} onFulfilled function to receive spread arguments\n\t\t * @return {Promise}\n\t\t */\n\t\tspread: function(onFulfilled) {\n\t\t\treturn this.then(function(array) {\n\t\t\t\t// array may contain promises, so resolve its contents.\n\t\t\t\treturn all(array, function(array) {\n\t\t\t\t\treturn onFulfilled.apply(undef, array);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Shortcut for .then(onFulfilledOrRejected, onFulfilledOrRejected)\n\t\t * @deprecated\n\t\t */\n\t\talways: function(onFulfilledOrRejected, onProgress) {\n\t\t\treturn this.then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress);\n\t\t}\n\t};\n\n\t/**\n\t * Returns a resolved promise. The returned promise will be\n\t *  - fulfilled with promiseOrValue if it is a value, or\n\t *  - if promiseOrValue is a promise\n\t *    - fulfilled with promiseOrValue's value after it is fulfilled\n\t *    - rejected with promiseOrValue's reason after it is rejected\n\t * @param  {*} value\n\t * @return {Promise}\n\t */\n\tfunction resolve(value) {\n\t\treturn promise(function(resolve) {\n\t\t\tresolve(value);\n\t\t});\n\t}\n\n\t/**\n\t * Returns a rejected promise for the supplied promiseOrValue.  The returned\n\t * promise will be rejected with:\n\t * - promiseOrValue, if it is a value, or\n\t * - if promiseOrValue is a promise\n\t *   - promiseOrValue's value after it is fulfilled\n\t *   - promiseOrValue's reason after it is rejected\n\t * @param {*} promiseOrValue the rejected value of the returned {@link Promise}\n\t * @return {Promise} rejected {@link Promise}\n\t */\n\tfunction reject(promiseOrValue) {\n\t\treturn when(promiseOrValue, rejected);\n\t}\n\n\t/**\n\t * Creates a {promise, resolver} pair, either or both of which\n\t * may be given out safely to consumers.\n\t * The resolver has resolve, reject, and progress.  The promise\n\t * has then plus extended promise API.\n\t *\n\t * @return {{\n\t * promise: Promise,\n\t * resolve: function:Promise,\n\t * reject: function:Promise,\n\t * notify: function:Promise\n\t * resolver: {\n\t *\tresolve: function:Promise,\n\t *\treject: function:Promise,\n\t *\tnotify: function:Promise\n\t * }}}\n\t */\n\tfunction defer() {\n\t\tvar deferred, pending, resolved;\n\n\t\t// Optimize object shape\n\t\tdeferred = {\n\t\t\tpromise: undef, resolve: undef, reject: undef, notify: undef,\n\t\t\tresolver: { resolve: undef, reject: undef, notify: undef }\n\t\t};\n\n\t\tdeferred.promise = pending = promise(makeDeferred);\n\n\t\treturn deferred;\n\n\t\tfunction makeDeferred(resolvePending, rejectPending, notifyPending) {\n\t\t\tdeferred.resolve = deferred.resolver.resolve = function(value) {\n\t\t\t\tif(resolved) {\n\t\t\t\t\treturn resolve(value);\n\t\t\t\t}\n\t\t\t\tresolved = true;\n\t\t\t\tresolvePending(value);\n\t\t\t\treturn pending;\n\t\t\t};\n\n\t\t\tdeferred.reject  = deferred.resolver.reject  = function(reason) {\n\t\t\t\tif(resolved) {\n\t\t\t\t\treturn resolve(rejected(reason));\n\t\t\t\t}\n\t\t\t\tresolved = true;\n\t\t\t\trejectPending(reason);\n\t\t\t\treturn pending;\n\t\t\t};\n\n\t\t\tdeferred.notify  = deferred.resolver.notify  = function(update) {\n\t\t\t\tnotifyPending(update);\n\t\t\t\treturn update;\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new promise whose fate is determined by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t */\n\tfunction promise(resolver) {\n\t\treturn _promise(resolver, monitorApi.PromiseStatus && monitorApi.PromiseStatus());\n\t}\n\n\t/**\n\t * Creates a new promise, linked to parent, whose fate is determined\n\t * by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @param {Promise?} status promise from which the new promise is begotten\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t * @private\n\t */\n\tfunction _promise(resolver, status) {\n\t\tvar self, value, handlers = [];\n\n\t\tself = new Promise(then, inspect);\n\n\t\t// Call the provider resolver to seal the promise's fate\n\t\ttry {\n\t\t\tresolver(promiseResolve, promiseReject, promiseNotify);\n\t\t} catch(e) {\n\t\t\tpromiseReject(e);\n\t\t}\n\n\t\t// Return the promise\n\t\treturn self;\n\n\t\t/**\n\t\t * Register handlers for this promise.\n\t\t * @param [onFulfilled] {Function} fulfillment handler\n\t\t * @param [onRejected] {Function} rejection handler\n\t\t * @param [onProgress] {Function} progress handler\n\t\t * @return {Promise} new Promise\n\t\t */\n\t\tfunction then(onFulfilled, onRejected, onProgress) {\n\t\t\tvar next = _promise(function(resolve, reject, notify) {\n\t\t\t\t// if not resolved, push onto handlers, otherwise execute asap\n\t\t\t\t// but not in the current stack\n\t\t\t\thandlers ? handlers.push(run) : enqueue(function() { run(value); });\n\n\t\t\t\tfunction run(p) {\n\t\t\t\t\tp.then(onFulfilled, onRejected, onProgress)\n\t\t\t\t\t\t.then(resolve, reject, notify);\n\t\t\t\t}\n\n\t\t\t}, status && status.observed());\n\n\t\t\treturn next;\n\t\t}\n\n\t\tfunction inspect() {\n\t\t\treturn value ? value.inspect() : toPendingState();\n\t\t}\n\n\t\t/**\n\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t * all listeners of the ultimate fulfillment or rejection\n\t\t * @param {*|Promise} val resolution value\n\t\t */\n\t\tfunction promiseResolve(val) {\n\t\t\tif(!handlers) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvalue = coerce(val);\n\t\t\tscheduleHandlers(handlers, value);\n\t\t\thandlers = undef;\n\n\t\t\tif (status) {\n\t\t\t\tvalue.then(\n\t\t\t\t\tfunction () { status.fulfilled(); },\n\t\t\t\t\tfunction(r) { status.rejected(r); }\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Reject this promise with the supplied reason, which will be used verbatim.\n\t\t * @param {*} reason reason for the rejection\n\t\t */\n\t\tfunction promiseReject(reason) {\n\t\t\tpromiseResolve(rejected(reason));\n\t\t}\n\n\t\t/**\n\t\t * Issue a progress event, notifying all progress listeners\n\t\t * @param {*} update progress event payload to pass to all listeners\n\t\t */\n\t\tfunction promiseNotify(update) {\n\t\t\tif(handlers) {\n\t\t\t\tscheduleHandlers(handlers, progressing(update));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Coerces x to a trusted Promise\n\t *\n\t * @private\n\t * @param {*} x thing to coerce\n\t * @returns {Promise} Guaranteed to return a trusted Promise.  If x\n\t *   is trusted, returns x, otherwise, returns a new, trusted, already-resolved\n\t *   Promise whose resolution value is:\n\t *   * the resolution value of x if it's a foreign promise, or\n\t *   * x if it's a value\n\t */\n\tfunction coerce(x) {\n\t\tif(x instanceof Promise) {\n\t\t\treturn x;\n\t\t}\n\n\t\tif (!(x === Object(x) && 'then' in x)) {\n\t\t\treturn fulfilled(x);\n\t\t}\n\n\t\treturn promise(function(resolve, reject, notify) {\n\t\t\tenqueue(function() {\n\t\t\t\ttry {\n\t\t\t\t\t// We must check and assimilate in the same tick, but not the\n\t\t\t\t\t// current tick, careful only to access promiseOrValue.then once.\n\t\t\t\t\tvar untrustedThen = x.then;\n\n\t\t\t\t\tif(typeof untrustedThen === 'function') {\n\t\t\t\t\t\tfcall(untrustedThen, x, resolve, reject, notify);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// It's a value, create a fulfilled wrapper\n\t\t\t\t\t\tresolve(fulfilled(x));\n\t\t\t\t\t}\n\n\t\t\t\t} catch(e) {\n\t\t\t\t\t// Something went wrong, reject\n\t\t\t\t\treject(e);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Create an already-fulfilled promise for the supplied value\n\t * @private\n\t * @param {*} value\n\t * @return {Promise} fulfilled promise\n\t */\n\tfunction fulfilled(value) {\n\t\tvar self = new Promise(function (onFulfilled) {\n\t\t\ttry {\n\t\t\t\treturn typeof onFulfilled == 'function'\n\t\t\t\t\t? coerce(onFulfilled(value)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn rejected(e);\n\t\t\t}\n\t\t}, function() {\n\t\t\treturn toFulfilledState(value);\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Create an already-rejected promise with the supplied rejection reason.\n\t * @private\n\t * @param {*} reason\n\t * @return {Promise} rejected promise\n\t */\n\tfunction rejected(reason) {\n\t\tvar self = new Promise(function (_, onRejected) {\n\t\t\ttry {\n\t\t\t\treturn typeof onRejected == 'function'\n\t\t\t\t\t? coerce(onRejected(reason)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn rejected(e);\n\t\t\t}\n\t\t}, function() {\n\t\t\treturn toRejectedState(reason);\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Create a progress promise with the supplied update.\n\t * @private\n\t * @param {*} update\n\t * @return {Promise} progress promise\n\t */\n\tfunction progressing(update) {\n\t\tvar self = new Promise(function (_, __, onProgress) {\n\t\t\ttry {\n\t\t\t\treturn typeof onProgress == 'function'\n\t\t\t\t\t? progressing(onProgress(update)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn progressing(e);\n\t\t\t}\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Schedule a task that will process a list of handlers\n\t * in the next queue drain run.\n\t * @private\n\t * @param {Array} handlers queue of handlers to execute\n\t * @param {*} value passed as the only arg to each handler\n\t */\n\tfunction scheduleHandlers(handlers, value) {\n\t\tenqueue(function() {\n\t\t\tvar handler, i = 0;\n\t\t\twhile (handler = handlers[i++]) {\n\t\t\t\thandler(value);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Determines if promiseOrValue is a promise or not\n\t *\n\t * @param {*} promiseOrValue anything\n\t * @returns {boolean} true if promiseOrValue is a {@link Promise}\n\t */\n\tfunction isPromise(promiseOrValue) {\n\t\treturn promiseOrValue && typeof promiseOrValue.then === 'function';\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * howMany of the supplied promisesOrValues have resolved, or will reject when\n\t * it becomes impossible for howMany to resolve, for example, when\n\t * (promisesOrValues.length - howMany) + 1 input promises reject.\n\t *\n\t * @param {Array} promisesOrValues array of anything, may contain a mix\n\t *      of promises and values\n\t * @param howMany {number} number of promisesOrValues to resolve\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise} promise that will resolve to an array of howMany values that\n\t *  resolved first, or will reject with an array of\n\t *  (promisesOrValues.length - howMany) + 1 rejection reasons.\n\t */\n\tfunction some(promisesOrValues, howMany, onFulfilled, onRejected, onProgress) {\n\n\t\treturn when(promisesOrValues, function(promisesOrValues) {\n\n\t\t\treturn promise(resolveSome).then(onFulfilled, onRejected, onProgress);\n\n\t\t\tfunction resolveSome(resolve, reject, notify) {\n\t\t\t\tvar toResolve, toReject, values, reasons, fulfillOne, rejectOne, len, i;\n\n\t\t\t\tlen = promisesOrValues.length >>> 0;\n\n\t\t\t\ttoResolve = Math.max(0, Math.min(howMany, len));\n\t\t\t\tvalues = [];\n\n\t\t\t\ttoReject = (len - toResolve) + 1;\n\t\t\t\treasons = [];\n\n\t\t\t\t// No items in the input, resolve immediately\n\t\t\t\tif (!toResolve) {\n\t\t\t\t\tresolve(values);\n\n\t\t\t\t} else {\n\t\t\t\t\trejectOne = function(reason) {\n\t\t\t\t\t\treasons.push(reason);\n\t\t\t\t\t\tif(!--toReject) {\n\t\t\t\t\t\t\tfulfillOne = rejectOne = identity;\n\t\t\t\t\t\t\treject(reasons);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tfulfillOne = function(val) {\n\t\t\t\t\t\t// This orders the values based on promise resolution order\n\t\t\t\t\t\tvalues.push(val);\n\t\t\t\t\t\tif (!--toResolve) {\n\t\t\t\t\t\t\tfulfillOne = rejectOne = identity;\n\t\t\t\t\t\t\tresolve(values);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tfor(i = 0; i < len; ++i) {\n\t\t\t\t\t\tif(i in promisesOrValues) {\n\t\t\t\t\t\t\twhen(promisesOrValues[i], fulfiller, rejecter, notify);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction rejecter(reason) {\n\t\t\t\t\trejectOne(reason);\n\t\t\t\t}\n\n\t\t\t\tfunction fulfiller(val) {\n\t\t\t\t\tfulfillOne(val);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * any one of the supplied promisesOrValues has resolved or will reject when\n\t * *all* promisesOrValues have rejected.\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise} promise that will resolve to the value that resolved first, or\n\t * will reject with an array of all rejected inputs.\n\t */\n\tfunction any(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\n\t\tfunction unwrapSingleResult(val) {\n\t\t\treturn onFulfilled ? onFulfilled(val[0]) : val[0];\n\t\t}\n\n\t\treturn some(promisesOrValues, 1, unwrapSingleResult, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Return a promise that will resolve only once all the supplied promisesOrValues\n\t * have resolved. The resolution value of the returned promise will be an array\n\t * containing the resolution values of each of the promisesOrValues.\n\t * @memberOf when\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise}\n\t */\n\tfunction all(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\t\treturn _map(promisesOrValues, identity).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Joins multiple promises into a single returned promise.\n\t * @return {Promise} a promise that will fulfill when *all* the input promises\n\t * have fulfilled, or will reject when *any one* of the input promises rejects.\n\t */\n\tfunction join(/* ...promises */) {\n\t\treturn _map(arguments, identity);\n\t}\n\n\t/**\n\t * Settles all input promises such that they are guaranteed not to\n\t * be pending once the returned promise fulfills. The returned promise\n\t * will always fulfill, except in the case where `array` is a promise\n\t * that rejects.\n\t * @param {Array|Promise} array or promise for array of promises to settle\n\t * @returns {Promise} promise that always fulfills with an array of\n\t *  outcome snapshots for each input promise.\n\t */\n\tfunction settle(array) {\n\t\treturn _map(array, toFulfilledState, toRejectedState);\n\t}\n\n\t/**\n\t * Promise-aware array map function, similar to `Array.prototype.map()`,\n\t * but input array may contain promises or values.\n\t * @param {Array|Promise} array array of anything, may contain promises and values\n\t * @param {function} mapFunc map function which may return a promise or value\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction map(array, mapFunc) {\n\t\treturn _map(array, mapFunc);\n\t}\n\n\t/**\n\t * Internal map that allows a fallback to handle rejections\n\t * @param {Array|Promise} array array of anything, may contain promises and values\n\t * @param {function} mapFunc map function which may return a promise or value\n\t * @param {function?} fallback function to handle rejected promises\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction _map(array, mapFunc, fallback) {\n\t\treturn when(array, function(array) {\n\n\t\t\treturn promise(resolveMap);\n\n\t\t\tfunction resolveMap(resolve, reject, notify) {\n\t\t\t\tvar results, len, toResolve, i;\n\n\t\t\t\t// Since we know the resulting length, we can preallocate the results\n\t\t\t\t// array to avoid array expansions.\n\t\t\t\ttoResolve = len = array.length >>> 0;\n\t\t\t\tresults = [];\n\n\t\t\t\tif(!toResolve) {\n\t\t\t\t\tresolve(results);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Since mapFunc may be async, get all invocations of it into flight\n\t\t\t\tfor(i = 0; i < len; i++) {\n\t\t\t\t\tif(i in array) {\n\t\t\t\t\t\tresolveOne(array[i], i);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t--toResolve;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction resolveOne(item, i) {\n\t\t\t\t\twhen(item, mapFunc, fallback).then(function(mapped) {\n\t\t\t\t\t\tresults[i] = mapped;\n\n\t\t\t\t\t\tif(!--toResolve) {\n\t\t\t\t\t\t\tresolve(results);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, reject, notify);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n\t * input may contain promises and/or values, and reduceFunc\n\t * may return either a value or a promise, *and* initialValue may\n\t * be a promise for the starting value.\n\t *\n\t * @param {Array|Promise} promise array or promise for an array of anything,\n\t *      may contain a mix of promises and values.\n\t * @param {function} reduceFunc reduce function reduce(currentValue, nextValue, index, total),\n\t *      where total is the total number of items being reduced, and will be the same\n\t *      in each call to reduceFunc.\n\t * @returns {Promise} that will resolve to the final reduced value\n\t */\n\tfunction reduce(promise, reduceFunc /*, initialValue */) {\n\t\tvar args = fcall(slice, arguments, 1);\n\n\t\treturn when(promise, function(array) {\n\t\t\tvar total;\n\n\t\t\ttotal = array.length;\n\n\t\t\t// Wrap the supplied reduceFunc with one that handles promises and then\n\t\t\t// delegates to the supplied.\n\t\t\targs[0] = function (current, val, i) {\n\t\t\t\treturn when(current, function (c) {\n\t\t\t\t\treturn when(val, function (value) {\n\t\t\t\t\t\treturn reduceFunc(c, value, i, total);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\t\treturn reduceArray.apply(array, args);\n\t\t});\n\t}\n\n\t// Snapshot states\n\n\t/**\n\t * Creates a fulfilled state snapshot\n\t * @private\n\t * @param {*} x any value\n\t * @returns {{state:'fulfilled',value:*}}\n\t */\n\tfunction toFulfilledState(x) {\n\t\treturn { state: 'fulfilled', value: x };\n\t}\n\n\t/**\n\t * Creates a rejected state snapshot\n\t * @private\n\t * @param {*} x any reason\n\t * @returns {{state:'rejected',reason:*}}\n\t */\n\tfunction toRejectedState(x) {\n\t\treturn { state: 'rejected', reason: x };\n\t}\n\n\t/**\n\t * Creates a pending state snapshot\n\t * @private\n\t * @returns {{state:'pending'}}\n\t */\n\tfunction toPendingState() {\n\t\treturn { state: 'pending' };\n\t}\n\n\t//\n\t// Utilities, etc.\n\t//\n\n\tvar reduceArray, slice, fcall, nextTick, handlerQueue,\n\t\tsetTimeout, funcProto, call, arrayProto, monitorApi, undef;\n\n\t//\n\t// Shared handler queue processing\n\t//\n\t// Credit to Twisol (https://github.com/Twisol) for suggesting\n\t// this type of extensible queue + trampoline approach for\n\t// next-tick conflation.\n\n\thandlerQueue = [];\n\n\t/**\n\t * Enqueue a task. If the queue is not currently scheduled to be\n\t * drained, schedule it.\n\t * @param {function} task\n\t */\n\tfunction enqueue(task) {\n\t\tif(handlerQueue.push(task) === 1) {\n\t\t\tnextTick(drainQueue);\n\t\t}\n\t}\n\n\t/**\n\t * Drain the handler queue entirely, being careful to allow the\n\t * queue to be extended while it is being processed, and to continue\n\t * processing until it is truly empty.\n\t */\n\tfunction drainQueue() {\n\t\tvar task, i = 0;\n\n\t\twhile(task = handlerQueue[i++]) {\n\t\t\ttask();\n\t\t}\n\n\t\thandlerQueue = [];\n\t}\n\n\t//\n\t// Capture function and array utils\n\t//\n\t/*global setImmediate,process,vertx*/\n\n\t// Allow attaching the monitor to when() if env has no console\n\tmonitorApi = typeof console != 'undefined' ? console : when;\n\n\t// capture setTimeout to avoid being caught by fake timers used in time based tests\n\tsetTimeout = global.setTimeout;\n\t// Prefer setImmediate, cascade to node, vertx and finally setTimeout\n\tnextTick = typeof setImmediate === 'function' ? setImmediate.bind(global)\n\t\t: typeof process === 'object' && process.nextTick ? process.nextTick\n\t\t: typeof vertx === 'object' ? vertx.runOnLoop // vert.x\n\t\t\t: function(task) { setTimeout(task, 0); }; // fallback\n\n\t// Safe function calls\n\tfuncProto = Function.prototype;\n\tcall = funcProto.call;\n\tfcall = funcProto.bind\n\t\t? call.bind(call)\n\t\t: function(f, context) {\n\t\t\treturn f.apply(context, slice.call(arguments, 2));\n\t\t};\n\n\t// Safe array ops\n\tarrayProto = [];\n\tslice = arrayProto.slice;\n\n\t// ES5 reduce implementation if native not available\n\t// See: http://es5.github.com/#x15.4.4.21 as there are many\n\t// specifics and edge cases.  ES5 dictates that reduce.length === 1\n\t// This implementation deviates from ES5 spec in the following ways:\n\t// 1. It does not check if reduceFunc is a Callable\n\treduceArray = arrayProto.reduce ||\n\t\tfunction(reduceFunc /*, initialValue */) {\n\t\t\t/*jshint maxcomplexity: 7*/\n\t\t\tvar arr, args, reduced, len, i;\n\n\t\t\ti = 0;\n\t\t\tarr = Object(this);\n\t\t\tlen = arr.length >>> 0;\n\t\t\targs = arguments;\n\n\t\t\t// If no initialValue, use first item of array (we know length !== 0 here)\n\t\t\t// and adjust i to start at second item\n\t\t\tif(args.length <= 1) {\n\t\t\t\t// Skip to the first real element in the array\n\t\t\t\tfor(;;) {\n\t\t\t\t\tif(i in arr) {\n\t\t\t\t\t\treduced = arr[i++];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If we reached the end of the array without finding any real\n\t\t\t\t\t// elements, it's a TypeError\n\t\t\t\t\tif(++i >= len) {\n\t\t\t\t\t\tthrow new TypeError();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If initialValue provided, use it\n\t\t\t\treduced = args[1];\n\t\t\t}\n\n\t\t\t// Do the actual reduce\n\t\t\tfor(;i < len; ++i) {\n\t\t\t\tif(i in arr) {\n\t\t\t\t\treduced = reduceFunc(reduced, arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn reduced;\n\t\t};\n\n\tfunction identity(x) {\n\t\treturn x;\n\t}\n\n\treturn when;\n});\n})(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(); },\n\tthis\n);\n","modules":[{"pos":428,"count":19,"factory":true,"id":"when/when"}]}{"absId":"when/when","text":"/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * A lightweight CommonJS Promises/A and when() implementation\n * when is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author Brian Cavalier\n * @author John Hann\n * @version 2.2.1\n */\n(function(define, global) { 'use strict';\ndefine(function () {\n\n\t// Public API\n\n\twhen.promise   = promise;    // Create a pending promise\n\twhen.resolve   = resolve;    // Create a resolved promise\n\twhen.reject    = reject;     // Create a rejected promise\n\twhen.defer     = defer;      // Create a {promise, resolver} pair\n\n\twhen.join      = join;       // Join 2 or more promises\n\n\twhen.all       = all;        // Resolve a list of promises\n\twhen.map       = map;        // Array.map() for promises\n\twhen.reduce    = reduce;     // Array.reduce() for promises\n\twhen.settle    = settle;     // Settle a list of promises\n\n\twhen.any       = any;        // One-winner race\n\twhen.some      = some;       // Multi-winner race\n\n\twhen.isPromise = isPromise;  // Determine if a thing is a promise\n\n\n\t/**\n\t * Register an observer for a promise or immediate value.\n\t *\n\t * @param {*} promiseOrValue\n\t * @param {function?} [onFulfilled] callback to be called when promiseOrValue is\n\t *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n\t *   will be invoked immediately.\n\t * @param {function?} [onRejected] callback to be called when promiseOrValue is\n\t *   rejected.\n\t * @param {function?} [onProgress] callback to be called when progress updates\n\t *   are issued for promiseOrValue.\n\t * @returns {Promise} a new {@link Promise} that will complete with the return\n\t *   value of callback or errback or the completion value of promiseOrValue if\n\t *   callback and/or errback is not supplied.\n\t */\n\tfunction when(promiseOrValue, onFulfilled, onRejected, onProgress) {\n\t\t// Get a trusted promise for the input promiseOrValue, and then\n\t\t// register promise handlers\n\t\treturn resolve(promiseOrValue).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Trusted Promise constructor.  A Promise created from this constructor is\n\t * a trusted when.js promise.  Any other duck-typed promise is considered\n\t * untrusted.\n\t * @constructor\n\t * @name Promise\n\t */\n\tfunction Promise(then, inspect) {\n\t\tthis.then = then;\n\t\tthis.inspect = inspect;\n\t}\n\n\tPromise.prototype = {\n\t\t/**\n\t\t * Register a rejection handler.  Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @return {Promise}\n\t\t */\n\t\totherwise: function(onRejected) {\n\t\t\treturn this.then(undef, onRejected);\n\t\t},\n\n\t\t/**\n\t\t * Ensures that onFulfilledOrRejected will be called regardless of whether\n\t\t * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT\n\t\t * receive the promises' value or reason.  Any returned value will be disregarded.\n\t\t * onFulfilledOrRejected may throw or return a rejected promise to signal\n\t\t * an additional error.\n\t\t * @param {function} onFulfilledOrRejected handler to be called regardless of\n\t\t *  fulfillment or rejection\n\t\t * @returns {Promise}\n\t\t */\n\t\tensure: function(onFulfilledOrRejected) {\n\t\t\treturn this.then(injectHandler, injectHandler)['yield'](this);\n\n\t\t\tfunction injectHandler() {\n\t\t\t\treturn resolve(onFulfilledOrRejected());\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Shortcut for .then(function() { return value; })\n\t\t * @param  {*} value\n\t\t * @return {Promise} a promise that:\n\t\t *  - is fulfilled if value is not a promise, or\n\t\t *  - if value is a promise, will fulfill with its value, or reject\n\t\t *    with its reason.\n\t\t */\n\t\t'yield': function(value) {\n\t\t\treturn this.then(function() {\n\t\t\t\treturn value;\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Assumes that this promise will fulfill with an array, and arranges\n\t\t * for the onFulfilled to be called with the array as its argument list\n\t\t * i.e. onFulfilled.apply(undefined, array).\n\t\t * @param {function} onFulfilled function to receive spread arguments\n\t\t * @return {Promise}\n\t\t */\n\t\tspread: function(onFulfilled) {\n\t\t\treturn this.then(function(array) {\n\t\t\t\t// array may contain promises, so resolve its contents.\n\t\t\t\treturn all(array, function(array) {\n\t\t\t\t\treturn onFulfilled.apply(undef, array);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Shortcut for .then(onFulfilledOrRejected, onFulfilledOrRejected)\n\t\t * @deprecated\n\t\t */\n\t\talways: function(onFulfilledOrRejected, onProgress) {\n\t\t\treturn this.then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress);\n\t\t}\n\t};\n\n\t/**\n\t * Returns a resolved promise. The returned promise will be\n\t *  - fulfilled with promiseOrValue if it is a value, or\n\t *  - if promiseOrValue is a promise\n\t *    - fulfilled with promiseOrValue's value after it is fulfilled\n\t *    - rejected with promiseOrValue's reason after it is rejected\n\t * @param  {*} value\n\t * @return {Promise}\n\t */\n\tfunction resolve(value) {\n\t\treturn promise(function(resolve) {\n\t\t\tresolve(value);\n\t\t});\n\t}\n\n\t/**\n\t * Returns a rejected promise for the supplied promiseOrValue.  The returned\n\t * promise will be rejected with:\n\t * - promiseOrValue, if it is a value, or\n\t * - if promiseOrValue is a promise\n\t *   - promiseOrValue's value after it is fulfilled\n\t *   - promiseOrValue's reason after it is rejected\n\t * @param {*} promiseOrValue the rejected value of the returned {@link Promise}\n\t * @return {Promise} rejected {@link Promise}\n\t */\n\tfunction reject(promiseOrValue) {\n\t\treturn when(promiseOrValue, rejected);\n\t}\n\n\t/**\n\t * Creates a {promise, resolver} pair, either or both of which\n\t * may be given out safely to consumers.\n\t * The resolver has resolve, reject, and progress.  The promise\n\t * has then plus extended promise API.\n\t *\n\t * @return {{\n\t * promise: Promise,\n\t * resolve: function:Promise,\n\t * reject: function:Promise,\n\t * notify: function:Promise\n\t * resolver: {\n\t *\tresolve: function:Promise,\n\t *\treject: function:Promise,\n\t *\tnotify: function:Promise\n\t * }}}\n\t */\n\tfunction defer() {\n\t\tvar deferred, pending, resolved;\n\n\t\t// Optimize object shape\n\t\tdeferred = {\n\t\t\tpromise: undef, resolve: undef, reject: undef, notify: undef,\n\t\t\tresolver: { resolve: undef, reject: undef, notify: undef }\n\t\t};\n\n\t\tdeferred.promise = pending = promise(makeDeferred);\n\n\t\treturn deferred;\n\n\t\tfunction makeDeferred(resolvePending, rejectPending, notifyPending) {\n\t\t\tdeferred.resolve = deferred.resolver.resolve = function(value) {\n\t\t\t\tif(resolved) {\n\t\t\t\t\treturn resolve(value);\n\t\t\t\t}\n\t\t\t\tresolved = true;\n\t\t\t\tresolvePending(value);\n\t\t\t\treturn pending;\n\t\t\t};\n\n\t\t\tdeferred.reject  = deferred.resolver.reject  = function(reason) {\n\t\t\t\tif(resolved) {\n\t\t\t\t\treturn resolve(rejected(reason));\n\t\t\t\t}\n\t\t\t\tresolved = true;\n\t\t\t\trejectPending(reason);\n\t\t\t\treturn pending;\n\t\t\t};\n\n\t\t\tdeferred.notify  = deferred.resolver.notify  = function(update) {\n\t\t\t\tnotifyPending(update);\n\t\t\t\treturn update;\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new promise whose fate is determined by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t */\n\tfunction promise(resolver) {\n\t\treturn _promise(resolver, monitorApi.PromiseStatus && monitorApi.PromiseStatus());\n\t}\n\n\t/**\n\t * Creates a new promise, linked to parent, whose fate is determined\n\t * by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @param {Promise?} status promise from which the new promise is begotten\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t * @private\n\t */\n\tfunction _promise(resolver, status) {\n\t\tvar self, value, handlers = [];\n\n\t\tself = new Promise(then, inspect);\n\n\t\t// Call the provider resolver to seal the promise's fate\n\t\ttry {\n\t\t\tresolver(promiseResolve, promiseReject, promiseNotify);\n\t\t} catch(e) {\n\t\t\tpromiseReject(e);\n\t\t}\n\n\t\t// Return the promise\n\t\treturn self;\n\n\t\t/**\n\t\t * Register handlers for this promise.\n\t\t * @param [onFulfilled] {Function} fulfillment handler\n\t\t * @param [onRejected] {Function} rejection handler\n\t\t * @param [onProgress] {Function} progress handler\n\t\t * @return {Promise} new Promise\n\t\t */\n\t\tfunction then(onFulfilled, onRejected, onProgress) {\n\t\t\tvar next = _promise(function(resolve, reject, notify) {\n\t\t\t\t// if not resolved, push onto handlers, otherwise execute asap\n\t\t\t\t// but not in the current stack\n\t\t\t\thandlers ? handlers.push(run) : enqueue(function() { run(value); });\n\n\t\t\t\tfunction run(p) {\n\t\t\t\t\tp.then(onFulfilled, onRejected, onProgress)\n\t\t\t\t\t\t.then(resolve, reject, notify);\n\t\t\t\t}\n\n\t\t\t}, status && status.observed());\n\n\t\t\treturn next;\n\t\t}\n\n\t\tfunction inspect() {\n\t\t\treturn value ? value.inspect() : toPendingState();\n\t\t}\n\n\t\t/**\n\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t * all listeners of the ultimate fulfillment or rejection\n\t\t * @param {*|Promise} val resolution value\n\t\t */\n\t\tfunction promiseResolve(val) {\n\t\t\tif(!handlers) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvalue = coerce(val);\n\t\t\tscheduleHandlers(handlers, value);\n\t\t\thandlers = undef;\n\n\t\t\tif (status) {\n\t\t\t\tvalue.then(\n\t\t\t\t\tfunction () { status.fulfilled(); },\n\t\t\t\t\tfunction(r) { status.rejected(r); }\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Reject this promise with the supplied reason, which will be used verbatim.\n\t\t * @param {*} reason reason for the rejection\n\t\t */\n\t\tfunction promiseReject(reason) {\n\t\t\tpromiseResolve(rejected(reason));\n\t\t}\n\n\t\t/**\n\t\t * Issue a progress event, notifying all progress listeners\n\t\t * @param {*} update progress event payload to pass to all listeners\n\t\t */\n\t\tfunction promiseNotify(update) {\n\t\t\tif(handlers) {\n\t\t\t\tscheduleHandlers(handlers, progressing(update));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Coerces x to a trusted Promise\n\t *\n\t * @private\n\t * @param {*} x thing to coerce\n\t * @returns {Promise} Guaranteed to return a trusted Promise.  If x\n\t *   is trusted, returns x, otherwise, returns a new, trusted, already-resolved\n\t *   Promise whose resolution value is:\n\t *   * the resolution value of x if it's a foreign promise, or\n\t *   * x if it's a value\n\t */\n\tfunction coerce(x) {\n\t\tif(x instanceof Promise) {\n\t\t\treturn x;\n\t\t}\n\n\t\tif (!(x === Object(x) && 'then' in x)) {\n\t\t\treturn fulfilled(x);\n\t\t}\n\n\t\treturn promise(function(resolve, reject, notify) {\n\t\t\tenqueue(function() {\n\t\t\t\ttry {\n\t\t\t\t\t// We must check and assimilate in the same tick, but not the\n\t\t\t\t\t// current tick, careful only to access promiseOrValue.then once.\n\t\t\t\t\tvar untrustedThen = x.then;\n\n\t\t\t\t\tif(typeof untrustedThen === 'function') {\n\t\t\t\t\t\tfcall(untrustedThen, x, resolve, reject, notify);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// It's a value, create a fulfilled wrapper\n\t\t\t\t\t\tresolve(fulfilled(x));\n\t\t\t\t\t}\n\n\t\t\t\t} catch(e) {\n\t\t\t\t\t// Something went wrong, reject\n\t\t\t\t\treject(e);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Create an already-fulfilled promise for the supplied value\n\t * @private\n\t * @param {*} value\n\t * @return {Promise} fulfilled promise\n\t */\n\tfunction fulfilled(value) {\n\t\tvar self = new Promise(function (onFulfilled) {\n\t\t\ttry {\n\t\t\t\treturn typeof onFulfilled == 'function'\n\t\t\t\t\t? coerce(onFulfilled(value)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn rejected(e);\n\t\t\t}\n\t\t}, function() {\n\t\t\treturn toFulfilledState(value);\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Create an already-rejected promise with the supplied rejection reason.\n\t * @private\n\t * @param {*} reason\n\t * @return {Promise} rejected promise\n\t */\n\tfunction rejected(reason) {\n\t\tvar self = new Promise(function (_, onRejected) {\n\t\t\ttry {\n\t\t\t\treturn typeof onRejected == 'function'\n\t\t\t\t\t? coerce(onRejected(reason)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn rejected(e);\n\t\t\t}\n\t\t}, function() {\n\t\t\treturn toRejectedState(reason);\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Create a progress promise with the supplied update.\n\t * @private\n\t * @param {*} update\n\t * @return {Promise} progress promise\n\t */\n\tfunction progressing(update) {\n\t\tvar self = new Promise(function (_, __, onProgress) {\n\t\t\ttry {\n\t\t\t\treturn typeof onProgress == 'function'\n\t\t\t\t\t? progressing(onProgress(update)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn progressing(e);\n\t\t\t}\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Schedule a task that will process a list of handlers\n\t * in the next queue drain run.\n\t * @private\n\t * @param {Array} handlers queue of handlers to execute\n\t * @param {*} value passed as the only arg to each handler\n\t */\n\tfunction scheduleHandlers(handlers, value) {\n\t\tenqueue(function() {\n\t\t\tvar handler, i = 0;\n\t\t\twhile (handler = handlers[i++]) {\n\t\t\t\thandler(value);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Determines if promiseOrValue is a promise or not\n\t *\n\t * @param {*} promiseOrValue anything\n\t * @returns {boolean} true if promiseOrValue is a {@link Promise}\n\t */\n\tfunction isPromise(promiseOrValue) {\n\t\treturn promiseOrValue && typeof promiseOrValue.then === 'function';\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * howMany of the supplied promisesOrValues have resolved, or will reject when\n\t * it becomes impossible for howMany to resolve, for example, when\n\t * (promisesOrValues.length - howMany) + 1 input promises reject.\n\t *\n\t * @param {Array} promisesOrValues array of anything, may contain a mix\n\t *      of promises and values\n\t * @param howMany {number} number of promisesOrValues to resolve\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise} promise that will resolve to an array of howMany values that\n\t *  resolved first, or will reject with an array of\n\t *  (promisesOrValues.length - howMany) + 1 rejection reasons.\n\t */\n\tfunction some(promisesOrValues, howMany, onFulfilled, onRejected, onProgress) {\n\n\t\treturn when(promisesOrValues, function(promisesOrValues) {\n\n\t\t\treturn promise(resolveSome).then(onFulfilled, onRejected, onProgress);\n\n\t\t\tfunction resolveSome(resolve, reject, notify) {\n\t\t\t\tvar toResolve, toReject, values, reasons, fulfillOne, rejectOne, len, i;\n\n\t\t\t\tlen = promisesOrValues.length >>> 0;\n\n\t\t\t\ttoResolve = Math.max(0, Math.min(howMany, len));\n\t\t\t\tvalues = [];\n\n\t\t\t\ttoReject = (len - toResolve) + 1;\n\t\t\t\treasons = [];\n\n\t\t\t\t// No items in the input, resolve immediately\n\t\t\t\tif (!toResolve) {\n\t\t\t\t\tresolve(values);\n\n\t\t\t\t} else {\n\t\t\t\t\trejectOne = function(reason) {\n\t\t\t\t\t\treasons.push(reason);\n\t\t\t\t\t\tif(!--toReject) {\n\t\t\t\t\t\t\tfulfillOne = rejectOne = identity;\n\t\t\t\t\t\t\treject(reasons);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tfulfillOne = function(val) {\n\t\t\t\t\t\t// This orders the values based on promise resolution order\n\t\t\t\t\t\tvalues.push(val);\n\t\t\t\t\t\tif (!--toResolve) {\n\t\t\t\t\t\t\tfulfillOne = rejectOne = identity;\n\t\t\t\t\t\t\tresolve(values);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tfor(i = 0; i < len; ++i) {\n\t\t\t\t\t\tif(i in promisesOrValues) {\n\t\t\t\t\t\t\twhen(promisesOrValues[i], fulfiller, rejecter, notify);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction rejecter(reason) {\n\t\t\t\t\trejectOne(reason);\n\t\t\t\t}\n\n\t\t\t\tfunction fulfiller(val) {\n\t\t\t\t\tfulfillOne(val);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * any one of the supplied promisesOrValues has resolved or will reject when\n\t * *all* promisesOrValues have rejected.\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise} promise that will resolve to the value that resolved first, or\n\t * will reject with an array of all rejected inputs.\n\t */\n\tfunction any(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\n\t\tfunction unwrapSingleResult(val) {\n\t\t\treturn onFulfilled ? onFulfilled(val[0]) : val[0];\n\t\t}\n\n\t\treturn some(promisesOrValues, 1, unwrapSingleResult, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Return a promise that will resolve only once all the supplied promisesOrValues\n\t * have resolved. The resolution value of the returned promise will be an array\n\t * containing the resolution values of each of the promisesOrValues.\n\t * @memberOf when\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise}\n\t */\n\tfunction all(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\t\treturn _map(promisesOrValues, identity).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Joins multiple promises into a single returned promise.\n\t * @return {Promise} a promise that will fulfill when *all* the input promises\n\t * have fulfilled, or will reject when *any one* of the input promises rejects.\n\t */\n\tfunction join(/* ...promises */) {\n\t\treturn _map(arguments, identity);\n\t}\n\n\t/**\n\t * Settles all input promises such that they are guaranteed not to\n\t * be pending once the returned promise fulfills. The returned promise\n\t * will always fulfill, except in the case where `array` is a promise\n\t * that rejects.\n\t * @param {Array|Promise} array or promise for array of promises to settle\n\t * @returns {Promise} promise that always fulfills with an array of\n\t *  outcome snapshots for each input promise.\n\t */\n\tfunction settle(array) {\n\t\treturn _map(array, toFulfilledState, toRejectedState);\n\t}\n\n\t/**\n\t * Promise-aware array map function, similar to `Array.prototype.map()`,\n\t * but input array may contain promises or values.\n\t * @param {Array|Promise} array array of anything, may contain promises and values\n\t * @param {function} mapFunc map function which may return a promise or value\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction map(array, mapFunc) {\n\t\treturn _map(array, mapFunc);\n\t}\n\n\t/**\n\t * Internal map that allows a fallback to handle rejections\n\t * @param {Array|Promise} array array of anything, may contain promises and values\n\t * @param {function} mapFunc map function which may return a promise or value\n\t * @param {function?} fallback function to handle rejected promises\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction _map(array, mapFunc, fallback) {\n\t\treturn when(array, function(array) {\n\n\t\t\treturn promise(resolveMap);\n\n\t\t\tfunction resolveMap(resolve, reject, notify) {\n\t\t\t\tvar results, len, toResolve, i;\n\n\t\t\t\t// Since we know the resulting length, we can preallocate the results\n\t\t\t\t// array to avoid array expansions.\n\t\t\t\ttoResolve = len = array.length >>> 0;\n\t\t\t\tresults = [];\n\n\t\t\t\tif(!toResolve) {\n\t\t\t\t\tresolve(results);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Since mapFunc may be async, get all invocations of it into flight\n\t\t\t\tfor(i = 0; i < len; i++) {\n\t\t\t\t\tif(i in array) {\n\t\t\t\t\t\tresolveOne(array[i], i);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t--toResolve;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction resolveOne(item, i) {\n\t\t\t\t\twhen(item, mapFunc, fallback).then(function(mapped) {\n\t\t\t\t\t\tresults[i] = mapped;\n\n\t\t\t\t\t\tif(!--toResolve) {\n\t\t\t\t\t\t\tresolve(results);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, reject, notify);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n\t * input may contain promises and/or values, and reduceFunc\n\t * may return either a value or a promise, *and* initialValue may\n\t * be a promise for the starting value.\n\t *\n\t * @param {Array|Promise} promise array or promise for an array of anything,\n\t *      may contain a mix of promises and values.\n\t * @param {function} reduceFunc reduce function reduce(currentValue, nextValue, index, total),\n\t *      where total is the total number of items being reduced, and will be the same\n\t *      in each call to reduceFunc.\n\t * @returns {Promise} that will resolve to the final reduced value\n\t */\n\tfunction reduce(promise, reduceFunc /*, initialValue */) {\n\t\tvar args = fcall(slice, arguments, 1);\n\n\t\treturn when(promise, function(array) {\n\t\t\tvar total;\n\n\t\t\ttotal = array.length;\n\n\t\t\t// Wrap the supplied reduceFunc with one that handles promises and then\n\t\t\t// delegates to the supplied.\n\t\t\targs[0] = function (current, val, i) {\n\t\t\t\treturn when(current, function (c) {\n\t\t\t\t\treturn when(val, function (value) {\n\t\t\t\t\t\treturn reduceFunc(c, value, i, total);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\t\treturn reduceArray.apply(array, args);\n\t\t});\n\t}\n\n\t// Snapshot states\n\n\t/**\n\t * Creates a fulfilled state snapshot\n\t * @private\n\t * @param {*} x any value\n\t * @returns {{state:'fulfilled',value:*}}\n\t */\n\tfunction toFulfilledState(x) {\n\t\treturn { state: 'fulfilled', value: x };\n\t}\n\n\t/**\n\t * Creates a rejected state snapshot\n\t * @private\n\t * @param {*} x any reason\n\t * @returns {{state:'rejected',reason:*}}\n\t */\n\tfunction toRejectedState(x) {\n\t\treturn { state: 'rejected', reason: x };\n\t}\n\n\t/**\n\t * Creates a pending state snapshot\n\t * @private\n\t * @returns {{state:'pending'}}\n\t */\n\tfunction toPendingState() {\n\t\treturn { state: 'pending' };\n\t}\n\n\t//\n\t// Utilities, etc.\n\t//\n\n\tvar reduceArray, slice, fcall, nextTick, handlerQueue,\n\t\tsetTimeout, funcProto, call, arrayProto, monitorApi, undef;\n\n\t//\n\t// Shared handler queue processing\n\t//\n\t// Credit to Twisol (https://github.com/Twisol) for suggesting\n\t// this type of extensible queue + trampoline approach for\n\t// next-tick conflation.\n\n\thandlerQueue = [];\n\n\t/**\n\t * Enqueue a task. If the queue is not currently scheduled to be\n\t * drained, schedule it.\n\t * @param {function} task\n\t */\n\tfunction enqueue(task) {\n\t\tif(handlerQueue.push(task) === 1) {\n\t\t\tnextTick(drainQueue);\n\t\t}\n\t}\n\n\t/**\n\t * Drain the handler queue entirely, being careful to allow the\n\t * queue to be extended while it is being processed, and to continue\n\t * processing until it is truly empty.\n\t */\n\tfunction drainQueue() {\n\t\tvar task, i = 0;\n\n\t\twhile(task = handlerQueue[i++]) {\n\t\t\ttask();\n\t\t}\n\n\t\thandlerQueue = [];\n\t}\n\n\t//\n\t// Capture function and array utils\n\t//\n\t/*global setImmediate,process,vertx*/\n\n\t// Allow attaching the monitor to when() if env has no console\n\tmonitorApi = typeof console != 'undefined' ? console : when;\n\n\t// capture setTimeout to avoid being caught by fake timers used in time based tests\n\tsetTimeout = global.setTimeout;\n\t// Prefer setImmediate, cascade to node, vertx and finally setTimeout\n\tnextTick = typeof setImmediate === 'function' ? setImmediate.bind(global)\n\t\t: typeof process === 'object' && process.nextTick ? process.nextTick\n\t\t: typeof vertx === 'object' ? vertx.runOnLoop // vert.x\n\t\t\t: function(task) { setTimeout(task, 0); }; // fallback\n\n\t// Safe function calls\n\tfuncProto = Function.prototype;\n\tcall = funcProto.call;\n\tfcall = funcProto.bind\n\t\t? call.bind(call)\n\t\t: function(f, context) {\n\t\t\treturn f.apply(context, slice.call(arguments, 2));\n\t\t};\n\n\t// Safe array ops\n\tarrayProto = [];\n\tslice = arrayProto.slice;\n\n\t// ES5 reduce implementation if native not available\n\t// See: http://es5.github.com/#x15.4.4.21 as there are many\n\t// specifics and edge cases.  ES5 dictates that reduce.length === 1\n\t// This implementation deviates from ES5 spec in the following ways:\n\t// 1. It does not check if reduceFunc is a Callable\n\treduceArray = arrayProto.reduce ||\n\t\tfunction(reduceFunc /*, initialValue */) {\n\t\t\t/*jshint maxcomplexity: 7*/\n\t\t\tvar arr, args, reduced, len, i;\n\n\t\t\ti = 0;\n\t\t\tarr = Object(this);\n\t\t\tlen = arr.length >>> 0;\n\t\t\targs = arguments;\n\n\t\t\t// If no initialValue, use first item of array (we know length !== 0 here)\n\t\t\t// and adjust i to start at second item\n\t\t\tif(args.length <= 1) {\n\t\t\t\t// Skip to the first real element in the array\n\t\t\t\tfor(;;) {\n\t\t\t\t\tif(i in arr) {\n\t\t\t\t\t\treduced = arr[i++];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If we reached the end of the array without finding any real\n\t\t\t\t\t// elements, it's a TypeError\n\t\t\t\t\tif(++i >= len) {\n\t\t\t\t\t\tthrow new TypeError();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If initialValue provided, use it\n\t\t\t\treduced = args[1];\n\t\t\t}\n\n\t\t\t// Do the actual reduce\n\t\t\tfor(;i < len; ++i) {\n\t\t\t\tif(i in arr) {\n\t\t\t\t\treduced = reduceFunc(reduced, arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn reduced;\n\t\t};\n\n\tfunction identity(x) {\n\t\treturn x;\n\t}\n\n\treturn when;\n});\n})(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(); },\n\tthis\n);\n","modules":[{"pos":428,"count":19,"factory":true,"id":"when/when"}]}{"absId":"when/when","text":"/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * A lightweight CommonJS Promises/A and when() implementation\n * when is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author Brian Cavalier\n * @author John Hann\n * @version 2.2.1\n */\n(function(define, global) { 'use strict';\ndefine(function () {\n\n\t// Public API\n\n\twhen.promise   = promise;    // Create a pending promise\n\twhen.resolve   = resolve;    // Create a resolved promise\n\twhen.reject    = reject;     // Create a rejected promise\n\twhen.defer     = defer;      // Create a {promise, resolver} pair\n\n\twhen.join      = join;       // Join 2 or more promises\n\n\twhen.all       = all;        // Resolve a list of promises\n\twhen.map       = map;        // Array.map() for promises\n\twhen.reduce    = reduce;     // Array.reduce() for promises\n\twhen.settle    = settle;     // Settle a list of promises\n\n\twhen.any       = any;        // One-winner race\n\twhen.some      = some;       // Multi-winner race\n\n\twhen.isPromise = isPromise;  // Determine if a thing is a promise\n\n\n\t/**\n\t * Register an observer for a promise or immediate value.\n\t *\n\t * @param {*} promiseOrValue\n\t * @param {function?} [onFulfilled] callback to be called when promiseOrValue is\n\t *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n\t *   will be invoked immediately.\n\t * @param {function?} [onRejected] callback to be called when promiseOrValue is\n\t *   rejected.\n\t * @param {function?} [onProgress] callback to be called when progress updates\n\t *   are issued for promiseOrValue.\n\t * @returns {Promise} a new {@link Promise} that will complete with the return\n\t *   value of callback or errback or the completion value of promiseOrValue if\n\t *   callback and/or errback is not supplied.\n\t */\n\tfunction when(promiseOrValue, onFulfilled, onRejected, onProgress) {\n\t\t// Get a trusted promise for the input promiseOrValue, and then\n\t\t// register promise handlers\n\t\treturn resolve(promiseOrValue).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Trusted Promise constructor.  A Promise created from this constructor is\n\t * a trusted when.js promise.  Any other duck-typed promise is considered\n\t * untrusted.\n\t * @constructor\n\t * @name Promise\n\t */\n\tfunction Promise(then, inspect) {\n\t\tthis.then = then;\n\t\tthis.inspect = inspect;\n\t}\n\n\tPromise.prototype = {\n\t\t/**\n\t\t * Register a rejection handler.  Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @return {Promise}\n\t\t */\n\t\totherwise: function(onRejected) {\n\t\t\treturn this.then(undef, onRejected);\n\t\t},\n\n\t\t/**\n\t\t * Ensures that onFulfilledOrRejected will be called regardless of whether\n\t\t * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT\n\t\t * receive the promises' value or reason.  Any returned value will be disregarded.\n\t\t * onFulfilledOrRejected may throw or return a rejected promise to signal\n\t\t * an additional error.\n\t\t * @param {function} onFulfilledOrRejected handler to be called regardless of\n\t\t *  fulfillment or rejection\n\t\t * @returns {Promise}\n\t\t */\n\t\tensure: function(onFulfilledOrRejected) {\n\t\t\treturn this.then(injectHandler, injectHandler)['yield'](this);\n\n\t\t\tfunction injectHandler() {\n\t\t\t\treturn resolve(onFulfilledOrRejected());\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Shortcut for .then(function() { return value; })\n\t\t * @param  {*} value\n\t\t * @return {Promise} a promise that:\n\t\t *  - is fulfilled if value is not a promise, or\n\t\t *  - if value is a promise, will fulfill with its value, or reject\n\t\t *    with its reason.\n\t\t */\n\t\t'yield': function(value) {\n\t\t\treturn this.then(function() {\n\t\t\t\treturn value;\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Assumes that this promise will fulfill with an array, and arranges\n\t\t * for the onFulfilled to be called with the array as its argument list\n\t\t * i.e. onFulfilled.apply(undefined, array).\n\t\t * @param {function} onFulfilled function to receive spread arguments\n\t\t * @return {Promise}\n\t\t */\n\t\tspread: function(onFulfilled) {\n\t\t\treturn this.then(function(array) {\n\t\t\t\t// array may contain promises, so resolve its contents.\n\t\t\t\treturn all(array, function(array) {\n\t\t\t\t\treturn onFulfilled.apply(undef, array);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Shortcut for .then(onFulfilledOrRejected, onFulfilledOrRejected)\n\t\t * @deprecated\n\t\t */\n\t\talways: function(onFulfilledOrRejected, onProgress) {\n\t\t\treturn this.then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress);\n\t\t}\n\t};\n\n\t/**\n\t * Returns a resolved promise. The returned promise will be\n\t *  - fulfilled with promiseOrValue if it is a value, or\n\t *  - if promiseOrValue is a promise\n\t *    - fulfilled with promiseOrValue's value after it is fulfilled\n\t *    - rejected with promiseOrValue's reason after it is rejected\n\t * @param  {*} value\n\t * @return {Promise}\n\t */\n\tfunction resolve(value) {\n\t\treturn promise(function(resolve) {\n\t\t\tresolve(value);\n\t\t});\n\t}\n\n\t/**\n\t * Returns a rejected promise for the supplied promiseOrValue.  The returned\n\t * promise will be rejected with:\n\t * - promiseOrValue, if it is a value, or\n\t * - if promiseOrValue is a promise\n\t *   - promiseOrValue's value after it is fulfilled\n\t *   - promiseOrValue's reason after it is rejected\n\t * @param {*} promiseOrValue the rejected value of the returned {@link Promise}\n\t * @return {Promise} rejected {@link Promise}\n\t */\n\tfunction reject(promiseOrValue) {\n\t\treturn when(promiseOrValue, rejected);\n\t}\n\n\t/**\n\t * Creates a {promise, resolver} pair, either or both of which\n\t * may be given out safely to consumers.\n\t * The resolver has resolve, reject, and progress.  The promise\n\t * has then plus extended promise API.\n\t *\n\t * @return {{\n\t * promise: Promise,\n\t * resolve: function:Promise,\n\t * reject: function:Promise,\n\t * notify: function:Promise\n\t * resolver: {\n\t *\tresolve: function:Promise,\n\t *\treject: function:Promise,\n\t *\tnotify: function:Promise\n\t * }}}\n\t */\n\tfunction defer() {\n\t\tvar deferred, pending, resolved;\n\n\t\t// Optimize object shape\n\t\tdeferred = {\n\t\t\tpromise: undef, resolve: undef, reject: undef, notify: undef,\n\t\t\tresolver: { resolve: undef, reject: undef, notify: undef }\n\t\t};\n\n\t\tdeferred.promise = pending = promise(makeDeferred);\n\n\t\treturn deferred;\n\n\t\tfunction makeDeferred(resolvePending, rejectPending, notifyPending) {\n\t\t\tdeferred.resolve = deferred.resolver.resolve = function(value) {\n\t\t\t\tif(resolved) {\n\t\t\t\t\treturn resolve(value);\n\t\t\t\t}\n\t\t\t\tresolved = true;\n\t\t\t\tresolvePending(value);\n\t\t\t\treturn pending;\n\t\t\t};\n\n\t\t\tdeferred.reject  = deferred.resolver.reject  = function(reason) {\n\t\t\t\tif(resolved) {\n\t\t\t\t\treturn resolve(rejected(reason));\n\t\t\t\t}\n\t\t\t\tresolved = true;\n\t\t\t\trejectPending(reason);\n\t\t\t\treturn pending;\n\t\t\t};\n\n\t\t\tdeferred.notify  = deferred.resolver.notify  = function(update) {\n\t\t\t\tnotifyPending(update);\n\t\t\t\treturn update;\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new promise whose fate is determined by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t */\n\tfunction promise(resolver) {\n\t\treturn _promise(resolver, monitorApi.PromiseStatus && monitorApi.PromiseStatus());\n\t}\n\n\t/**\n\t * Creates a new promise, linked to parent, whose fate is determined\n\t * by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @param {Promise?} status promise from which the new promise is begotten\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t * @private\n\t */\n\tfunction _promise(resolver, status) {\n\t\tvar self, value, handlers = [];\n\n\t\tself = new Promise(then, inspect);\n\n\t\t// Call the provider resolver to seal the promise's fate\n\t\ttry {\n\t\t\tresolver(promiseResolve, promiseReject, promiseNotify);\n\t\t} catch(e) {\n\t\t\tpromiseReject(e);\n\t\t}\n\n\t\t// Return the promise\n\t\treturn self;\n\n\t\t/**\n\t\t * Register handlers for this promise.\n\t\t * @param [onFulfilled] {Function} fulfillment handler\n\t\t * @param [onRejected] {Function} rejection handler\n\t\t * @param [onProgress] {Function} progress handler\n\t\t * @return {Promise} new Promise\n\t\t */\n\t\tfunction then(onFulfilled, onRejected, onProgress) {\n\t\t\tvar next = _promise(function(resolve, reject, notify) {\n\t\t\t\t// if not resolved, push onto handlers, otherwise execute asap\n\t\t\t\t// but not in the current stack\n\t\t\t\thandlers ? handlers.push(run) : enqueue(function() { run(value); });\n\n\t\t\t\tfunction run(p) {\n\t\t\t\t\tp.then(onFulfilled, onRejected, onProgress)\n\t\t\t\t\t\t.then(resolve, reject, notify);\n\t\t\t\t}\n\n\t\t\t}, status && status.observed());\n\n\t\t\treturn next;\n\t\t}\n\n\t\tfunction inspect() {\n\t\t\treturn value ? value.inspect() : toPendingState();\n\t\t}\n\n\t\t/**\n\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t * all listeners of the ultimate fulfillment or rejection\n\t\t * @param {*|Promise} val resolution value\n\t\t */\n\t\tfunction promiseResolve(val) {\n\t\t\tif(!handlers) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvalue = coerce(val);\n\t\t\tscheduleHandlers(handlers, value);\n\t\t\thandlers = undef;\n\n\t\t\tif (status) {\n\t\t\t\tvalue.then(\n\t\t\t\t\tfunction () { status.fulfilled(); },\n\t\t\t\t\tfunction(r) { status.rejected(r); }\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Reject this promise with the supplied reason, which will be used verbatim.\n\t\t * @param {*} reason reason for the rejection\n\t\t */\n\t\tfunction promiseReject(reason) {\n\t\t\tpromiseResolve(rejected(reason));\n\t\t}\n\n\t\t/**\n\t\t * Issue a progress event, notifying all progress listeners\n\t\t * @param {*} update progress event payload to pass to all listeners\n\t\t */\n\t\tfunction promiseNotify(update) {\n\t\t\tif(handlers) {\n\t\t\t\tscheduleHandlers(handlers, progressing(update));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Coerces x to a trusted Promise\n\t *\n\t * @private\n\t * @param {*} x thing to coerce\n\t * @returns {Promise} Guaranteed to return a trusted Promise.  If x\n\t *   is trusted, returns x, otherwise, returns a new, trusted, already-resolved\n\t *   Promise whose resolution value is:\n\t *   * the resolution value of x if it's a foreign promise, or\n\t *   * x if it's a value\n\t */\n\tfunction coerce(x) {\n\t\tif(x instanceof Promise) {\n\t\t\treturn x;\n\t\t}\n\n\t\tif (!(x === Object(x) && 'then' in x)) {\n\t\t\treturn fulfilled(x);\n\t\t}\n\n\t\treturn promise(function(resolve, reject, notify) {\n\t\t\tenqueue(function() {\n\t\t\t\ttry {\n\t\t\t\t\t// We must check and assimilate in the same tick, but not the\n\t\t\t\t\t// current tick, careful only to access promiseOrValue.then once.\n\t\t\t\t\tvar untrustedThen = x.then;\n\n\t\t\t\t\tif(typeof untrustedThen === 'function') {\n\t\t\t\t\t\tfcall(untrustedThen, x, resolve, reject, notify);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// It's a value, create a fulfilled wrapper\n\t\t\t\t\t\tresolve(fulfilled(x));\n\t\t\t\t\t}\n\n\t\t\t\t} catch(e) {\n\t\t\t\t\t// Something went wrong, reject\n\t\t\t\t\treject(e);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Create an already-fulfilled promise for the supplied value\n\t * @private\n\t * @param {*} value\n\t * @return {Promise} fulfilled promise\n\t */\n\tfunction fulfilled(value) {\n\t\tvar self = new Promise(function (onFulfilled) {\n\t\t\ttry {\n\t\t\t\treturn typeof onFulfilled == 'function'\n\t\t\t\t\t? coerce(onFulfilled(value)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn rejected(e);\n\t\t\t}\n\t\t}, function() {\n\t\t\treturn toFulfilledState(value);\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Create an already-rejected promise with the supplied rejection reason.\n\t * @private\n\t * @param {*} reason\n\t * @return {Promise} rejected promise\n\t */\n\tfunction rejected(reason) {\n\t\tvar self = new Promise(function (_, onRejected) {\n\t\t\ttry {\n\t\t\t\treturn typeof onRejected == 'function'\n\t\t\t\t\t? coerce(onRejected(reason)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn rejected(e);\n\t\t\t}\n\t\t}, function() {\n\t\t\treturn toRejectedState(reason);\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Create a progress promise with the supplied update.\n\t * @private\n\t * @param {*} update\n\t * @return {Promise} progress promise\n\t */\n\tfunction progressing(update) {\n\t\tvar self = new Promise(function (_, __, onProgress) {\n\t\t\ttry {\n\t\t\t\treturn typeof onProgress == 'function'\n\t\t\t\t\t? progressing(onProgress(update)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn progressing(e);\n\t\t\t}\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Schedule a task that will process a list of handlers\n\t * in the next queue drain run.\n\t * @private\n\t * @param {Array} handlers queue of handlers to execute\n\t * @param {*} value passed as the only arg to each handler\n\t */\n\tfunction scheduleHandlers(handlers, value) {\n\t\tenqueue(function() {\n\t\t\tvar handler, i = 0;\n\t\t\twhile (handler = handlers[i++]) {\n\t\t\t\thandler(value);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Determines if promiseOrValue is a promise or not\n\t *\n\t * @param {*} promiseOrValue anything\n\t * @returns {boolean} true if promiseOrValue is a {@link Promise}\n\t */\n\tfunction isPromise(promiseOrValue) {\n\t\treturn promiseOrValue && typeof promiseOrValue.then === 'function';\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * howMany of the supplied promisesOrValues have resolved, or will reject when\n\t * it becomes impossible for howMany to resolve, for example, when\n\t * (promisesOrValues.length - howMany) + 1 input promises reject.\n\t *\n\t * @param {Array} promisesOrValues array of anything, may contain a mix\n\t *      of promises and values\n\t * @param howMany {number} number of promisesOrValues to resolve\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise} promise that will resolve to an array of howMany values that\n\t *  resolved first, or will reject with an array of\n\t *  (promisesOrValues.length - howMany) + 1 rejection reasons.\n\t */\n\tfunction some(promisesOrValues, howMany, onFulfilled, onRejected, onProgress) {\n\n\t\treturn when(promisesOrValues, function(promisesOrValues) {\n\n\t\t\treturn promise(resolveSome).then(onFulfilled, onRejected, onProgress);\n\n\t\t\tfunction resolveSome(resolve, reject, notify) {\n\t\t\t\tvar toResolve, toReject, values, reasons, fulfillOne, rejectOne, len, i;\n\n\t\t\t\tlen = promisesOrValues.length >>> 0;\n\n\t\t\t\ttoResolve = Math.max(0, Math.min(howMany, len));\n\t\t\t\tvalues = [];\n\n\t\t\t\ttoReject = (len - toResolve) + 1;\n\t\t\t\treasons = [];\n\n\t\t\t\t// No items in the input, resolve immediately\n\t\t\t\tif (!toResolve) {\n\t\t\t\t\tresolve(values);\n\n\t\t\t\t} else {\n\t\t\t\t\trejectOne = function(reason) {\n\t\t\t\t\t\treasons.push(reason);\n\t\t\t\t\t\tif(!--toReject) {\n\t\t\t\t\t\t\tfulfillOne = rejectOne = identity;\n\t\t\t\t\t\t\treject(reasons);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tfulfillOne = function(val) {\n\t\t\t\t\t\t// This orders the values based on promise resolution order\n\t\t\t\t\t\tvalues.push(val);\n\t\t\t\t\t\tif (!--toResolve) {\n\t\t\t\t\t\t\tfulfillOne = rejectOne = identity;\n\t\t\t\t\t\t\tresolve(values);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tfor(i = 0; i < len; ++i) {\n\t\t\t\t\t\tif(i in promisesOrValues) {\n\t\t\t\t\t\t\twhen(promisesOrValues[i], fulfiller, rejecter, notify);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction rejecter(reason) {\n\t\t\t\t\trejectOne(reason);\n\t\t\t\t}\n\n\t\t\t\tfunction fulfiller(val) {\n\t\t\t\t\tfulfillOne(val);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * any one of the supplied promisesOrValues has resolved or will reject when\n\t * *all* promisesOrValues have rejected.\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise} promise that will resolve to the value that resolved first, or\n\t * will reject with an array of all rejected inputs.\n\t */\n\tfunction any(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\n\t\tfunction unwrapSingleResult(val) {\n\t\t\treturn onFulfilled ? onFulfilled(val[0]) : val[0];\n\t\t}\n\n\t\treturn some(promisesOrValues, 1, unwrapSingleResult, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Return a promise that will resolve only once all the supplied promisesOrValues\n\t * have resolved. The resolution value of the returned promise will be an array\n\t * containing the resolution values of each of the promisesOrValues.\n\t * @memberOf when\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise}\n\t */\n\tfunction all(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\t\treturn _map(promisesOrValues, identity).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Joins multiple promises into a single returned promise.\n\t * @return {Promise} a promise that will fulfill when *all* the input promises\n\t * have fulfilled, or will reject when *any one* of the input promises rejects.\n\t */\n\tfunction join(/* ...promises */) {\n\t\treturn _map(arguments, identity);\n\t}\n\n\t/**\n\t * Settles all input promises such that they are guaranteed not to\n\t * be pending once the returned promise fulfills. The returned promise\n\t * will always fulfill, except in the case where `array` is a promise\n\t * that rejects.\n\t * @param {Array|Promise} array or promise for array of promises to settle\n\t * @returns {Promise} promise that always fulfills with an array of\n\t *  outcome snapshots for each input promise.\n\t */\n\tfunction settle(array) {\n\t\treturn _map(array, toFulfilledState, toRejectedState);\n\t}\n\n\t/**\n\t * Promise-aware array map function, similar to `Array.prototype.map()`,\n\t * but input array may contain promises or values.\n\t * @param {Array|Promise} array array of anything, may contain promises and values\n\t * @param {function} mapFunc map function which may return a promise or value\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction map(array, mapFunc) {\n\t\treturn _map(array, mapFunc);\n\t}\n\n\t/**\n\t * Internal map that allows a fallback to handle rejections\n\t * @param {Array|Promise} array array of anything, may contain promises and values\n\t * @param {function} mapFunc map function which may return a promise or value\n\t * @param {function?} fallback function to handle rejected promises\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction _map(array, mapFunc, fallback) {\n\t\treturn when(array, function(array) {\n\n\t\t\treturn promise(resolveMap);\n\n\t\t\tfunction resolveMap(resolve, reject, notify) {\n\t\t\t\tvar results, len, toResolve, i;\n\n\t\t\t\t// Since we know the resulting length, we can preallocate the results\n\t\t\t\t// array to avoid array expansions.\n\t\t\t\ttoResolve = len = array.length >>> 0;\n\t\t\t\tresults = [];\n\n\t\t\t\tif(!toResolve) {\n\t\t\t\t\tresolve(results);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Since mapFunc may be async, get all invocations of it into flight\n\t\t\t\tfor(i = 0; i < len; i++) {\n\t\t\t\t\tif(i in array) {\n\t\t\t\t\t\tresolveOne(array[i], i);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t--toResolve;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction resolveOne(item, i) {\n\t\t\t\t\twhen(item, mapFunc, fallback).then(function(mapped) {\n\t\t\t\t\t\tresults[i] = mapped;\n\n\t\t\t\t\t\tif(!--toResolve) {\n\t\t\t\t\t\t\tresolve(results);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, reject, notify);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n\t * input may contain promises and/or values, and reduceFunc\n\t * may return either a value or a promise, *and* initialValue may\n\t * be a promise for the starting value.\n\t *\n\t * @param {Array|Promise} promise array or promise for an array of anything,\n\t *      may contain a mix of promises and values.\n\t * @param {function} reduceFunc reduce function reduce(currentValue, nextValue, index, total),\n\t *      where total is the total number of items being reduced, and will be the same\n\t *      in each call to reduceFunc.\n\t * @returns {Promise} that will resolve to the final reduced value\n\t */\n\tfunction reduce(promise, reduceFunc /*, initialValue */) {\n\t\tvar args = fcall(slice, arguments, 1);\n\n\t\treturn when(promise, function(array) {\n\t\t\tvar total;\n\n\t\t\ttotal = array.length;\n\n\t\t\t// Wrap the supplied reduceFunc with one that handles promises and then\n\t\t\t// delegates to the supplied.\n\t\t\targs[0] = function (current, val, i) {\n\t\t\t\treturn when(current, function (c) {\n\t\t\t\t\treturn when(val, function (value) {\n\t\t\t\t\t\treturn reduceFunc(c, value, i, total);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\t\treturn reduceArray.apply(array, args);\n\t\t});\n\t}\n\n\t// Snapshot states\n\n\t/**\n\t * Creates a fulfilled state snapshot\n\t * @private\n\t * @param {*} x any value\n\t * @returns {{state:'fulfilled',value:*}}\n\t */\n\tfunction toFulfilledState(x) {\n\t\treturn { state: 'fulfilled', value: x };\n\t}\n\n\t/**\n\t * Creates a rejected state snapshot\n\t * @private\n\t * @param {*} x any reason\n\t * @returns {{state:'rejected',reason:*}}\n\t */\n\tfunction toRejectedState(x) {\n\t\treturn { state: 'rejected', reason: x };\n\t}\n\n\t/**\n\t * Creates a pending state snapshot\n\t * @private\n\t * @returns {{state:'pending'}}\n\t */\n\tfunction toPendingState() {\n\t\treturn { state: 'pending' };\n\t}\n\n\t//\n\t// Utilities, etc.\n\t//\n\n\tvar reduceArray, slice, fcall, nextTick, handlerQueue,\n\t\tsetTimeout, funcProto, call, arrayProto, monitorApi, undef;\n\n\t//\n\t// Shared handler queue processing\n\t//\n\t// Credit to Twisol (https://github.com/Twisol) for suggesting\n\t// this type of extensible queue + trampoline approach for\n\t// next-tick conflation.\n\n\thandlerQueue = [];\n\n\t/**\n\t * Enqueue a task. If the queue is not currently scheduled to be\n\t * drained, schedule it.\n\t * @param {function} task\n\t */\n\tfunction enqueue(task) {\n\t\tif(handlerQueue.push(task) === 1) {\n\t\t\tnextTick(drainQueue);\n\t\t}\n\t}\n\n\t/**\n\t * Drain the handler queue entirely, being careful to allow the\n\t * queue to be extended while it is being processed, and to continue\n\t * processing until it is truly empty.\n\t */\n\tfunction drainQueue() {\n\t\tvar task, i = 0;\n\n\t\twhile(task = handlerQueue[i++]) {\n\t\t\ttask();\n\t\t}\n\n\t\thandlerQueue = [];\n\t}\n\n\t//\n\t// Capture function and array utils\n\t//\n\t/*global setImmediate,process,vertx*/\n\n\t// Allow attaching the monitor to when() if env has no console\n\tmonitorApi = typeof console != 'undefined' ? console : when;\n\n\t// capture setTimeout to avoid being caught by fake timers used in time based tests\n\tsetTimeout = global.setTimeout;\n\t// Prefer setImmediate, cascade to node, vertx and finally setTimeout\n\tnextTick = typeof setImmediate === 'function' ? setImmediate.bind(global)\n\t\t: typeof process === 'object' && process.nextTick ? process.nextTick\n\t\t: typeof vertx === 'object' ? vertx.runOnLoop // vert.x\n\t\t\t: function(task) { setTimeout(task, 0); }; // fallback\n\n\t// Safe function calls\n\tfuncProto = Function.prototype;\n\tcall = funcProto.call;\n\tfcall = funcProto.bind\n\t\t? call.bind(call)\n\t\t: function(f, context) {\n\t\t\treturn f.apply(context, slice.call(arguments, 2));\n\t\t};\n\n\t// Safe array ops\n\tarrayProto = [];\n\tslice = arrayProto.slice;\n\n\t// ES5 reduce implementation if native not available\n\t// See: http://es5.github.com/#x15.4.4.21 as there are many\n\t// specifics and edge cases.  ES5 dictates that reduce.length === 1\n\t// This implementation deviates from ES5 spec in the following ways:\n\t// 1. It does not check if reduceFunc is a Callable\n\treduceArray = arrayProto.reduce ||\n\t\tfunction(reduceFunc /*, initialValue */) {\n\t\t\t/*jshint maxcomplexity: 7*/\n\t\t\tvar arr, args, reduced, len, i;\n\n\t\t\ti = 0;\n\t\t\tarr = Object(this);\n\t\t\tlen = arr.length >>> 0;\n\t\t\targs = arguments;\n\n\t\t\t// If no initialValue, use first item of array (we know length !== 0 here)\n\t\t\t// and adjust i to start at second item\n\t\t\tif(args.length <= 1) {\n\t\t\t\t// Skip to the first real element in the array\n\t\t\t\tfor(;;) {\n\t\t\t\t\tif(i in arr) {\n\t\t\t\t\t\treduced = arr[i++];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If we reached the end of the array without finding any real\n\t\t\t\t\t// elements, it's a TypeError\n\t\t\t\t\tif(++i >= len) {\n\t\t\t\t\t\tthrow new TypeError();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If initialValue provided, use it\n\t\t\t\treduced = args[1];\n\t\t\t}\n\n\t\t\t// Do the actual reduce\n\t\t\tfor(;i < len; ++i) {\n\t\t\t\tif(i in arr) {\n\t\t\t\t\treduced = reduceFunc(reduced, arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn reduced;\n\t\t};\n\n\tfunction identity(x) {\n\t\treturn x;\n\t}\n\n\treturn when;\n});\n})(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(); },\n\tthis\n);\n","modules":[{"pos":428,"count":19,"factory":true,"id":"when/when"}]}{"absId":"when/when","text":"/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * A lightweight CommonJS Promises/A and when() implementation\n * when is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author Brian Cavalier\n * @author John Hann\n * @version 2.2.1\n */\n(function(define, global) { 'use strict';\ndefine(function () {\n\n\t// Public API\n\n\twhen.promise   = promise;    // Create a pending promise\n\twhen.resolve   = resolve;    // Create a resolved promise\n\twhen.reject    = reject;     // Create a rejected promise\n\twhen.defer     = defer;      // Create a {promise, resolver} pair\n\n\twhen.join      = join;       // Join 2 or more promises\n\n\twhen.all       = all;        // Resolve a list of promises\n\twhen.map       = map;        // Array.map() for promises\n\twhen.reduce    = reduce;     // Array.reduce() for promises\n\twhen.settle    = settle;     // Settle a list of promises\n\n\twhen.any       = any;        // One-winner race\n\twhen.some      = some;       // Multi-winner race\n\n\twhen.isPromise = isPromise;  // Determine if a thing is a promise\n\n\n\t/**\n\t * Register an observer for a promise or immediate value.\n\t *\n\t * @param {*} promiseOrValue\n\t * @param {function?} [onFulfilled] callback to be called when promiseOrValue is\n\t *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n\t *   will be invoked immediately.\n\t * @param {function?} [onRejected] callback to be called when promiseOrValue is\n\t *   rejected.\n\t * @param {function?} [onProgress] callback to be called when progress updates\n\t *   are issued for promiseOrValue.\n\t * @returns {Promise} a new {@link Promise} that will complete with the return\n\t *   value of callback or errback or the completion value of promiseOrValue if\n\t *   callback and/or errback is not supplied.\n\t */\n\tfunction when(promiseOrValue, onFulfilled, onRejected, onProgress) {\n\t\t// Get a trusted promise for the input promiseOrValue, and then\n\t\t// register promise handlers\n\t\treturn resolve(promiseOrValue).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Trusted Promise constructor.  A Promise created from this constructor is\n\t * a trusted when.js promise.  Any other duck-typed promise is considered\n\t * untrusted.\n\t * @constructor\n\t * @name Promise\n\t */\n\tfunction Promise(then, inspect) {\n\t\tthis.then = then;\n\t\tthis.inspect = inspect;\n\t}\n\n\tPromise.prototype = {\n\t\t/**\n\t\t * Register a rejection handler.  Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @return {Promise}\n\t\t */\n\t\totherwise: function(onRejected) {\n\t\t\treturn this.then(undef, onRejected);\n\t\t},\n\n\t\t/**\n\t\t * Ensures that onFulfilledOrRejected will be called regardless of whether\n\t\t * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT\n\t\t * receive the promises' value or reason.  Any returned value will be disregarded.\n\t\t * onFulfilledOrRejected may throw or return a rejected promise to signal\n\t\t * an additional error.\n\t\t * @param {function} onFulfilledOrRejected handler to be called regardless of\n\t\t *  fulfillment or rejection\n\t\t * @returns {Promise}\n\t\t */\n\t\tensure: function(onFulfilledOrRejected) {\n\t\t\treturn this.then(injectHandler, injectHandler)['yield'](this);\n\n\t\t\tfunction injectHandler() {\n\t\t\t\treturn resolve(onFulfilledOrRejected());\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Shortcut for .then(function() { return value; })\n\t\t * @param  {*} value\n\t\t * @return {Promise} a promise that:\n\t\t *  - is fulfilled if value is not a promise, or\n\t\t *  - if value is a promise, will fulfill with its value, or reject\n\t\t *    with its reason.\n\t\t */\n\t\t'yield': function(value) {\n\t\t\treturn this.then(function() {\n\t\t\t\treturn value;\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Assumes that this promise will fulfill with an array, and arranges\n\t\t * for the onFulfilled to be called with the array as its argument list\n\t\t * i.e. onFulfilled.apply(undefined, array).\n\t\t * @param {function} onFulfilled function to receive spread arguments\n\t\t * @return {Promise}\n\t\t */\n\t\tspread: function(onFulfilled) {\n\t\t\treturn this.then(function(array) {\n\t\t\t\t// array may contain promises, so resolve its contents.\n\t\t\t\treturn all(array, function(array) {\n\t\t\t\t\treturn onFulfilled.apply(undef, array);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Shortcut for .then(onFulfilledOrRejected, onFulfilledOrRejected)\n\t\t * @deprecated\n\t\t */\n\t\talways: function(onFulfilledOrRejected, onProgress) {\n\t\t\treturn this.then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress);\n\t\t}\n\t};\n\n\t/**\n\t * Returns a resolved promise. The returned promise will be\n\t *  - fulfilled with promiseOrValue if it is a value, or\n\t *  - if promiseOrValue is a promise\n\t *    - fulfilled with promiseOrValue's value after it is fulfilled\n\t *    - rejected with promiseOrValue's reason after it is rejected\n\t * @param  {*} value\n\t * @return {Promise}\n\t */\n\tfunction resolve(value) {\n\t\treturn promise(function(resolve) {\n\t\t\tresolve(value);\n\t\t});\n\t}\n\n\t/**\n\t * Returns a rejected promise for the supplied promiseOrValue.  The returned\n\t * promise will be rejected with:\n\t * - promiseOrValue, if it is a value, or\n\t * - if promiseOrValue is a promise\n\t *   - promiseOrValue's value after it is fulfilled\n\t *   - promiseOrValue's reason after it is rejected\n\t * @param {*} promiseOrValue the rejected value of the returned {@link Promise}\n\t * @return {Promise} rejected {@link Promise}\n\t */\n\tfunction reject(promiseOrValue) {\n\t\treturn when(promiseOrValue, rejected);\n\t}\n\n\t/**\n\t * Creates a {promise, resolver} pair, either or both of which\n\t * may be given out safely to consumers.\n\t * The resolver has resolve, reject, and progress.  The promise\n\t * has then plus extended promise API.\n\t *\n\t * @return {{\n\t * promise: Promise,\n\t * resolve: function:Promise,\n\t * reject: function:Promise,\n\t * notify: function:Promise\n\t * resolver: {\n\t *\tresolve: function:Promise,\n\t *\treject: function:Promise,\n\t *\tnotify: function:Promise\n\t * }}}\n\t */\n\tfunction defer() {\n\t\tvar deferred, pending, resolved;\n\n\t\t// Optimize object shape\n\t\tdeferred = {\n\t\t\tpromise: undef, resolve: undef, reject: undef, notify: undef,\n\t\t\tresolver: { resolve: undef, reject: undef, notify: undef }\n\t\t};\n\n\t\tdeferred.promise = pending = promise(makeDeferred);\n\n\t\treturn deferred;\n\n\t\tfunction makeDeferred(resolvePending, rejectPending, notifyPending) {\n\t\t\tdeferred.resolve = deferred.resolver.resolve = function(value) {\n\t\t\t\tif(resolved) {\n\t\t\t\t\treturn resolve(value);\n\t\t\t\t}\n\t\t\t\tresolved = true;\n\t\t\t\tresolvePending(value);\n\t\t\t\treturn pending;\n\t\t\t};\n\n\t\t\tdeferred.reject  = deferred.resolver.reject  = function(reason) {\n\t\t\t\tif(resolved) {\n\t\t\t\t\treturn resolve(rejected(reason));\n\t\t\t\t}\n\t\t\t\tresolved = true;\n\t\t\t\trejectPending(reason);\n\t\t\t\treturn pending;\n\t\t\t};\n\n\t\t\tdeferred.notify  = deferred.resolver.notify  = function(update) {\n\t\t\t\tnotifyPending(update);\n\t\t\t\treturn update;\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new promise whose fate is determined by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t */\n\tfunction promise(resolver) {\n\t\treturn _promise(resolver, monitorApi.PromiseStatus && monitorApi.PromiseStatus());\n\t}\n\n\t/**\n\t * Creates a new promise, linked to parent, whose fate is determined\n\t * by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @param {Promise?} status promise from which the new promise is begotten\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t * @private\n\t */\n\tfunction _promise(resolver, status) {\n\t\tvar self, value, handlers = [];\n\n\t\tself = new Promise(then, inspect);\n\n\t\t// Call the provider resolver to seal the promise's fate\n\t\ttry {\n\t\t\tresolver(promiseResolve, promiseReject, promiseNotify);\n\t\t} catch(e) {\n\t\t\tpromiseReject(e);\n\t\t}\n\n\t\t// Return the promise\n\t\treturn self;\n\n\t\t/**\n\t\t * Register handlers for this promise.\n\t\t * @param [onFulfilled] {Function} fulfillment handler\n\t\t * @param [onRejected] {Function} rejection handler\n\t\t * @param [onProgress] {Function} progress handler\n\t\t * @return {Promise} new Promise\n\t\t */\n\t\tfunction then(onFulfilled, onRejected, onProgress) {\n\t\t\tvar next = _promise(function(resolve, reject, notify) {\n\t\t\t\t// if not resolved, push onto handlers, otherwise execute asap\n\t\t\t\t// but not in the current stack\n\t\t\t\thandlers ? handlers.push(run) : enqueue(function() { run(value); });\n\n\t\t\t\tfunction run(p) {\n\t\t\t\t\tp.then(onFulfilled, onRejected, onProgress)\n\t\t\t\t\t\t.then(resolve, reject, notify);\n\t\t\t\t}\n\n\t\t\t}, status && status.observed());\n\n\t\t\treturn next;\n\t\t}\n\n\t\tfunction inspect() {\n\t\t\treturn value ? value.inspect() : toPendingState();\n\t\t}\n\n\t\t/**\n\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t * all listeners of the ultimate fulfillment or rejection\n\t\t * @param {*|Promise} val resolution value\n\t\t */\n\t\tfunction promiseResolve(val) {\n\t\t\tif(!handlers) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvalue = coerce(val);\n\t\t\tscheduleHandlers(handlers, value);\n\t\t\thandlers = undef;\n\n\t\t\tif (status) {\n\t\t\t\tvalue.then(\n\t\t\t\t\tfunction () { status.fulfilled(); },\n\t\t\t\t\tfunction(r) { status.rejected(r); }\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Reject this promise with the supplied reason, which will be used verbatim.\n\t\t * @param {*} reason reason for the rejection\n\t\t */\n\t\tfunction promiseReject(reason) {\n\t\t\tpromiseResolve(rejected(reason));\n\t\t}\n\n\t\t/**\n\t\t * Issue a progress event, notifying all progress listeners\n\t\t * @param {*} update progress event payload to pass to all listeners\n\t\t */\n\t\tfunction promiseNotify(update) {\n\t\t\tif(handlers) {\n\t\t\t\tscheduleHandlers(handlers, progressing(update));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Coerces x to a trusted Promise\n\t *\n\t * @private\n\t * @param {*} x thing to coerce\n\t * @returns {Promise} Guaranteed to return a trusted Promise.  If x\n\t *   is trusted, returns x, otherwise, returns a new, trusted, already-resolved\n\t *   Promise whose resolution value is:\n\t *   * the resolution value of x if it's a foreign promise, or\n\t *   * x if it's a value\n\t */\n\tfunction coerce(x) {\n\t\tif(x instanceof Promise) {\n\t\t\treturn x;\n\t\t}\n\n\t\tif (!(x === Object(x) && 'then' in x)) {\n\t\t\treturn fulfilled(x);\n\t\t}\n\n\t\treturn promise(function(resolve, reject, notify) {\n\t\t\tenqueue(function() {\n\t\t\t\ttry {\n\t\t\t\t\t// We must check and assimilate in the same tick, but not the\n\t\t\t\t\t// current tick, careful only to access promiseOrValue.then once.\n\t\t\t\t\tvar untrustedThen = x.then;\n\n\t\t\t\t\tif(typeof untrustedThen === 'function') {\n\t\t\t\t\t\tfcall(untrustedThen, x, resolve, reject, notify);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// It's a value, create a fulfilled wrapper\n\t\t\t\t\t\tresolve(fulfilled(x));\n\t\t\t\t\t}\n\n\t\t\t\t} catch(e) {\n\t\t\t\t\t// Something went wrong, reject\n\t\t\t\t\treject(e);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Create an already-fulfilled promise for the supplied value\n\t * @private\n\t * @param {*} value\n\t * @return {Promise} fulfilled promise\n\t */\n\tfunction fulfilled(value) {\n\t\tvar self = new Promise(function (onFulfilled) {\n\t\t\ttry {\n\t\t\t\treturn typeof onFulfilled == 'function'\n\t\t\t\t\t? coerce(onFulfilled(value)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn rejected(e);\n\t\t\t}\n\t\t}, function() {\n\t\t\treturn toFulfilledState(value);\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Create an already-rejected promise with the supplied rejection reason.\n\t * @private\n\t * @param {*} reason\n\t * @return {Promise} rejected promise\n\t */\n\tfunction rejected(reason) {\n\t\tvar self = new Promise(function (_, onRejected) {\n\t\t\ttry {\n\t\t\t\treturn typeof onRejected == 'function'\n\t\t\t\t\t? coerce(onRejected(reason)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn rejected(e);\n\t\t\t}\n\t\t}, function() {\n\t\t\treturn toRejectedState(reason);\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Create a progress promise with the supplied update.\n\t * @private\n\t * @param {*} update\n\t * @return {Promise} progress promise\n\t */\n\tfunction progressing(update) {\n\t\tvar self = new Promise(function (_, __, onProgress) {\n\t\t\ttry {\n\t\t\t\treturn typeof onProgress == 'function'\n\t\t\t\t\t? progressing(onProgress(update)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn progressing(e);\n\t\t\t}\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Schedule a task that will process a list of handlers\n\t * in the next queue drain run.\n\t * @private\n\t * @param {Array} handlers queue of handlers to execute\n\t * @param {*} value passed as the only arg to each handler\n\t */\n\tfunction scheduleHandlers(handlers, value) {\n\t\tenqueue(function() {\n\t\t\tvar handler, i = 0;\n\t\t\twhile (handler = handlers[i++]) {\n\t\t\t\thandler(value);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Determines if promiseOrValue is a promise or not\n\t *\n\t * @param {*} promiseOrValue anything\n\t * @returns {boolean} true if promiseOrValue is a {@link Promise}\n\t */\n\tfunction isPromise(promiseOrValue) {\n\t\treturn promiseOrValue && typeof promiseOrValue.then === 'function';\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * howMany of the supplied promisesOrValues have resolved, or will reject when\n\t * it becomes impossible for howMany to resolve, for example, when\n\t * (promisesOrValues.length - howMany) + 1 input promises reject.\n\t *\n\t * @param {Array} promisesOrValues array of anything, may contain a mix\n\t *      of promises and values\n\t * @param howMany {number} number of promisesOrValues to resolve\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise} promise that will resolve to an array of howMany values that\n\t *  resolved first, or will reject with an array of\n\t *  (promisesOrValues.length - howMany) + 1 rejection reasons.\n\t */\n\tfunction some(promisesOrValues, howMany, onFulfilled, onRejected, onProgress) {\n\n\t\treturn when(promisesOrValues, function(promisesOrValues) {\n\n\t\t\treturn promise(resolveSome).then(onFulfilled, onRejected, onProgress);\n\n\t\t\tfunction resolveSome(resolve, reject, notify) {\n\t\t\t\tvar toResolve, toReject, values, reasons, fulfillOne, rejectOne, len, i;\n\n\t\t\t\tlen = promisesOrValues.length >>> 0;\n\n\t\t\t\ttoResolve = Math.max(0, Math.min(howMany, len));\n\t\t\t\tvalues = [];\n\n\t\t\t\ttoReject = (len - toResolve) + 1;\n\t\t\t\treasons = [];\n\n\t\t\t\t// No items in the input, resolve immediately\n\t\t\t\tif (!toResolve) {\n\t\t\t\t\tresolve(values);\n\n\t\t\t\t} else {\n\t\t\t\t\trejectOne = function(reason) {\n\t\t\t\t\t\treasons.push(reason);\n\t\t\t\t\t\tif(!--toReject) {\n\t\t\t\t\t\t\tfulfillOne = rejectOne = identity;\n\t\t\t\t\t\t\treject(reasons);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tfulfillOne = function(val) {\n\t\t\t\t\t\t// This orders the values based on promise resolution order\n\t\t\t\t\t\tvalues.push(val);\n\t\t\t\t\t\tif (!--toResolve) {\n\t\t\t\t\t\t\tfulfillOne = rejectOne = identity;\n\t\t\t\t\t\t\tresolve(values);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tfor(i = 0; i < len; ++i) {\n\t\t\t\t\t\tif(i in promisesOrValues) {\n\t\t\t\t\t\t\twhen(promisesOrValues[i], fulfiller, rejecter, notify);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction rejecter(reason) {\n\t\t\t\t\trejectOne(reason);\n\t\t\t\t}\n\n\t\t\t\tfunction fulfiller(val) {\n\t\t\t\t\tfulfillOne(val);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * any one of the supplied promisesOrValues has resolved or will reject when\n\t * *all* promisesOrValues have rejected.\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise} promise that will resolve to the value that resolved first, or\n\t * will reject with an array of all rejected inputs.\n\t */\n\tfunction any(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\n\t\tfunction unwrapSingleResult(val) {\n\t\t\treturn onFulfilled ? onFulfilled(val[0]) : val[0];\n\t\t}\n\n\t\treturn some(promisesOrValues, 1, unwrapSingleResult, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Return a promise that will resolve only once all the supplied promisesOrValues\n\t * have resolved. The resolution value of the returned promise will be an array\n\t * containing the resolution values of each of the promisesOrValues.\n\t * @memberOf when\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise}\n\t */\n\tfunction all(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\t\treturn _map(promisesOrValues, identity).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Joins multiple promises into a single returned promise.\n\t * @return {Promise} a promise that will fulfill when *all* the input promises\n\t * have fulfilled, or will reject when *any one* of the input promises rejects.\n\t */\n\tfunction join(/* ...promises */) {\n\t\treturn _map(arguments, identity);\n\t}\n\n\t/**\n\t * Settles all input promises such that they are guaranteed not to\n\t * be pending once the returned promise fulfills. The returned promise\n\t * will always fulfill, except in the case where `array` is a promise\n\t * that rejects.\n\t * @param {Array|Promise} array or promise for array of promises to settle\n\t * @returns {Promise} promise that always fulfills with an array of\n\t *  outcome snapshots for each input promise.\n\t */\n\tfunction settle(array) {\n\t\treturn _map(array, toFulfilledState, toRejectedState);\n\t}\n\n\t/**\n\t * Promise-aware array map function, similar to `Array.prototype.map()`,\n\t * but input array may contain promises or values.\n\t * @param {Array|Promise} array array of anything, may contain promises and values\n\t * @param {function} mapFunc map function which may return a promise or value\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction map(array, mapFunc) {\n\t\treturn _map(array, mapFunc);\n\t}\n\n\t/**\n\t * Internal map that allows a fallback to handle rejections\n\t * @param {Array|Promise} array array of anything, may contain promises and values\n\t * @param {function} mapFunc map function which may return a promise or value\n\t * @param {function?} fallback function to handle rejected promises\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction _map(array, mapFunc, fallback) {\n\t\treturn when(array, function(array) {\n\n\t\t\treturn promise(resolveMap);\n\n\t\t\tfunction resolveMap(resolve, reject, notify) {\n\t\t\t\tvar results, len, toResolve, i;\n\n\t\t\t\t// Since we know the resulting length, we can preallocate the results\n\t\t\t\t// array to avoid array expansions.\n\t\t\t\ttoResolve = len = array.length >>> 0;\n\t\t\t\tresults = [];\n\n\t\t\t\tif(!toResolve) {\n\t\t\t\t\tresolve(results);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Since mapFunc may be async, get all invocations of it into flight\n\t\t\t\tfor(i = 0; i < len; i++) {\n\t\t\t\t\tif(i in array) {\n\t\t\t\t\t\tresolveOne(array[i], i);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t--toResolve;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction resolveOne(item, i) {\n\t\t\t\t\twhen(item, mapFunc, fallback).then(function(mapped) {\n\t\t\t\t\t\tresults[i] = mapped;\n\n\t\t\t\t\t\tif(!--toResolve) {\n\t\t\t\t\t\t\tresolve(results);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, reject, notify);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n\t * input may contain promises and/or values, and reduceFunc\n\t * may return either a value or a promise, *and* initialValue may\n\t * be a promise for the starting value.\n\t *\n\t * @param {Array|Promise} promise array or promise for an array of anything,\n\t *      may contain a mix of promises and values.\n\t * @param {function} reduceFunc reduce function reduce(currentValue, nextValue, index, total),\n\t *      where total is the total number of items being reduced, and will be the same\n\t *      in each call to reduceFunc.\n\t * @returns {Promise} that will resolve to the final reduced value\n\t */\n\tfunction reduce(promise, reduceFunc /*, initialValue */) {\n\t\tvar args = fcall(slice, arguments, 1);\n\n\t\treturn when(promise, function(array) {\n\t\t\tvar total;\n\n\t\t\ttotal = array.length;\n\n\t\t\t// Wrap the supplied reduceFunc with one that handles promises and then\n\t\t\t// delegates to the supplied.\n\t\t\targs[0] = function (current, val, i) {\n\t\t\t\treturn when(current, function (c) {\n\t\t\t\t\treturn when(val, function (value) {\n\t\t\t\t\t\treturn reduceFunc(c, value, i, total);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\t\treturn reduceArray.apply(array, args);\n\t\t});\n\t}\n\n\t// Snapshot states\n\n\t/**\n\t * Creates a fulfilled state snapshot\n\t * @private\n\t * @param {*} x any value\n\t * @returns {{state:'fulfilled',value:*}}\n\t */\n\tfunction toFulfilledState(x) {\n\t\treturn { state: 'fulfilled', value: x };\n\t}\n\n\t/**\n\t * Creates a rejected state snapshot\n\t * @private\n\t * @param {*} x any reason\n\t * @returns {{state:'rejected',reason:*}}\n\t */\n\tfunction toRejectedState(x) {\n\t\treturn { state: 'rejected', reason: x };\n\t}\n\n\t/**\n\t * Creates a pending state snapshot\n\t * @private\n\t * @returns {{state:'pending'}}\n\t */\n\tfunction toPendingState() {\n\t\treturn { state: 'pending' };\n\t}\n\n\t//\n\t// Utilities, etc.\n\t//\n\n\tvar reduceArray, slice, fcall, nextTick, handlerQueue,\n\t\tsetTimeout, funcProto, call, arrayProto, monitorApi, undef;\n\n\t//\n\t// Shared handler queue processing\n\t//\n\t// Credit to Twisol (https://github.com/Twisol) for suggesting\n\t// this type of extensible queue + trampoline approach for\n\t// next-tick conflation.\n\n\thandlerQueue = [];\n\n\t/**\n\t * Enqueue a task. If the queue is not currently scheduled to be\n\t * drained, schedule it.\n\t * @param {function} task\n\t */\n\tfunction enqueue(task) {\n\t\tif(handlerQueue.push(task) === 1) {\n\t\t\tnextTick(drainQueue);\n\t\t}\n\t}\n\n\t/**\n\t * Drain the handler queue entirely, being careful to allow the\n\t * queue to be extended while it is being processed, and to continue\n\t * processing until it is truly empty.\n\t */\n\tfunction drainQueue() {\n\t\tvar task, i = 0;\n\n\t\twhile(task = handlerQueue[i++]) {\n\t\t\ttask();\n\t\t}\n\n\t\thandlerQueue = [];\n\t}\n\n\t//\n\t// Capture function and array utils\n\t//\n\t/*global setImmediate,process,vertx*/\n\n\t// Allow attaching the monitor to when() if env has no console\n\tmonitorApi = typeof console != 'undefined' ? console : when;\n\n\t// capture setTimeout to avoid being caught by fake timers used in time based tests\n\tsetTimeout = global.setTimeout;\n\t// Prefer setImmediate, cascade to node, vertx and finally setTimeout\n\tnextTick = typeof setImmediate === 'function' ? setImmediate.bind(global)\n\t\t: typeof process === 'object' && process.nextTick ? process.nextTick\n\t\t: typeof vertx === 'object' ? vertx.runOnLoop // vert.x\n\t\t\t: function(task) { setTimeout(task, 0); }; // fallback\n\n\t// Safe function calls\n\tfuncProto = Function.prototype;\n\tcall = funcProto.call;\n\tfcall = funcProto.bind\n\t\t? call.bind(call)\n\t\t: function(f, context) {\n\t\t\treturn f.apply(context, slice.call(arguments, 2));\n\t\t};\n\n\t// Safe array ops\n\tarrayProto = [];\n\tslice = arrayProto.slice;\n\n\t// ES5 reduce implementation if native not available\n\t// See: http://es5.github.com/#x15.4.4.21 as there are many\n\t// specifics and edge cases.  ES5 dictates that reduce.length === 1\n\t// This implementation deviates from ES5 spec in the following ways:\n\t// 1. It does not check if reduceFunc is a Callable\n\treduceArray = arrayProto.reduce ||\n\t\tfunction(reduceFunc /*, initialValue */) {\n\t\t\t/*jshint maxcomplexity: 7*/\n\t\t\tvar arr, args, reduced, len, i;\n\n\t\t\ti = 0;\n\t\t\tarr = Object(this);\n\t\t\tlen = arr.length >>> 0;\n\t\t\targs = arguments;\n\n\t\t\t// If no initialValue, use first item of array (we know length !== 0 here)\n\t\t\t// and adjust i to start at second item\n\t\t\tif(args.length <= 1) {\n\t\t\t\t// Skip to the first real element in the array\n\t\t\t\tfor(;;) {\n\t\t\t\t\tif(i in arr) {\n\t\t\t\t\t\treduced = arr[i++];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If we reached the end of the array without finding any real\n\t\t\t\t\t// elements, it's a TypeError\n\t\t\t\t\tif(++i >= len) {\n\t\t\t\t\t\tthrow new TypeError();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If initialValue provided, use it\n\t\t\t\treduced = args[1];\n\t\t\t}\n\n\t\t\t// Do the actual reduce\n\t\t\tfor(;i < len; ++i) {\n\t\t\t\tif(i in arr) {\n\t\t\t\t\treduced = reduceFunc(reduced, arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn reduced;\n\t\t};\n\n\tfunction identity(x) {\n\t\treturn x;\n\t}\n\n\treturn when;\n});\n})(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(); },\n\tthis\n);\n","modules":[{"pos":428,"count":19,"factory":true,"id":"when/when"}]}{"absId":"when/when","text":"/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * A lightweight CommonJS Promises/A and when() implementation\n * when is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author Brian Cavalier\n * @author John Hann\n * @version 2.2.1\n */\n(function(define, global) { 'use strict';\ndefine(function () {\n\n\t// Public API\n\n\twhen.promise   = promise;    // Create a pending promise\n\twhen.resolve   = resolve;    // Create a resolved promise\n\twhen.reject    = reject;     // Create a rejected promise\n\twhen.defer     = defer;      // Create a {promise, resolver} pair\n\n\twhen.join      = join;       // Join 2 or more promises\n\n\twhen.all       = all;        // Resolve a list of promises\n\twhen.map       = map;        // Array.map() for promises\n\twhen.reduce    = reduce;     // Array.reduce() for promises\n\twhen.settle    = settle;     // Settle a list of promises\n\n\twhen.any       = any;        // One-winner race\n\twhen.some      = some;       // Multi-winner race\n\n\twhen.isPromise = isPromise;  // Determine if a thing is a promise\n\n\n\t/**\n\t * Register an observer for a promise or immediate value.\n\t *\n\t * @param {*} promiseOrValue\n\t * @param {function?} [onFulfilled] callback to be called when promiseOrValue is\n\t *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n\t *   will be invoked immediately.\n\t * @param {function?} [onRejected] callback to be called when promiseOrValue is\n\t *   rejected.\n\t * @param {function?} [onProgress] callback to be called when progress updates\n\t *   are issued for promiseOrValue.\n\t * @returns {Promise} a new {@link Promise} that will complete with the return\n\t *   value of callback or errback or the completion value of promiseOrValue if\n\t *   callback and/or errback is not supplied.\n\t */\n\tfunction when(promiseOrValue, onFulfilled, onRejected, onProgress) {\n\t\t// Get a trusted promise for the input promiseOrValue, and then\n\t\t// register promise handlers\n\t\treturn resolve(promiseOrValue).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Trusted Promise constructor.  A Promise created from this constructor is\n\t * a trusted when.js promise.  Any other duck-typed promise is considered\n\t * untrusted.\n\t * @constructor\n\t * @name Promise\n\t */\n\tfunction Promise(then, inspect) {\n\t\tthis.then = then;\n\t\tthis.inspect = inspect;\n\t}\n\n\tPromise.prototype = {\n\t\t/**\n\t\t * Register a rejection handler.  Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @return {Promise}\n\t\t */\n\t\totherwise: function(onRejected) {\n\t\t\treturn this.then(undef, onRejected);\n\t\t},\n\n\t\t/**\n\t\t * Ensures that onFulfilledOrRejected will be called regardless of whether\n\t\t * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT\n\t\t * receive the promises' value or reason.  Any returned value will be disregarded.\n\t\t * onFulfilledOrRejected may throw or return a rejected promise to signal\n\t\t * an additional error.\n\t\t * @param {function} onFulfilledOrRejected handler to be called regardless of\n\t\t *  fulfillment or rejection\n\t\t * @returns {Promise}\n\t\t */\n\t\tensure: function(onFulfilledOrRejected) {\n\t\t\treturn this.then(injectHandler, injectHandler)['yield'](this);\n\n\t\t\tfunction injectHandler() {\n\t\t\t\treturn resolve(onFulfilledOrRejected());\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Shortcut for .then(function() { return value; })\n\t\t * @param  {*} value\n\t\t * @return {Promise} a promise that:\n\t\t *  - is fulfilled if value is not a promise, or\n\t\t *  - if value is a promise, will fulfill with its value, or reject\n\t\t *    with its reason.\n\t\t */\n\t\t'yield': function(value) {\n\t\t\treturn this.then(function() {\n\t\t\t\treturn value;\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Assumes that this promise will fulfill with an array, and arranges\n\t\t * for the onFulfilled to be called with the array as its argument list\n\t\t * i.e. onFulfilled.apply(undefined, array).\n\t\t * @param {function} onFulfilled function to receive spread arguments\n\t\t * @return {Promise}\n\t\t */\n\t\tspread: function(onFulfilled) {\n\t\t\treturn this.then(function(array) {\n\t\t\t\t// array may contain promises, so resolve its contents.\n\t\t\t\treturn all(array, function(array) {\n\t\t\t\t\treturn onFulfilled.apply(undef, array);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Shortcut for .then(onFulfilledOrRejected, onFulfilledOrRejected)\n\t\t * @deprecated\n\t\t */\n\t\talways: function(onFulfilledOrRejected, onProgress) {\n\t\t\treturn this.then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress);\n\t\t}\n\t};\n\n\t/**\n\t * Returns a resolved promise. The returned promise will be\n\t *  - fulfilled with promiseOrValue if it is a value, or\n\t *  - if promiseOrValue is a promise\n\t *    - fulfilled with promiseOrValue's value after it is fulfilled\n\t *    - rejected with promiseOrValue's reason after it is rejected\n\t * @param  {*} value\n\t * @return {Promise}\n\t */\n\tfunction resolve(value) {\n\t\treturn promise(function(resolve) {\n\t\t\tresolve(value);\n\t\t});\n\t}\n\n\t/**\n\t * Returns a rejected promise for the supplied promiseOrValue.  The returned\n\t * promise will be rejected with:\n\t * - promiseOrValue, if it is a value, or\n\t * - if promiseOrValue is a promise\n\t *   - promiseOrValue's value after it is fulfilled\n\t *   - promiseOrValue's reason after it is rejected\n\t * @param {*} promiseOrValue the rejected value of the returned {@link Promise}\n\t * @return {Promise} rejected {@link Promise}\n\t */\n\tfunction reject(promiseOrValue) {\n\t\treturn when(promiseOrValue, rejected);\n\t}\n\n\t/**\n\t * Creates a {promise, resolver} pair, either or both of which\n\t * may be given out safely to consumers.\n\t * The resolver has resolve, reject, and progress.  The promise\n\t * has then plus extended promise API.\n\t *\n\t * @return {{\n\t * promise: Promise,\n\t * resolve: function:Promise,\n\t * reject: function:Promise,\n\t * notify: function:Promise\n\t * resolver: {\n\t *\tresolve: function:Promise,\n\t *\treject: function:Promise,\n\t *\tnotify: function:Promise\n\t * }}}\n\t */\n\tfunction defer() {\n\t\tvar deferred, pending, resolved;\n\n\t\t// Optimize object shape\n\t\tdeferred = {\n\t\t\tpromise: undef, resolve: undef, reject: undef, notify: undef,\n\t\t\tresolver: { resolve: undef, reject: undef, notify: undef }\n\t\t};\n\n\t\tdeferred.promise = pending = promise(makeDeferred);\n\n\t\treturn deferred;\n\n\t\tfunction makeDeferred(resolvePending, rejectPending, notifyPending) {\n\t\t\tdeferred.resolve = deferred.resolver.resolve = function(value) {\n\t\t\t\tif(resolved) {\n\t\t\t\t\treturn resolve(value);\n\t\t\t\t}\n\t\t\t\tresolved = true;\n\t\t\t\tresolvePending(value);\n\t\t\t\treturn pending;\n\t\t\t};\n\n\t\t\tdeferred.reject  = deferred.resolver.reject  = function(reason) {\n\t\t\t\tif(resolved) {\n\t\t\t\t\treturn resolve(rejected(reason));\n\t\t\t\t}\n\t\t\t\tresolved = true;\n\t\t\t\trejectPending(reason);\n\t\t\t\treturn pending;\n\t\t\t};\n\n\t\t\tdeferred.notify  = deferred.resolver.notify  = function(update) {\n\t\t\t\tnotifyPending(update);\n\t\t\t\treturn update;\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new promise whose fate is determined by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t */\n\tfunction promise(resolver) {\n\t\treturn _promise(resolver, monitorApi.PromiseStatus && monitorApi.PromiseStatus());\n\t}\n\n\t/**\n\t * Creates a new promise, linked to parent, whose fate is determined\n\t * by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @param {Promise?} status promise from which the new promise is begotten\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t * @private\n\t */\n\tfunction _promise(resolver, status) {\n\t\tvar self, value, handlers = [];\n\n\t\tself = new Promise(then, inspect);\n\n\t\t// Call the provider resolver to seal the promise's fate\n\t\ttry {\n\t\t\tresolver(promiseResolve, promiseReject, promiseNotify);\n\t\t} catch(e) {\n\t\t\tpromiseReject(e);\n\t\t}\n\n\t\t// Return the promise\n\t\treturn self;\n\n\t\t/**\n\t\t * Register handlers for this promise.\n\t\t * @param [onFulfilled] {Function} fulfillment handler\n\t\t * @param [onRejected] {Function} rejection handler\n\t\t * @param [onProgress] {Function} progress handler\n\t\t * @return {Promise} new Promise\n\t\t */\n\t\tfunction then(onFulfilled, onRejected, onProgress) {\n\t\t\tvar next = _promise(function(resolve, reject, notify) {\n\t\t\t\t// if not resolved, push onto handlers, otherwise execute asap\n\t\t\t\t// but not in the current stack\n\t\t\t\thandlers ? handlers.push(run) : enqueue(function() { run(value); });\n\n\t\t\t\tfunction run(p) {\n\t\t\t\t\tp.then(onFulfilled, onRejected, onProgress)\n\t\t\t\t\t\t.then(resolve, reject, notify);\n\t\t\t\t}\n\n\t\t\t}, status && status.observed());\n\n\t\t\treturn next;\n\t\t}\n\n\t\tfunction inspect() {\n\t\t\treturn value ? value.inspect() : toPendingState();\n\t\t}\n\n\t\t/**\n\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t * all listeners of the ultimate fulfillment or rejection\n\t\t * @param {*|Promise} val resolution value\n\t\t */\n\t\tfunction promiseResolve(val) {\n\t\t\tif(!handlers) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvalue = coerce(val);\n\t\t\tscheduleHandlers(handlers, value);\n\t\t\thandlers = undef;\n\n\t\t\tif (status) {\n\t\t\t\tvalue.then(\n\t\t\t\t\tfunction () { status.fulfilled(); },\n\t\t\t\t\tfunction(r) { status.rejected(r); }\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Reject this promise with the supplied reason, which will be used verbatim.\n\t\t * @param {*} reason reason for the rejection\n\t\t */\n\t\tfunction promiseReject(reason) {\n\t\t\tpromiseResolve(rejected(reason));\n\t\t}\n\n\t\t/**\n\t\t * Issue a progress event, notifying all progress listeners\n\t\t * @param {*} update progress event payload to pass to all listeners\n\t\t */\n\t\tfunction promiseNotify(update) {\n\t\t\tif(handlers) {\n\t\t\t\tscheduleHandlers(handlers, progressing(update));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Coerces x to a trusted Promise\n\t *\n\t * @private\n\t * @param {*} x thing to coerce\n\t * @returns {Promise} Guaranteed to return a trusted Promise.  If x\n\t *   is trusted, returns x, otherwise, returns a new, trusted, already-resolved\n\t *   Promise whose resolution value is:\n\t *   * the resolution value of x if it's a foreign promise, or\n\t *   * x if it's a value\n\t */\n\tfunction coerce(x) {\n\t\tif(x instanceof Promise) {\n\t\t\treturn x;\n\t\t}\n\n\t\tif (!(x === Object(x) && 'then' in x)) {\n\t\t\treturn fulfilled(x);\n\t\t}\n\n\t\treturn promise(function(resolve, reject, notify) {\n\t\t\tenqueue(function() {\n\t\t\t\ttry {\n\t\t\t\t\t// We must check and assimilate in the same tick, but not the\n\t\t\t\t\t// current tick, careful only to access promiseOrValue.then once.\n\t\t\t\t\tvar untrustedThen = x.then;\n\n\t\t\t\t\tif(typeof untrustedThen === 'function') {\n\t\t\t\t\t\tfcall(untrustedThen, x, resolve, reject, notify);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// It's a value, create a fulfilled wrapper\n\t\t\t\t\t\tresolve(fulfilled(x));\n\t\t\t\t\t}\n\n\t\t\t\t} catch(e) {\n\t\t\t\t\t// Something went wrong, reject\n\t\t\t\t\treject(e);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Create an already-fulfilled promise for the supplied value\n\t * @private\n\t * @param {*} value\n\t * @return {Promise} fulfilled promise\n\t */\n\tfunction fulfilled(value) {\n\t\tvar self = new Promise(function (onFulfilled) {\n\t\t\ttry {\n\t\t\t\treturn typeof onFulfilled == 'function'\n\t\t\t\t\t? coerce(onFulfilled(value)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn rejected(e);\n\t\t\t}\n\t\t}, function() {\n\t\t\treturn toFulfilledState(value);\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Create an already-rejected promise with the supplied rejection reason.\n\t * @private\n\t * @param {*} reason\n\t * @return {Promise} rejected promise\n\t */\n\tfunction rejected(reason) {\n\t\tvar self = new Promise(function (_, onRejected) {\n\t\t\ttry {\n\t\t\t\treturn typeof onRejected == 'function'\n\t\t\t\t\t? coerce(onRejected(reason)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn rejected(e);\n\t\t\t}\n\t\t}, function() {\n\t\t\treturn toRejectedState(reason);\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Create a progress promise with the supplied update.\n\t * @private\n\t * @param {*} update\n\t * @return {Promise} progress promise\n\t */\n\tfunction progressing(update) {\n\t\tvar self = new Promise(function (_, __, onProgress) {\n\t\t\ttry {\n\t\t\t\treturn typeof onProgress == 'function'\n\t\t\t\t\t? progressing(onProgress(update)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn progressing(e);\n\t\t\t}\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Schedule a task that will process a list of handlers\n\t * in the next queue drain run.\n\t * @private\n\t * @param {Array} handlers queue of handlers to execute\n\t * @param {*} value passed as the only arg to each handler\n\t */\n\tfunction scheduleHandlers(handlers, value) {\n\t\tenqueue(function() {\n\t\t\tvar handler, i = 0;\n\t\t\twhile (handler = handlers[i++]) {\n\t\t\t\thandler(value);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Determines if promiseOrValue is a promise or not\n\t *\n\t * @param {*} promiseOrValue anything\n\t * @returns {boolean} true if promiseOrValue is a {@link Promise}\n\t */\n\tfunction isPromise(promiseOrValue) {\n\t\treturn promiseOrValue && typeof promiseOrValue.then === 'function';\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * howMany of the supplied promisesOrValues have resolved, or will reject when\n\t * it becomes impossible for howMany to resolve, for example, when\n\t * (promisesOrValues.length - howMany) + 1 input promises reject.\n\t *\n\t * @param {Array} promisesOrValues array of anything, may contain a mix\n\t *      of promises and values\n\t * @param howMany {number} number of promisesOrValues to resolve\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise} promise that will resolve to an array of howMany values that\n\t *  resolved first, or will reject with an array of\n\t *  (promisesOrValues.length - howMany) + 1 rejection reasons.\n\t */\n\tfunction some(promisesOrValues, howMany, onFulfilled, onRejected, onProgress) {\n\n\t\treturn when(promisesOrValues, function(promisesOrValues) {\n\n\t\t\treturn promise(resolveSome).then(onFulfilled, onRejected, onProgress);\n\n\t\t\tfunction resolveSome(resolve, reject, notify) {\n\t\t\t\tvar toResolve, toReject, values, reasons, fulfillOne, rejectOne, len, i;\n\n\t\t\t\tlen = promisesOrValues.length >>> 0;\n\n\t\t\t\ttoResolve = Math.max(0, Math.min(howMany, len));\n\t\t\t\tvalues = [];\n\n\t\t\t\ttoReject = (len - toResolve) + 1;\n\t\t\t\treasons = [];\n\n\t\t\t\t// No items in the input, resolve immediately\n\t\t\t\tif (!toResolve) {\n\t\t\t\t\tresolve(values);\n\n\t\t\t\t} else {\n\t\t\t\t\trejectOne = function(reason) {\n\t\t\t\t\t\treasons.push(reason);\n\t\t\t\t\t\tif(!--toReject) {\n\t\t\t\t\t\t\tfulfillOne = rejectOne = identity;\n\t\t\t\t\t\t\treject(reasons);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tfulfillOne = function(val) {\n\t\t\t\t\t\t// This orders the values based on promise resolution order\n\t\t\t\t\t\tvalues.push(val);\n\t\t\t\t\t\tif (!--toResolve) {\n\t\t\t\t\t\t\tfulfillOne = rejectOne = identity;\n\t\t\t\t\t\t\tresolve(values);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tfor(i = 0; i < len; ++i) {\n\t\t\t\t\t\tif(i in promisesOrValues) {\n\t\t\t\t\t\t\twhen(promisesOrValues[i], fulfiller, rejecter, notify);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction rejecter(reason) {\n\t\t\t\t\trejectOne(reason);\n\t\t\t\t}\n\n\t\t\t\tfunction fulfiller(val) {\n\t\t\t\t\tfulfillOne(val);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * any one of the supplied promisesOrValues has resolved or will reject when\n\t * *all* promisesOrValues have rejected.\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise} promise that will resolve to the value that resolved first, or\n\t * will reject with an array of all rejected inputs.\n\t */\n\tfunction any(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\n\t\tfunction unwrapSingleResult(val) {\n\t\t\treturn onFulfilled ? onFulfilled(val[0]) : val[0];\n\t\t}\n\n\t\treturn some(promisesOrValues, 1, unwrapSingleResult, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Return a promise that will resolve only once all the supplied promisesOrValues\n\t * have resolved. The resolution value of the returned promise will be an array\n\t * containing the resolution values of each of the promisesOrValues.\n\t * @memberOf when\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise}\n\t */\n\tfunction all(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\t\treturn _map(promisesOrValues, identity).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Joins multiple promises into a single returned promise.\n\t * @return {Promise} a promise that will fulfill when *all* the input promises\n\t * have fulfilled, or will reject when *any one* of the input promises rejects.\n\t */\n\tfunction join(/* ...promises */) {\n\t\treturn _map(arguments, identity);\n\t}\n\n\t/**\n\t * Settles all input promises such that they are guaranteed not to\n\t * be pending once the returned promise fulfills. The returned promise\n\t * will always fulfill, except in the case where `array` is a promise\n\t * that rejects.\n\t * @param {Array|Promise} array or promise for array of promises to settle\n\t * @returns {Promise} promise that always fulfills with an array of\n\t *  outcome snapshots for each input promise.\n\t */\n\tfunction settle(array) {\n\t\treturn _map(array, toFulfilledState, toRejectedState);\n\t}\n\n\t/**\n\t * Promise-aware array map function, similar to `Array.prototype.map()`,\n\t * but input array may contain promises or values.\n\t * @param {Array|Promise} array array of anything, may contain promises and values\n\t * @param {function} mapFunc map function which may return a promise or value\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction map(array, mapFunc) {\n\t\treturn _map(array, mapFunc);\n\t}\n\n\t/**\n\t * Internal map that allows a fallback to handle rejections\n\t * @param {Array|Promise} array array of anything, may contain promises and values\n\t * @param {function} mapFunc map function which may return a promise or value\n\t * @param {function?} fallback function to handle rejected promises\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction _map(array, mapFunc, fallback) {\n\t\treturn when(array, function(array) {\n\n\t\t\treturn promise(resolveMap);\n\n\t\t\tfunction resolveMap(resolve, reject, notify) {\n\t\t\t\tvar results, len, toResolve, i;\n\n\t\t\t\t// Since we know the resulting length, we can preallocate the results\n\t\t\t\t// array to avoid array expansions.\n\t\t\t\ttoResolve = len = array.length >>> 0;\n\t\t\t\tresults = [];\n\n\t\t\t\tif(!toResolve) {\n\t\t\t\t\tresolve(results);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Since mapFunc may be async, get all invocations of it into flight\n\t\t\t\tfor(i = 0; i < len; i++) {\n\t\t\t\t\tif(i in array) {\n\t\t\t\t\t\tresolveOne(array[i], i);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t--toResolve;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction resolveOne(item, i) {\n\t\t\t\t\twhen(item, mapFunc, fallback).then(function(mapped) {\n\t\t\t\t\t\tresults[i] = mapped;\n\n\t\t\t\t\t\tif(!--toResolve) {\n\t\t\t\t\t\t\tresolve(results);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, reject, notify);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n\t * input may contain promises and/or values, and reduceFunc\n\t * may return either a value or a promise, *and* initialValue may\n\t * be a promise for the starting value.\n\t *\n\t * @param {Array|Promise} promise array or promise for an array of anything,\n\t *      may contain a mix of promises and values.\n\t * @param {function} reduceFunc reduce function reduce(currentValue, nextValue, index, total),\n\t *      where total is the total number of items being reduced, and will be the same\n\t *      in each call to reduceFunc.\n\t * @returns {Promise} that will resolve to the final reduced value\n\t */\n\tfunction reduce(promise, reduceFunc /*, initialValue */) {\n\t\tvar args = fcall(slice, arguments, 1);\n\n\t\treturn when(promise, function(array) {\n\t\t\tvar total;\n\n\t\t\ttotal = array.length;\n\n\t\t\t// Wrap the supplied reduceFunc with one that handles promises and then\n\t\t\t// delegates to the supplied.\n\t\t\targs[0] = function (current, val, i) {\n\t\t\t\treturn when(current, function (c) {\n\t\t\t\t\treturn when(val, function (value) {\n\t\t\t\t\t\treturn reduceFunc(c, value, i, total);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\t\treturn reduceArray.apply(array, args);\n\t\t});\n\t}\n\n\t// Snapshot states\n\n\t/**\n\t * Creates a fulfilled state snapshot\n\t * @private\n\t * @param {*} x any value\n\t * @returns {{state:'fulfilled',value:*}}\n\t */\n\tfunction toFulfilledState(x) {\n\t\treturn { state: 'fulfilled', value: x };\n\t}\n\n\t/**\n\t * Creates a rejected state snapshot\n\t * @private\n\t * @param {*} x any reason\n\t * @returns {{state:'rejected',reason:*}}\n\t */\n\tfunction toRejectedState(x) {\n\t\treturn { state: 'rejected', reason: x };\n\t}\n\n\t/**\n\t * Creates a pending state snapshot\n\t * @private\n\t * @returns {{state:'pending'}}\n\t */\n\tfunction toPendingState() {\n\t\treturn { state: 'pending' };\n\t}\n\n\t//\n\t// Utilities, etc.\n\t//\n\n\tvar reduceArray, slice, fcall, nextTick, handlerQueue,\n\t\tsetTimeout, funcProto, call, arrayProto, monitorApi, undef;\n\n\t//\n\t// Shared handler queue processing\n\t//\n\t// Credit to Twisol (https://github.com/Twisol) for suggesting\n\t// this type of extensible queue + trampoline approach for\n\t// next-tick conflation.\n\n\thandlerQueue = [];\n\n\t/**\n\t * Enqueue a task. If the queue is not currently scheduled to be\n\t * drained, schedule it.\n\t * @param {function} task\n\t */\n\tfunction enqueue(task) {\n\t\tif(handlerQueue.push(task) === 1) {\n\t\t\tnextTick(drainQueue);\n\t\t}\n\t}\n\n\t/**\n\t * Drain the handler queue entirely, being careful to allow the\n\t * queue to be extended while it is being processed, and to continue\n\t * processing until it is truly empty.\n\t */\n\tfunction drainQueue() {\n\t\tvar task, i = 0;\n\n\t\twhile(task = handlerQueue[i++]) {\n\t\t\ttask();\n\t\t}\n\n\t\thandlerQueue = [];\n\t}\n\n\t//\n\t// Capture function and array utils\n\t//\n\t/*global setImmediate,process,vertx*/\n\n\t// Allow attaching the monitor to when() if env has no console\n\tmonitorApi = typeof console != 'undefined' ? console : when;\n\n\t// capture setTimeout to avoid being caught by fake timers used in time based tests\n\tsetTimeout = global.setTimeout;\n\t// Prefer setImmediate, cascade to node, vertx and finally setTimeout\n\tnextTick = typeof setImmediate === 'function' ? setImmediate.bind(global)\n\t\t: typeof process === 'object' && process.nextTick ? process.nextTick\n\t\t: typeof vertx === 'object' ? vertx.runOnLoop // vert.x\n\t\t\t: function(task) { setTimeout(task, 0); }; // fallback\n\n\t// Safe function calls\n\tfuncProto = Function.prototype;\n\tcall = funcProto.call;\n\tfcall = funcProto.bind\n\t\t? call.bind(call)\n\t\t: function(f, context) {\n\t\t\treturn f.apply(context, slice.call(arguments, 2));\n\t\t};\n\n\t// Safe array ops\n\tarrayProto = [];\n\tslice = arrayProto.slice;\n\n\t// ES5 reduce implementation if native not available\n\t// See: http://es5.github.com/#x15.4.4.21 as there are many\n\t// specifics and edge cases.  ES5 dictates that reduce.length === 1\n\t// This implementation deviates from ES5 spec in the following ways:\n\t// 1. It does not check if reduceFunc is a Callable\n\treduceArray = arrayProto.reduce ||\n\t\tfunction(reduceFunc /*, initialValue */) {\n\t\t\t/*jshint maxcomplexity: 7*/\n\t\t\tvar arr, args, reduced, len, i;\n\n\t\t\ti = 0;\n\t\t\tarr = Object(this);\n\t\t\tlen = arr.length >>> 0;\n\t\t\targs = arguments;\n\n\t\t\t// If no initialValue, use first item of array (we know length !== 0 here)\n\t\t\t// and adjust i to start at second item\n\t\t\tif(args.length <= 1) {\n\t\t\t\t// Skip to the first real element in the array\n\t\t\t\tfor(;;) {\n\t\t\t\t\tif(i in arr) {\n\t\t\t\t\t\treduced = arr[i++];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If we reached the end of the array without finding any real\n\t\t\t\t\t// elements, it's a TypeError\n\t\t\t\t\tif(++i >= len) {\n\t\t\t\t\t\tthrow new TypeError();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If initialValue provided, use it\n\t\t\t\treduced = args[1];\n\t\t\t}\n\n\t\t\t// Do the actual reduce\n\t\t\tfor(;i < len; ++i) {\n\t\t\t\tif(i in arr) {\n\t\t\t\t\treduced = reduceFunc(reduced, arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn reduced;\n\t\t};\n\n\tfunction identity(x) {\n\t\treturn x;\n\t}\n\n\treturn when;\n});\n})(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(); },\n\tthis\n);\n","modules":[{"pos":428,"count":19,"factory":true,"id":"when/when"}]}{"absId":"when/when","text":"/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * A lightweight CommonJS Promises/A and when() implementation\n * when is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author Brian Cavalier\n * @author John Hann\n * @version 2.2.1\n */\n(function(define, global) { 'use strict';\ndefine(function () {\n\n\t// Public API\n\n\twhen.promise   = promise;    // Create a pending promise\n\twhen.resolve   = resolve;    // Create a resolved promise\n\twhen.reject    = reject;     // Create a rejected promise\n\twhen.defer     = defer;      // Create a {promise, resolver} pair\n\n\twhen.join      = join;       // Join 2 or more promises\n\n\twhen.all       = all;        // Resolve a list of promises\n\twhen.map       = map;        // Array.map() for promises\n\twhen.reduce    = reduce;     // Array.reduce() for promises\n\twhen.settle    = settle;     // Settle a list of promises\n\n\twhen.any       = any;        // One-winner race\n\twhen.some      = some;       // Multi-winner race\n\n\twhen.isPromise = isPromise;  // Determine if a thing is a promise\n\n\n\t/**\n\t * Register an observer for a promise or immediate value.\n\t *\n\t * @param {*} promiseOrValue\n\t * @param {function?} [onFulfilled] callback to be called when promiseOrValue is\n\t *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n\t *   will be invoked immediately.\n\t * @param {function?} [onRejected] callback to be called when promiseOrValue is\n\t *   rejected.\n\t * @param {function?} [onProgress] callback to be called when progress updates\n\t *   are issued for promiseOrValue.\n\t * @returns {Promise} a new {@link Promise} that will complete with the return\n\t *   value of callback or errback or the completion value of promiseOrValue if\n\t *   callback and/or errback is not supplied.\n\t */\n\tfunction when(promiseOrValue, onFulfilled, onRejected, onProgress) {\n\t\t// Get a trusted promise for the input promiseOrValue, and then\n\t\t// register promise handlers\n\t\treturn resolve(promiseOrValue).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Trusted Promise constructor.  A Promise created from this constructor is\n\t * a trusted when.js promise.  Any other duck-typed promise is considered\n\t * untrusted.\n\t * @constructor\n\t * @name Promise\n\t */\n\tfunction Promise(then, inspect) {\n\t\tthis.then = then;\n\t\tthis.inspect = inspect;\n\t}\n\n\tPromise.prototype = {\n\t\t/**\n\t\t * Register a rejection handler.  Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @return {Promise}\n\t\t */\n\t\totherwise: function(onRejected) {\n\t\t\treturn this.then(undef, onRejected);\n\t\t},\n\n\t\t/**\n\t\t * Ensures that onFulfilledOrRejected will be called regardless of whether\n\t\t * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT\n\t\t * receive the promises' value or reason.  Any returned value will be disregarded.\n\t\t * onFulfilledOrRejected may throw or return a rejected promise to signal\n\t\t * an additional error.\n\t\t * @param {function} onFulfilledOrRejected handler to be called regardless of\n\t\t *  fulfillment or rejection\n\t\t * @returns {Promise}\n\t\t */\n\t\tensure: function(onFulfilledOrRejected) {\n\t\t\treturn this.then(injectHandler, injectHandler)['yield'](this);\n\n\t\t\tfunction injectHandler() {\n\t\t\t\treturn resolve(onFulfilledOrRejected());\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Shortcut for .then(function() { return value; })\n\t\t * @param  {*} value\n\t\t * @return {Promise} a promise that:\n\t\t *  - is fulfilled if value is not a promise, or\n\t\t *  - if value is a promise, will fulfill with its value, or reject\n\t\t *    with its reason.\n\t\t */\n\t\t'yield': function(value) {\n\t\t\treturn this.then(function() {\n\t\t\t\treturn value;\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Assumes that this promise will fulfill with an array, and arranges\n\t\t * for the onFulfilled to be called with the array as its argument list\n\t\t * i.e. onFulfilled.apply(undefined, array).\n\t\t * @param {function} onFulfilled function to receive spread arguments\n\t\t * @return {Promise}\n\t\t */\n\t\tspread: function(onFulfilled) {\n\t\t\treturn this.then(function(array) {\n\t\t\t\t// array may contain promises, so resolve its contents.\n\t\t\t\treturn all(array, function(array) {\n\t\t\t\t\treturn onFulfilled.apply(undef, array);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Shortcut for .then(onFulfilledOrRejected, onFulfilledOrRejected)\n\t\t * @deprecated\n\t\t */\n\t\talways: function(onFulfilledOrRejected, onProgress) {\n\t\t\treturn this.then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress);\n\t\t}\n\t};\n\n\t/**\n\t * Returns a resolved promise. The returned promise will be\n\t *  - fulfilled with promiseOrValue if it is a value, or\n\t *  - if promiseOrValue is a promise\n\t *    - fulfilled with promiseOrValue's value after it is fulfilled\n\t *    - rejected with promiseOrValue's reason after it is rejected\n\t * @param  {*} value\n\t * @return {Promise}\n\t */\n\tfunction resolve(value) {\n\t\treturn promise(function(resolve) {\n\t\t\tresolve(value);\n\t\t});\n\t}\n\n\t/**\n\t * Returns a rejected promise for the supplied promiseOrValue.  The returned\n\t * promise will be rejected with:\n\t * - promiseOrValue, if it is a value, or\n\t * - if promiseOrValue is a promise\n\t *   - promiseOrValue's value after it is fulfilled\n\t *   - promiseOrValue's reason after it is rejected\n\t * @param {*} promiseOrValue the rejected value of the returned {@link Promise}\n\t * @return {Promise} rejected {@link Promise}\n\t */\n\tfunction reject(promiseOrValue) {\n\t\treturn when(promiseOrValue, rejected);\n\t}\n\n\t/**\n\t * Creates a {promise, resolver} pair, either or both of which\n\t * may be given out safely to consumers.\n\t * The resolver has resolve, reject, and progress.  The promise\n\t * has then plus extended promise API.\n\t *\n\t * @return {{\n\t * promise: Promise,\n\t * resolve: function:Promise,\n\t * reject: function:Promise,\n\t * notify: function:Promise\n\t * resolver: {\n\t *\tresolve: function:Promise,\n\t *\treject: function:Promise,\n\t *\tnotify: function:Promise\n\t * }}}\n\t */\n\tfunction defer() {\n\t\tvar deferred, pending, resolved;\n\n\t\t// Optimize object shape\n\t\tdeferred = {\n\t\t\tpromise: undef, resolve: undef, reject: undef, notify: undef,\n\t\t\tresolver: { resolve: undef, reject: undef, notify: undef }\n\t\t};\n\n\t\tdeferred.promise = pending = promise(makeDeferred);\n\n\t\treturn deferred;\n\n\t\tfunction makeDeferred(resolvePending, rejectPending, notifyPending) {\n\t\t\tdeferred.resolve = deferred.resolver.resolve = function(value) {\n\t\t\t\tif(resolved) {\n\t\t\t\t\treturn resolve(value);\n\t\t\t\t}\n\t\t\t\tresolved = true;\n\t\t\t\tresolvePending(value);\n\t\t\t\treturn pending;\n\t\t\t};\n\n\t\t\tdeferred.reject  = deferred.resolver.reject  = function(reason) {\n\t\t\t\tif(resolved) {\n\t\t\t\t\treturn resolve(rejected(reason));\n\t\t\t\t}\n\t\t\t\tresolved = true;\n\t\t\t\trejectPending(reason);\n\t\t\t\treturn pending;\n\t\t\t};\n\n\t\t\tdeferred.notify  = deferred.resolver.notify  = function(update) {\n\t\t\t\tnotifyPending(update);\n\t\t\t\treturn update;\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new promise whose fate is determined by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t */\n\tfunction promise(resolver) {\n\t\treturn _promise(resolver, monitorApi.PromiseStatus && monitorApi.PromiseStatus());\n\t}\n\n\t/**\n\t * Creates a new promise, linked to parent, whose fate is determined\n\t * by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @param {Promise?} status promise from which the new promise is begotten\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t * @private\n\t */\n\tfunction _promise(resolver, status) {\n\t\tvar self, value, handlers = [];\n\n\t\tself = new Promise(then, inspect);\n\n\t\t// Call the provider resolver to seal the promise's fate\n\t\ttry {\n\t\t\tresolver(promiseResolve, promiseReject, promiseNotify);\n\t\t} catch(e) {\n\t\t\tpromiseReject(e);\n\t\t}\n\n\t\t// Return the promise\n\t\treturn self;\n\n\t\t/**\n\t\t * Register handlers for this promise.\n\t\t * @param [onFulfilled] {Function} fulfillment handler\n\t\t * @param [onRejected] {Function} rejection handler\n\t\t * @param [onProgress] {Function} progress handler\n\t\t * @return {Promise} new Promise\n\t\t */\n\t\tfunction then(onFulfilled, onRejected, onProgress) {\n\t\t\tvar next = _promise(function(resolve, reject, notify) {\n\t\t\t\t// if not resolved, push onto handlers, otherwise execute asap\n\t\t\t\t// but not in the current stack\n\t\t\t\thandlers ? handlers.push(run) : enqueue(function() { run(value); });\n\n\t\t\t\tfunction run(p) {\n\t\t\t\t\tp.then(onFulfilled, onRejected, onProgress)\n\t\t\t\t\t\t.then(resolve, reject, notify);\n\t\t\t\t}\n\n\t\t\t}, status && status.observed());\n\n\t\t\treturn next;\n\t\t}\n\n\t\tfunction inspect() {\n\t\t\treturn value ? value.inspect() : toPendingState();\n\t\t}\n\n\t\t/**\n\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t * all listeners of the ultimate fulfillment or rejection\n\t\t * @param {*|Promise} val resolution value\n\t\t */\n\t\tfunction promiseResolve(val) {\n\t\t\tif(!handlers) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvalue = coerce(val);\n\t\t\tscheduleHandlers(handlers, value);\n\t\t\thandlers = undef;\n\n\t\t\tif (status) {\n\t\t\t\tvalue.then(\n\t\t\t\t\tfunction () { status.fulfilled(); },\n\t\t\t\t\tfunction(r) { status.rejected(r); }\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Reject this promise with the supplied reason, which will be used verbatim.\n\t\t * @param {*} reason reason for the rejection\n\t\t */\n\t\tfunction promiseReject(reason) {\n\t\t\tpromiseResolve(rejected(reason));\n\t\t}\n\n\t\t/**\n\t\t * Issue a progress event, notifying all progress listeners\n\t\t * @param {*} update progress event payload to pass to all listeners\n\t\t */\n\t\tfunction promiseNotify(update) {\n\t\t\tif(handlers) {\n\t\t\t\tscheduleHandlers(handlers, progressing(update));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Coerces x to a trusted Promise\n\t *\n\t * @private\n\t * @param {*} x thing to coerce\n\t * @returns {Promise} Guaranteed to return a trusted Promise.  If x\n\t *   is trusted, returns x, otherwise, returns a new, trusted, already-resolved\n\t *   Promise whose resolution value is:\n\t *   * the resolution value of x if it's a foreign promise, or\n\t *   * x if it's a value\n\t */\n\tfunction coerce(x) {\n\t\tif(x instanceof Promise) {\n\t\t\treturn x;\n\t\t}\n\n\t\tif (!(x === Object(x) && 'then' in x)) {\n\t\t\treturn fulfilled(x);\n\t\t}\n\n\t\treturn promise(function(resolve, reject, notify) {\n\t\t\tenqueue(function() {\n\t\t\t\ttry {\n\t\t\t\t\t// We must check and assimilate in the same tick, but not the\n\t\t\t\t\t// current tick, careful only to access promiseOrValue.then once.\n\t\t\t\t\tvar untrustedThen = x.then;\n\n\t\t\t\t\tif(typeof untrustedThen === 'function') {\n\t\t\t\t\t\tfcall(untrustedThen, x, resolve, reject, notify);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// It's a value, create a fulfilled wrapper\n\t\t\t\t\t\tresolve(fulfilled(x));\n\t\t\t\t\t}\n\n\t\t\t\t} catch(e) {\n\t\t\t\t\t// Something went wrong, reject\n\t\t\t\t\treject(e);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Create an already-fulfilled promise for the supplied value\n\t * @private\n\t * @param {*} value\n\t * @return {Promise} fulfilled promise\n\t */\n\tfunction fulfilled(value) {\n\t\tvar self = new Promise(function (onFulfilled) {\n\t\t\ttry {\n\t\t\t\treturn typeof onFulfilled == 'function'\n\t\t\t\t\t? coerce(onFulfilled(value)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn rejected(e);\n\t\t\t}\n\t\t}, function() {\n\t\t\treturn toFulfilledState(value);\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Create an already-rejected promise with the supplied rejection reason.\n\t * @private\n\t * @param {*} reason\n\t * @return {Promise} rejected promise\n\t */\n\tfunction rejected(reason) {\n\t\tvar self = new Promise(function (_, onRejected) {\n\t\t\ttry {\n\t\t\t\treturn typeof onRejected == 'function'\n\t\t\t\t\t? coerce(onRejected(reason)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn rejected(e);\n\t\t\t}\n\t\t}, function() {\n\t\t\treturn toRejectedState(reason);\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Create a progress promise with the supplied update.\n\t * @private\n\t * @param {*} update\n\t * @return {Promise} progress promise\n\t */\n\tfunction progressing(update) {\n\t\tvar self = new Promise(function (_, __, onProgress) {\n\t\t\ttry {\n\t\t\t\treturn typeof onProgress == 'function'\n\t\t\t\t\t? progressing(onProgress(update)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn progressing(e);\n\t\t\t}\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Schedule a task that will process a list of handlers\n\t * in the next queue drain run.\n\t * @private\n\t * @param {Array} handlers queue of handlers to execute\n\t * @param {*} value passed as the only arg to each handler\n\t */\n\tfunction scheduleHandlers(handlers, value) {\n\t\tenqueue(function() {\n\t\t\tvar handler, i = 0;\n\t\t\twhile (handler = handlers[i++]) {\n\t\t\t\thandler(value);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Determines if promiseOrValue is a promise or not\n\t *\n\t * @param {*} promiseOrValue anything\n\t * @returns {boolean} true if promiseOrValue is a {@link Promise}\n\t */\n\tfunction isPromise(promiseOrValue) {\n\t\treturn promiseOrValue && typeof promiseOrValue.then === 'function';\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * howMany of the supplied promisesOrValues have resolved, or will reject when\n\t * it becomes impossible for howMany to resolve, for example, when\n\t * (promisesOrValues.length - howMany) + 1 input promises reject.\n\t *\n\t * @param {Array} promisesOrValues array of anything, may contain a mix\n\t *      of promises and values\n\t * @param howMany {number} number of promisesOrValues to resolve\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise} promise that will resolve to an array of howMany values that\n\t *  resolved first, or will reject with an array of\n\t *  (promisesOrValues.length - howMany) + 1 rejection reasons.\n\t */\n\tfunction some(promisesOrValues, howMany, onFulfilled, onRejected, onProgress) {\n\n\t\treturn when(promisesOrValues, function(promisesOrValues) {\n\n\t\t\treturn promise(resolveSome).then(onFulfilled, onRejected, onProgress);\n\n\t\t\tfunction resolveSome(resolve, reject, notify) {\n\t\t\t\tvar toResolve, toReject, values, reasons, fulfillOne, rejectOne, len, i;\n\n\t\t\t\tlen = promisesOrValues.length >>> 0;\n\n\t\t\t\ttoResolve = Math.max(0, Math.min(howMany, len));\n\t\t\t\tvalues = [];\n\n\t\t\t\ttoReject = (len - toResolve) + 1;\n\t\t\t\treasons = [];\n\n\t\t\t\t// No items in the input, resolve immediately\n\t\t\t\tif (!toResolve) {\n\t\t\t\t\tresolve(values);\n\n\t\t\t\t} else {\n\t\t\t\t\trejectOne = function(reason) {\n\t\t\t\t\t\treasons.push(reason);\n\t\t\t\t\t\tif(!--toReject) {\n\t\t\t\t\t\t\tfulfillOne = rejectOne = identity;\n\t\t\t\t\t\t\treject(reasons);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tfulfillOne = function(val) {\n\t\t\t\t\t\t// This orders the values based on promise resolution order\n\t\t\t\t\t\tvalues.push(val);\n\t\t\t\t\t\tif (!--toResolve) {\n\t\t\t\t\t\t\tfulfillOne = rejectOne = identity;\n\t\t\t\t\t\t\tresolve(values);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tfor(i = 0; i < len; ++i) {\n\t\t\t\t\t\tif(i in promisesOrValues) {\n\t\t\t\t\t\t\twhen(promisesOrValues[i], fulfiller, rejecter, notify);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction rejecter(reason) {\n\t\t\t\t\trejectOne(reason);\n\t\t\t\t}\n\n\t\t\t\tfunction fulfiller(val) {\n\t\t\t\t\tfulfillOne(val);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * any one of the supplied promisesOrValues has resolved or will reject when\n\t * *all* promisesOrValues have rejected.\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise} promise that will resolve to the value that resolved first, or\n\t * will reject with an array of all rejected inputs.\n\t */\n\tfunction any(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\n\t\tfunction unwrapSingleResult(val) {\n\t\t\treturn onFulfilled ? onFulfilled(val[0]) : val[0];\n\t\t}\n\n\t\treturn some(promisesOrValues, 1, unwrapSingleResult, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Return a promise that will resolve only once all the supplied promisesOrValues\n\t * have resolved. The resolution value of the returned promise will be an array\n\t * containing the resolution values of each of the promisesOrValues.\n\t * @memberOf when\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise}\n\t */\n\tfunction all(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\t\treturn _map(promisesOrValues, identity).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Joins multiple promises into a single returned promise.\n\t * @return {Promise} a promise that will fulfill when *all* the input promises\n\t * have fulfilled, or will reject when *any one* of the input promises rejects.\n\t */\n\tfunction join(/* ...promises */) {\n\t\treturn _map(arguments, identity);\n\t}\n\n\t/**\n\t * Settles all input promises such that they are guaranteed not to\n\t * be pending once the returned promise fulfills. The returned promise\n\t * will always fulfill, except in the case where `array` is a promise\n\t * that rejects.\n\t * @param {Array|Promise} array or promise for array of promises to settle\n\t * @returns {Promise} promise that always fulfills with an array of\n\t *  outcome snapshots for each input promise.\n\t */\n\tfunction settle(array) {\n\t\treturn _map(array, toFulfilledState, toRejectedState);\n\t}\n\n\t/**\n\t * Promise-aware array map function, similar to `Array.prototype.map()`,\n\t * but input array may contain promises or values.\n\t * @param {Array|Promise} array array of anything, may contain promises and values\n\t * @param {function} mapFunc map function which may return a promise or value\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction map(array, mapFunc) {\n\t\treturn _map(array, mapFunc);\n\t}\n\n\t/**\n\t * Internal map that allows a fallback to handle rejections\n\t * @param {Array|Promise} array array of anything, may contain promises and values\n\t * @param {function} mapFunc map function which may return a promise or value\n\t * @param {function?} fallback function to handle rejected promises\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction _map(array, mapFunc, fallback) {\n\t\treturn when(array, function(array) {\n\n\t\t\treturn promise(resolveMap);\n\n\t\t\tfunction resolveMap(resolve, reject, notify) {\n\t\t\t\tvar results, len, toResolve, i;\n\n\t\t\t\t// Since we know the resulting length, we can preallocate the results\n\t\t\t\t// array to avoid array expansions.\n\t\t\t\ttoResolve = len = array.length >>> 0;\n\t\t\t\tresults = [];\n\n\t\t\t\tif(!toResolve) {\n\t\t\t\t\tresolve(results);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Since mapFunc may be async, get all invocations of it into flight\n\t\t\t\tfor(i = 0; i < len; i++) {\n\t\t\t\t\tif(i in array) {\n\t\t\t\t\t\tresolveOne(array[i], i);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t--toResolve;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction resolveOne(item, i) {\n\t\t\t\t\twhen(item, mapFunc, fallback).then(function(mapped) {\n\t\t\t\t\t\tresults[i] = mapped;\n\n\t\t\t\t\t\tif(!--toResolve) {\n\t\t\t\t\t\t\tresolve(results);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, reject, notify);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n\t * input may contain promises and/or values, and reduceFunc\n\t * may return either a value or a promise, *and* initialValue may\n\t * be a promise for the starting value.\n\t *\n\t * @param {Array|Promise} promise array or promise for an array of anything,\n\t *      may contain a mix of promises and values.\n\t * @param {function} reduceFunc reduce function reduce(currentValue, nextValue, index, total),\n\t *      where total is the total number of items being reduced, and will be the same\n\t *      in each call to reduceFunc.\n\t * @returns {Promise} that will resolve to the final reduced value\n\t */\n\tfunction reduce(promise, reduceFunc /*, initialValue */) {\n\t\tvar args = fcall(slice, arguments, 1);\n\n\t\treturn when(promise, function(array) {\n\t\t\tvar total;\n\n\t\t\ttotal = array.length;\n\n\t\t\t// Wrap the supplied reduceFunc with one that handles promises and then\n\t\t\t// delegates to the supplied.\n\t\t\targs[0] = function (current, val, i) {\n\t\t\t\treturn when(current, function (c) {\n\t\t\t\t\treturn when(val, function (value) {\n\t\t\t\t\t\treturn reduceFunc(c, value, i, total);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\t\treturn reduceArray.apply(array, args);\n\t\t});\n\t}\n\n\t// Snapshot states\n\n\t/**\n\t * Creates a fulfilled state snapshot\n\t * @private\n\t * @param {*} x any value\n\t * @returns {{state:'fulfilled',value:*}}\n\t */\n\tfunction toFulfilledState(x) {\n\t\treturn { state: 'fulfilled', value: x };\n\t}\n\n\t/**\n\t * Creates a rejected state snapshot\n\t * @private\n\t * @param {*} x any reason\n\t * @returns {{state:'rejected',reason:*}}\n\t */\n\tfunction toRejectedState(x) {\n\t\treturn { state: 'rejected', reason: x };\n\t}\n\n\t/**\n\t * Creates a pending state snapshot\n\t * @private\n\t * @returns {{state:'pending'}}\n\t */\n\tfunction toPendingState() {\n\t\treturn { state: 'pending' };\n\t}\n\n\t//\n\t// Utilities, etc.\n\t//\n\n\tvar reduceArray, slice, fcall, nextTick, handlerQueue,\n\t\tsetTimeout, funcProto, call, arrayProto, monitorApi, undef;\n\n\t//\n\t// Shared handler queue processing\n\t//\n\t// Credit to Twisol (https://github.com/Twisol) for suggesting\n\t// this type of extensible queue + trampoline approach for\n\t// next-tick conflation.\n\n\thandlerQueue = [];\n\n\t/**\n\t * Enqueue a task. If the queue is not currently scheduled to be\n\t * drained, schedule it.\n\t * @param {function} task\n\t */\n\tfunction enqueue(task) {\n\t\tif(handlerQueue.push(task) === 1) {\n\t\t\tnextTick(drainQueue);\n\t\t}\n\t}\n\n\t/**\n\t * Drain the handler queue entirely, being careful to allow the\n\t * queue to be extended while it is being processed, and to continue\n\t * processing until it is truly empty.\n\t */\n\tfunction drainQueue() {\n\t\tvar task, i = 0;\n\n\t\twhile(task = handlerQueue[i++]) {\n\t\t\ttask();\n\t\t}\n\n\t\thandlerQueue = [];\n\t}\n\n\t//\n\t// Capture function and array utils\n\t//\n\t/*global setImmediate,process,vertx*/\n\n\t// Allow attaching the monitor to when() if env has no console\n\tmonitorApi = typeof console != 'undefined' ? console : when;\n\n\t// capture setTimeout to avoid being caught by fake timers used in time based tests\n\tsetTimeout = global.setTimeout;\n\t// Prefer setImmediate, cascade to node, vertx and finally setTimeout\n\tnextTick = typeof setImmediate === 'function' ? setImmediate.bind(global)\n\t\t: typeof process === 'object' && process.nextTick ? process.nextTick\n\t\t: typeof vertx === 'object' ? vertx.runOnLoop // vert.x\n\t\t\t: function(task) { setTimeout(task, 0); }; // fallback\n\n\t// Safe function calls\n\tfuncProto = Function.prototype;\n\tcall = funcProto.call;\n\tfcall = funcProto.bind\n\t\t? call.bind(call)\n\t\t: function(f, context) {\n\t\t\treturn f.apply(context, slice.call(arguments, 2));\n\t\t};\n\n\t// Safe array ops\n\tarrayProto = [];\n\tslice = arrayProto.slice;\n\n\t// ES5 reduce implementation if native not available\n\t// See: http://es5.github.com/#x15.4.4.21 as there are many\n\t// specifics and edge cases.  ES5 dictates that reduce.length === 1\n\t// This implementation deviates from ES5 spec in the following ways:\n\t// 1. It does not check if reduceFunc is a Callable\n\treduceArray = arrayProto.reduce ||\n\t\tfunction(reduceFunc /*, initialValue */) {\n\t\t\t/*jshint maxcomplexity: 7*/\n\t\t\tvar arr, args, reduced, len, i;\n\n\t\t\ti = 0;\n\t\t\tarr = Object(this);\n\t\t\tlen = arr.length >>> 0;\n\t\t\targs = arguments;\n\n\t\t\t// If no initialValue, use first item of array (we know length !== 0 here)\n\t\t\t// and adjust i to start at second item\n\t\t\tif(args.length <= 1) {\n\t\t\t\t// Skip to the first real element in the array\n\t\t\t\tfor(;;) {\n\t\t\t\t\tif(i in arr) {\n\t\t\t\t\t\treduced = arr[i++];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If we reached the end of the array without finding any real\n\t\t\t\t\t// elements, it's a TypeError\n\t\t\t\t\tif(++i >= len) {\n\t\t\t\t\t\tthrow new TypeError();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If initialValue provided, use it\n\t\t\t\treduced = args[1];\n\t\t\t}\n\n\t\t\t// Do the actual reduce\n\t\t\tfor(;i < len; ++i) {\n\t\t\t\tif(i in arr) {\n\t\t\t\t\treduced = reduceFunc(reduced, arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn reduced;\n\t\t};\n\n\tfunction identity(x) {\n\t\treturn x;\n\t}\n\n\treturn when;\n});\n})(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(); },\n\tthis\n);\n","modules":[{"pos":428,"count":19,"factory":true,"id":"when/when"}]}{"absId":"when/when","text":"/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * A lightweight CommonJS Promises/A and when() implementation\n * when is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author Brian Cavalier\n * @author John Hann\n * @version 2.2.1\n */\n(function(define, global) { 'use strict';\ndefine(function () {\n\n\t// Public API\n\n\twhen.promise   = promise;    // Create a pending promise\n\twhen.resolve   = resolve;    // Create a resolved promise\n\twhen.reject    = reject;     // Create a rejected promise\n\twhen.defer     = defer;      // Create a {promise, resolver} pair\n\n\twhen.join      = join;       // Join 2 or more promises\n\n\twhen.all       = all;        // Resolve a list of promises\n\twhen.map       = map;        // Array.map() for promises\n\twhen.reduce    = reduce;     // Array.reduce() for promises\n\twhen.settle    = settle;     // Settle a list of promises\n\n\twhen.any       = any;        // One-winner race\n\twhen.some      = some;       // Multi-winner race\n\n\twhen.isPromise = isPromise;  // Determine if a thing is a promise\n\n\n\t/**\n\t * Register an observer for a promise or immediate value.\n\t *\n\t * @param {*} promiseOrValue\n\t * @param {function?} [onFulfilled] callback to be called when promiseOrValue is\n\t *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n\t *   will be invoked immediately.\n\t * @param {function?} [onRejected] callback to be called when promiseOrValue is\n\t *   rejected.\n\t * @param {function?} [onProgress] callback to be called when progress updates\n\t *   are issued for promiseOrValue.\n\t * @returns {Promise} a new {@link Promise} that will complete with the return\n\t *   value of callback or errback or the completion value of promiseOrValue if\n\t *   callback and/or errback is not supplied.\n\t */\n\tfunction when(promiseOrValue, onFulfilled, onRejected, onProgress) {\n\t\t// Get a trusted promise for the input promiseOrValue, and then\n\t\t// register promise handlers\n\t\treturn resolve(promiseOrValue).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Trusted Promise constructor.  A Promise created from this constructor is\n\t * a trusted when.js promise.  Any other duck-typed promise is considered\n\t * untrusted.\n\t * @constructor\n\t * @name Promise\n\t */\n\tfunction Promise(then, inspect) {\n\t\tthis.then = then;\n\t\tthis.inspect = inspect;\n\t}\n\n\tPromise.prototype = {\n\t\t/**\n\t\t * Register a rejection handler.  Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @return {Promise}\n\t\t */\n\t\totherwise: function(onRejected) {\n\t\t\treturn this.then(undef, onRejected);\n\t\t},\n\n\t\t/**\n\t\t * Ensures that onFulfilledOrRejected will be called regardless of whether\n\t\t * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT\n\t\t * receive the promises' value or reason.  Any returned value will be disregarded.\n\t\t * onFulfilledOrRejected may throw or return a rejected promise to signal\n\t\t * an additional error.\n\t\t * @param {function} onFulfilledOrRejected handler to be called regardless of\n\t\t *  fulfillment or rejection\n\t\t * @returns {Promise}\n\t\t */\n\t\tensure: function(onFulfilledOrRejected) {\n\t\t\treturn this.then(injectHandler, injectHandler)['yield'](this);\n\n\t\t\tfunction injectHandler() {\n\t\t\t\treturn resolve(onFulfilledOrRejected());\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Shortcut for .then(function() { return value; })\n\t\t * @param  {*} value\n\t\t * @return {Promise} a promise that:\n\t\t *  - is fulfilled if value is not a promise, or\n\t\t *  - if value is a promise, will fulfill with its value, or reject\n\t\t *    with its reason.\n\t\t */\n\t\t'yield': function(value) {\n\t\t\treturn this.then(function() {\n\t\t\t\treturn value;\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Assumes that this promise will fulfill with an array, and arranges\n\t\t * for the onFulfilled to be called with the array as its argument list\n\t\t * i.e. onFulfilled.apply(undefined, array).\n\t\t * @param {function} onFulfilled function to receive spread arguments\n\t\t * @return {Promise}\n\t\t */\n\t\tspread: function(onFulfilled) {\n\t\t\treturn this.then(function(array) {\n\t\t\t\t// array may contain promises, so resolve its contents.\n\t\t\t\treturn all(array, function(array) {\n\t\t\t\t\treturn onFulfilled.apply(undef, array);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Shortcut for .then(onFulfilledOrRejected, onFulfilledOrRejected)\n\t\t * @deprecated\n\t\t */\n\t\talways: function(onFulfilledOrRejected, onProgress) {\n\t\t\treturn this.then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress);\n\t\t}\n\t};\n\n\t/**\n\t * Returns a resolved promise. The returned promise will be\n\t *  - fulfilled with promiseOrValue if it is a value, or\n\t *  - if promiseOrValue is a promise\n\t *    - fulfilled with promiseOrValue's value after it is fulfilled\n\t *    - rejected with promiseOrValue's reason after it is rejected\n\t * @param  {*} value\n\t * @return {Promise}\n\t */\n\tfunction resolve(value) {\n\t\treturn promise(function(resolve) {\n\t\t\tresolve(value);\n\t\t});\n\t}\n\n\t/**\n\t * Returns a rejected promise for the supplied promiseOrValue.  The returned\n\t * promise will be rejected with:\n\t * - promiseOrValue, if it is a value, or\n\t * - if promiseOrValue is a promise\n\t *   - promiseOrValue's value after it is fulfilled\n\t *   - promiseOrValue's reason after it is rejected\n\t * @param {*} promiseOrValue the rejected value of the returned {@link Promise}\n\t * @return {Promise} rejected {@link Promise}\n\t */\n\tfunction reject(promiseOrValue) {\n\t\treturn when(promiseOrValue, rejected);\n\t}\n\n\t/**\n\t * Creates a {promise, resolver} pair, either or both of which\n\t * may be given out safely to consumers.\n\t * The resolver has resolve, reject, and progress.  The promise\n\t * has then plus extended promise API.\n\t *\n\t * @return {{\n\t * promise: Promise,\n\t * resolve: function:Promise,\n\t * reject: function:Promise,\n\t * notify: function:Promise\n\t * resolver: {\n\t *\tresolve: function:Promise,\n\t *\treject: function:Promise,\n\t *\tnotify: function:Promise\n\t * }}}\n\t */\n\tfunction defer() {\n\t\tvar deferred, pending, resolved;\n\n\t\t// Optimize object shape\n\t\tdeferred = {\n\t\t\tpromise: undef, resolve: undef, reject: undef, notify: undef,\n\t\t\tresolver: { resolve: undef, reject: undef, notify: undef }\n\t\t};\n\n\t\tdeferred.promise = pending = promise(makeDeferred);\n\n\t\treturn deferred;\n\n\t\tfunction makeDeferred(resolvePending, rejectPending, notifyPending) {\n\t\t\tdeferred.resolve = deferred.resolver.resolve = function(value) {\n\t\t\t\tif(resolved) {\n\t\t\t\t\treturn resolve(value);\n\t\t\t\t}\n\t\t\t\tresolved = true;\n\t\t\t\tresolvePending(value);\n\t\t\t\treturn pending;\n\t\t\t};\n\n\t\t\tdeferred.reject  = deferred.resolver.reject  = function(reason) {\n\t\t\t\tif(resolved) {\n\t\t\t\t\treturn resolve(rejected(reason));\n\t\t\t\t}\n\t\t\t\tresolved = true;\n\t\t\t\trejectPending(reason);\n\t\t\t\treturn pending;\n\t\t\t};\n\n\t\t\tdeferred.notify  = deferred.resolver.notify  = function(update) {\n\t\t\t\tnotifyPending(update);\n\t\t\t\treturn update;\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new promise whose fate is determined by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t */\n\tfunction promise(resolver) {\n\t\treturn _promise(resolver, monitorApi.PromiseStatus && monitorApi.PromiseStatus());\n\t}\n\n\t/**\n\t * Creates a new promise, linked to parent, whose fate is determined\n\t * by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @param {Promise?} status promise from which the new promise is begotten\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t * @private\n\t */\n\tfunction _promise(resolver, status) {\n\t\tvar self, value, handlers = [];\n\n\t\tself = new Promise(then, inspect);\n\n\t\t// Call the provider resolver to seal the promise's fate\n\t\ttry {\n\t\t\tresolver(promiseResolve, promiseReject, promiseNotify);\n\t\t} catch(e) {\n\t\t\tpromiseReject(e);\n\t\t}\n\n\t\t// Return the promise\n\t\treturn self;\n\n\t\t/**\n\t\t * Register handlers for this promise.\n\t\t * @param [onFulfilled] {Function} fulfillment handler\n\t\t * @param [onRejected] {Function} rejection handler\n\t\t * @param [onProgress] {Function} progress handler\n\t\t * @return {Promise} new Promise\n\t\t */\n\t\tfunction then(onFulfilled, onRejected, onProgress) {\n\t\t\tvar next = _promise(function(resolve, reject, notify) {\n\t\t\t\t// if not resolved, push onto handlers, otherwise execute asap\n\t\t\t\t// but not in the current stack\n\t\t\t\thandlers ? handlers.push(run) : enqueue(function() { run(value); });\n\n\t\t\t\tfunction run(p) {\n\t\t\t\t\tp.then(onFulfilled, onRejected, onProgress)\n\t\t\t\t\t\t.then(resolve, reject, notify);\n\t\t\t\t}\n\n\t\t\t}, status && status.observed());\n\n\t\t\treturn next;\n\t\t}\n\n\t\tfunction inspect() {\n\t\t\treturn value ? value.inspect() : toPendingState();\n\t\t}\n\n\t\t/**\n\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t * all listeners of the ultimate fulfillment or rejection\n\t\t * @param {*|Promise} val resolution value\n\t\t */\n\t\tfunction promiseResolve(val) {\n\t\t\tif(!handlers) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvalue = coerce(val);\n\t\t\tscheduleHandlers(handlers, value);\n\t\t\thandlers = undef;\n\n\t\t\tif (status) {\n\t\t\t\tvalue.then(\n\t\t\t\t\tfunction () { status.fulfilled(); },\n\t\t\t\t\tfunction(r) { status.rejected(r); }\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Reject this promise with the supplied reason, which will be used verbatim.\n\t\t * @param {*} reason reason for the rejection\n\t\t */\n\t\tfunction promiseReject(reason) {\n\t\t\tpromiseResolve(rejected(reason));\n\t\t}\n\n\t\t/**\n\t\t * Issue a progress event, notifying all progress listeners\n\t\t * @param {*} update progress event payload to pass to all listeners\n\t\t */\n\t\tfunction promiseNotify(update) {\n\t\t\tif(handlers) {\n\t\t\t\tscheduleHandlers(handlers, progressing(update));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Coerces x to a trusted Promise\n\t *\n\t * @private\n\t * @param {*} x thing to coerce\n\t * @returns {Promise} Guaranteed to return a trusted Promise.  If x\n\t *   is trusted, returns x, otherwise, returns a new, trusted, already-resolved\n\t *   Promise whose resolution value is:\n\t *   * the resolution value of x if it's a foreign promise, or\n\t *   * x if it's a value\n\t */\n\tfunction coerce(x) {\n\t\tif(x instanceof Promise) {\n\t\t\treturn x;\n\t\t}\n\n\t\tif (!(x === Object(x) && 'then' in x)) {\n\t\t\treturn fulfilled(x);\n\t\t}\n\n\t\treturn promise(function(resolve, reject, notify) {\n\t\t\tenqueue(function() {\n\t\t\t\ttry {\n\t\t\t\t\t// We must check and assimilate in the same tick, but not the\n\t\t\t\t\t// current tick, careful only to access promiseOrValue.then once.\n\t\t\t\t\tvar untrustedThen = x.then;\n\n\t\t\t\t\tif(typeof untrustedThen === 'function') {\n\t\t\t\t\t\tfcall(untrustedThen, x, resolve, reject, notify);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// It's a value, create a fulfilled wrapper\n\t\t\t\t\t\tresolve(fulfilled(x));\n\t\t\t\t\t}\n\n\t\t\t\t} catch(e) {\n\t\t\t\t\t// Something went wrong, reject\n\t\t\t\t\treject(e);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Create an already-fulfilled promise for the supplied value\n\t * @private\n\t * @param {*} value\n\t * @return {Promise} fulfilled promise\n\t */\n\tfunction fulfilled(value) {\n\t\tvar self = new Promise(function (onFulfilled) {\n\t\t\ttry {\n\t\t\t\treturn typeof onFulfilled == 'function'\n\t\t\t\t\t? coerce(onFulfilled(value)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn rejected(e);\n\t\t\t}\n\t\t}, function() {\n\t\t\treturn toFulfilledState(value);\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Create an already-rejected promise with the supplied rejection reason.\n\t * @private\n\t * @param {*} reason\n\t * @return {Promise} rejected promise\n\t */\n\tfunction rejected(reason) {\n\t\tvar self = new Promise(function (_, onRejected) {\n\t\t\ttry {\n\t\t\t\treturn typeof onRejected == 'function'\n\t\t\t\t\t? coerce(onRejected(reason)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn rejected(e);\n\t\t\t}\n\t\t}, function() {\n\t\t\treturn toRejectedState(reason);\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Create a progress promise with the supplied update.\n\t * @private\n\t * @param {*} update\n\t * @return {Promise} progress promise\n\t */\n\tfunction progressing(update) {\n\t\tvar self = new Promise(function (_, __, onProgress) {\n\t\t\ttry {\n\t\t\t\treturn typeof onProgress == 'function'\n\t\t\t\t\t? progressing(onProgress(update)) : self;\n\t\t\t} catch (e) {\n\t\t\t\treturn progressing(e);\n\t\t\t}\n\t\t});\n\n\t\treturn self;\n\t}\n\n\t/**\n\t * Schedule a task that will process a list of handlers\n\t * in the next queue drain run.\n\t * @private\n\t * @param {Array} handlers queue of handlers to execute\n\t * @param {*} value passed as the only arg to each handler\n\t */\n\tfunction scheduleHandlers(handlers, value) {\n\t\tenqueue(function() {\n\t\t\tvar handler, i = 0;\n\t\t\twhile (handler = handlers[i++]) {\n\t\t\t\thandler(value);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Determines if promiseOrValue is a promise or not\n\t *\n\t * @param {*} promiseOrValue anything\n\t * @returns {boolean} true if promiseOrValue is a {@link Promise}\n\t */\n\tfunction isPromise(promiseOrValue) {\n\t\treturn promiseOrValue && typeof promiseOrValue.then === 'function';\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * howMany of the supplied promisesOrValues have resolved, or will reject when\n\t * it becomes impossible for howMany to resolve, for example, when\n\t * (promisesOrValues.length - howMany) + 1 input promises reject.\n\t *\n\t * @param {Array} promisesOrValues array of anything, may contain a mix\n\t *      of promises and values\n\t * @param howMany {number} number of promisesOrValues to resolve\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise} promise that will resolve to an array of howMany values that\n\t *  resolved first, or will reject with an array of\n\t *  (promisesOrValues.length - howMany) + 1 rejection reasons.\n\t */\n\tfunction some(promisesOrValues, howMany, onFulfilled, onRejected, onProgress) {\n\n\t\treturn when(promisesOrValues, function(promisesOrValues) {\n\n\t\t\treturn promise(resolveSome).then(onFulfilled, onRejected, onProgress);\n\n\t\t\tfunction resolveSome(resolve, reject, notify) {\n\t\t\t\tvar toResolve, toReject, values, reasons, fulfillOne, rejectOne, len, i;\n\n\t\t\t\tlen = promisesOrValues.length >>> 0;\n\n\t\t\t\ttoResolve = Math.max(0, Math.min(howMany, len));\n\t\t\t\tvalues = [];\n\n\t\t\t\ttoReject = (len - toResolve) + 1;\n\t\t\t\treasons = [];\n\n\t\t\t\t// No items in the input, resolve immediately\n\t\t\t\tif (!toResolve) {\n\t\t\t\t\tresolve(values);\n\n\t\t\t\t} else {\n\t\t\t\t\trejectOne = function(reason) {\n\t\t\t\t\t\treasons.push(reason);\n\t\t\t\t\t\tif(!--toReject) {\n\t\t\t\t\t\t\tfulfillOne = rejectOne = identity;\n\t\t\t\t\t\t\treject(reasons);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tfulfillOne = function(val) {\n\t\t\t\t\t\t// This orders the values based on promise resolution order\n\t\t\t\t\t\tvalues.push(val);\n\t\t\t\t\t\tif (!--toResolve) {\n\t\t\t\t\t\t\tfulfillOne = rejectOne = identity;\n\t\t\t\t\t\t\tresolve(values);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tfor(i = 0; i < len; ++i) {\n\t\t\t\t\t\tif(i in promisesOrValues) {\n\t\t\t\t\t\t\twhen(promisesOrValues[i], fulfiller, rejecter, notify);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction rejecter(reason) {\n\t\t\t\t\trejectOne(reason);\n\t\t\t\t}\n\n\t\t\t\tfunction fulfiller(val) {\n\t\t\t\t\tfulfillOne(val);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * any one of the supplied promisesOrValues has resolved or will reject when\n\t * *all* promisesOrValues have rejected.\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise} promise that will resolve to the value that resolved first, or\n\t * will reject with an array of all rejected inputs.\n\t */\n\tfunction any(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\n\t\tfunction unwrapSingleResult(val) {\n\t\t\treturn onFulfilled ? onFulfilled(val[0]) : val[0];\n\t\t}\n\n\t\treturn some(promisesOrValues, 1, unwrapSingleResult, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Return a promise that will resolve only once all the supplied promisesOrValues\n\t * have resolved. The resolution value of the returned promise will be an array\n\t * containing the resolution values of each of the promisesOrValues.\n\t * @memberOf when\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise}\n\t */\n\tfunction all(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\t\treturn _map(promisesOrValues, identity).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Joins multiple promises into a single returned promise.\n\t * @return {Promise} a promise that will fulfill when *all* the input promises\n\t * have fulfilled, or will reject when *any one* of the input promises rejects.\n\t */\n\tfunction join(/* ...promises */) {\n\t\treturn _map(arguments, identity);\n\t}\n\n\t/**\n\t * Settles all input promises such that they are guaranteed not to\n\t * be pending once the returned promise fulfills. The returned promise\n\t * will always fulfill, except in the case where `array` is a promise\n\t * that rejects.\n\t * @param {Array|Promise} array or promise for array of promises to settle\n\t * @returns {Promise} promise that always fulfills with an array of\n\t *  outcome snapshots for each input promise.\n\t */\n\tfunction settle(array) {\n\t\treturn _map(array, toFulfilledState, toRejectedState);\n\t}\n\n\t/**\n\t * Promise-aware array map function, similar to `Array.prototype.map()`,\n\t * but input array may contain promises or values.\n\t * @param {Array|Promise} array array of anything, may contain promises and values\n\t * @param {function} mapFunc map function which may return a promise or value\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction map(array, mapFunc) {\n\t\treturn _map(array, mapFunc);\n\t}\n\n\t/**\n\t * Internal map that allows a fallback to handle rejections\n\t * @param {Array|Promise} array array of anything, may contain promises and values\n\t * @param {function} mapFunc map function which may return a promise or value\n\t * @param {function?} fallback function to handle rejected promises\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction _map(array, mapFunc, fallback) {\n\t\treturn when(array, function(array) {\n\n\t\t\treturn promise(resolveMap);\n\n\t\t\tfunction resolveMap(resolve, reject, notify) {\n\t\t\t\tvar results, len, toResolve, i;\n\n\t\t\t\t// Since we know the resulting length, we can preallocate the results\n\t\t\t\t// array to avoid array expansions.\n\t\t\t\ttoResolve = len = array.length >>> 0;\n\t\t\t\tresults = [];\n\n\t\t\t\tif(!toResolve) {\n\t\t\t\t\tresolve(results);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Since mapFunc may be async, get all invocations of it into flight\n\t\t\t\tfor(i = 0; i < len; i++) {\n\t\t\t\t\tif(i in array) {\n\t\t\t\t\t\tresolveOne(array[i], i);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t--toResolve;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction resolveOne(item, i) {\n\t\t\t\t\twhen(item, mapFunc, fallback).then(function(mapped) {\n\t\t\t\t\t\tresults[i] = mapped;\n\n\t\t\t\t\t\tif(!--toResolve) {\n\t\t\t\t\t\t\tresolve(results);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, reject, notify);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n\t * input may contain promises and/or values, and reduceFunc\n\t * may return either a value or a promise, *and* initialValue may\n\t * be a promise for the starting value.\n\t *\n\t * @param {Array|Promise} promise array or promise for an array of anything,\n\t *      may contain a mix of promises and values.\n\t * @param {function} reduceFunc reduce function reduce(currentValue, nextValue, index, total),\n\t *      where total is the total number of items being reduced, and will be the same\n\t *      in each call to reduceFunc.\n\t * @returns {Promise} that will resolve to the final reduced value\n\t */\n\tfunction reduce(promise, reduceFunc /*, initialValue */) {\n\t\tvar args = fcall(slice, arguments, 1);\n\n\t\treturn when(promise, function(array) {\n\t\t\tvar total;\n\n\t\t\ttotal = array.length;\n\n\t\t\t// Wrap the supplied reduceFunc with one that handles promises and then\n\t\t\t// delegates to the supplied.\n\t\t\targs[0] = function (current, val, i) {\n\t\t\t\treturn when(current, function (c) {\n\t\t\t\t\treturn when(val, function (value) {\n\t\t\t\t\t\treturn reduceFunc(c, value, i, total);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\t\treturn reduceArray.apply(array, args);\n\t\t});\n\t}\n\n\t// Snapshot states\n\n\t/**\n\t * Creates a fulfilled state snapshot\n\t * @private\n\t * @param {*} x any value\n\t * @returns {{state:'fulfilled',value:*}}\n\t */\n\tfunction toFulfilledState(x) {\n\t\treturn { state: 'fulfilled', value: x };\n\t}\n\n\t/**\n\t * Creates a rejected state snapshot\n\t * @private\n\t * @param {*} x any reason\n\t * @returns {{state:'rejected',reason:*}}\n\t */\n\tfunction toRejectedState(x) {\n\t\treturn { state: 'rejected', reason: x };\n\t}\n\n\t/**\n\t * Creates a pending state snapshot\n\t * @private\n\t * @returns {{state:'pending'}}\n\t */\n\tfunction toPendingState() {\n\t\treturn { state: 'pending' };\n\t}\n\n\t//\n\t// Utilities, etc.\n\t//\n\n\tvar reduceArray, slice, fcall, nextTick, handlerQueue,\n\t\tsetTimeout, funcProto, call, arrayProto, monitorApi, undef;\n\n\t//\n\t// Shared handler queue processing\n\t//\n\t// Credit to Twisol (https://github.com/Twisol) for suggesting\n\t// this type of extensible queue + trampoline approach for\n\t// next-tick conflation.\n\n\thandlerQueue = [];\n\n\t/**\n\t * Enqueue a task. If the queue is not currently scheduled to be\n\t * drained, schedule it.\n\t * @param {function} task\n\t */\n\tfunction enqueue(task) {\n\t\tif(handlerQueue.push(task) === 1) {\n\t\t\tnextTick(drainQueue);\n\t\t}\n\t}\n\n\t/**\n\t * Drain the handler queue entirely, being careful to allow the\n\t * queue to be extended while it is being processed, and to continue\n\t * processing until it is truly empty.\n\t */\n\tfunction drainQueue() {\n\t\tvar task, i = 0;\n\n\t\twhile(task = handlerQueue[i++]) {\n\t\t\ttask();\n\t\t}\n\n\t\thandlerQueue = [];\n\t}\n\n\t//\n\t// Capture function and array utils\n\t//\n\t/*global setImmediate,process,vertx*/\n\n\t// Allow attaching the monitor to when() if env has no console\n\tmonitorApi = typeof console != 'undefined' ? console : when;\n\n\t// capture setTimeout to avoid being caught by fake timers used in time based tests\n\tsetTimeout = global.setTimeout;\n\t// Prefer setImmediate, cascade to node, vertx and finally setTimeout\n\tnextTick = typeof setImmediate === 'function' ? setImmediate.bind(global)\n\t\t: typeof process === 'object' && process.nextTick ? process.nextTick\n\t\t: typeof vertx === 'object' ? vertx.runOnLoop // vert.x\n\t\t\t: function(task) { setTimeout(task, 0); }; // fallback\n\n\t// Safe function calls\n\tfuncProto = Function.prototype;\n\tcall = funcProto.call;\n\tfcall = funcProto.bind\n\t\t? call.bind(call)\n\t\t: function(f, context) {\n\t\t\treturn f.apply(context, slice.call(arguments, 2));\n\t\t};\n\n\t// Safe array ops\n\tarrayProto = [];\n\tslice = arrayProto.slice;\n\n\t// ES5 reduce implementation if native not available\n\t// See: http://es5.github.com/#x15.4.4.21 as there are many\n\t// specifics and edge cases.  ES5 dictates that reduce.length === 1\n\t// This implementation deviates from ES5 spec in the following ways:\n\t// 1. It does not check if reduceFunc is a Callable\n\treduceArray = arrayProto.reduce ||\n\t\tfunction(reduceFunc /*, initialValue */) {\n\t\t\t/*jshint maxcomplexity: 7*/\n\t\t\tvar arr, args, reduced, len, i;\n\n\t\t\ti = 0;\n\t\t\tarr = Object(this);\n\t\t\tlen = arr.length >>> 0;\n\t\t\targs = arguments;\n\n\t\t\t// If no initialValue, use first item of array (we know length !== 0 here)\n\t\t\t// and adjust i to start at second item\n\t\t\tif(args.length <= 1) {\n\t\t\t\t// Skip to the first real element in the array\n\t\t\t\tfor(;;) {\n\t\t\t\t\tif(i in arr) {\n\t\t\t\t\t\treduced = arr[i++];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If we reached the end of the array without finding any real\n\t\t\t\t\t// elements, it's a TypeError\n\t\t\t\t\tif(++i >= len) {\n\t\t\t\t\t\tthrow new TypeError();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If initialValue provided, use it\n\t\t\t\treduced = args[1];\n\t\t\t}\n\n\t\t\t// Do the actual reduce\n\t\t\tfor(;i < len; ++i) {\n\t\t\t\tif(i in arr) {\n\t\t\t\t\treduced = reduceFunc(reduced, arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn reduced;\n\t\t};\n\n\tfunction identity(x) {\n\t\treturn x;\n\t}\n\n\treturn when;\n});\n})(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(); },\n\tthis\n);\n","modules":[{"pos":428,"count":19,"factory":true,"id":"when/when"}]}